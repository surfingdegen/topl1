{"ast":null,"code":"import * as abitype from 'abitype';\nimport * as Address from './Address.js';\nimport * as Bytes from './Bytes.js';\nimport * as Errors from './Errors.js';\nimport * as Hex from './Hex.js';\nimport * as internal from './internal/abiParameters.js';\nimport * as Cursor from './internal/cursor.js';\nimport * as Solidity from './Solidity.js';\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function decode(parameters, data) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    as = 'Array',\n    checksumAddress = false\n  } = options;\n  const bytes = typeof data === 'string' ? Bytes.fromHex(data) : data;\n  const cursor = Cursor.create(bytes);\n  if (Bytes.size(bytes) === 0 && parameters.length > 0) throw new ZeroDataError();\n  if (Bytes.size(bytes) && Bytes.size(bytes) < 32) throw new DataSizeTooSmallError({\n    data: typeof data === 'string' ? data : Hex.fromBytes(data),\n    parameters: parameters,\n    size: Bytes.size(bytes)\n  });\n  let consumed = 0;\n  const values = as === 'Array' ? [] : {};\n  for (let i = 0; i < parameters.length; ++i) {\n    var _param$name;\n    const param = parameters[i];\n    cursor.setPosition(consumed);\n    const [data, consumed_] = internal.decodeParameter(cursor, param, {\n      checksumAddress,\n      staticPosition: 0\n    });\n    consumed += consumed_;\n    if (as === 'Array') values.push(data);else values[(_param$name = param.name) !== null && _param$name !== void 0 ? _param$name : i] = data;\n  }\n  return values;\n}\n/**\n * Encodes primitive values into ABI encoded data as per the [Application Binary Interface (ABI) Specification](https://docs.soliditylang.org/en/latest/abi-spec).\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const data = AbiParameters.encode(\n *   AbiParameters.from(['string', 'uint', 'bool']),\n *   ['wagmi', 420n, true],\n * )\n * ```\n *\n * @example\n * ### JSON Parameters\n *\n * Specify **JSON ABI** Parameters as schema:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const data = AbiParameters.encode(\n *   [\n *     { type: 'string', name: 'name' },\n *     { type: 'uint', name: 'age' },\n *     { type: 'bool', name: 'isOwner' },\n *   ],\n *   ['wagmi', 420n, true],\n * )\n * ```\n *\n * @param parameters - The set of ABI parameters to encode, in the shape of the `inputs` or `outputs` attribute of an ABI Item. These parameters must include valid [ABI types](https://docs.soliditylang.org/en/latest/types.html).\n * @param values - The set of primitive values that correspond to the ABI types defined in `parameters`.\n * @returns ABI encoded data.\n */\nexport function encode(parameters, values, options) {\n  const {\n    checksumAddress = false\n  } = options !== null && options !== void 0 ? options : {};\n  if (parameters.length !== values.length) throw new LengthMismatchError({\n    expectedLength: parameters.length,\n    givenLength: values.length\n  });\n  // Prepare the parameters to determine dynamic types to encode.\n  const preparedParameters = internal.prepareParameters({\n    checksumAddress,\n    parameters: parameters,\n    values: values\n  });\n  const data = internal.encode(preparedParameters);\n  if (data.length === 0) return '0x';\n  return data;\n}\n/**\n * Encodes an array of primitive values to a [packed ABI encoding](https://docs.soliditylang.org/en/latest/abi-spec.html#non-standard-packed-mode).\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const encoded = AbiParameters.encodePacked(\n *   ['address', 'string'],\n *   ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 'hello world'],\n * )\n * // @log: '0xd8da6bf26964af9d7eed9e03e53415d37aa9604568656c6c6f20776f726c64'\n * ```\n *\n * @param types - Set of ABI types to pack encode.\n * @param values - The set of primitive values that correspond to the ABI types defined in `types`.\n * @returns The encoded packed data.\n */\nexport function encodePacked(types, values) {\n  if (types.length !== values.length) throw new LengthMismatchError({\n    expectedLength: types.length,\n    givenLength: values.length\n  });\n  const data = [];\n  for (let i = 0; i < types.length; i++) {\n    const type = types[i];\n    const value = values[i];\n    data.push(encodePacked.encode(type, value));\n  }\n  return Hex.concat(...data);\n}\n(function (encodePacked) {\n  // eslint-disable-next-line jsdoc/require-jsdoc\n  function encode(type, value) {\n    let isArray = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (type === 'address') {\n      const address = value;\n      Address.assert(address);\n      return Hex.padLeft(address.toLowerCase(), isArray ? 32 : 0);\n    }\n    if (type === 'string') return Hex.fromString(value);\n    if (type === 'bytes') return value;\n    if (type === 'bool') return Hex.padLeft(Hex.fromBoolean(value), isArray ? 32 : 1);\n    const intMatch = type.match(Solidity.integerRegex);\n    if (intMatch) {\n      const [_type, baseType, bits = '256'] = intMatch;\n      const size = Number.parseInt(bits, 10) / 8;\n      return Hex.fromNumber(value, {\n        size: isArray ? 32 : size,\n        signed: baseType === 'int'\n      });\n    }\n    const bytesMatch = type.match(Solidity.bytesRegex);\n    if (bytesMatch) {\n      const [_type, size] = bytesMatch;\n      if (Number.parseInt(size, 10) !== (value.length - 2) / 2) throw new BytesSizeMismatchError({\n        expectedSize: Number.parseInt(size, 10),\n        value: value\n      });\n      return Hex.padRight(value, isArray ? 32 : 0);\n    }\n    const arrayMatch = type.match(Solidity.arrayRegex);\n    if (arrayMatch && Array.isArray(value)) {\n      const [_type, childType] = arrayMatch;\n      const data = [];\n      for (let i = 0; i < value.length; i++) {\n        data.push(encode(childType, value[i], true));\n      }\n      if (data.length === 0) return '0x';\n      return Hex.concat(...data);\n    }\n    throw new InvalidTypeError(type);\n  }\n  encodePacked.encode = encode;\n})(encodePacked || (encodePacked = {}));\n/**\n * Formats {@link ox#AbiParameters.AbiParameters} into **Human Readable ABI Parameters**.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const formatted = AbiParameters.format([\n *   {\n *     name: 'spender',\n *     type: 'address',\n *   },\n *   {\n *     name: 'amount',\n *     type: 'uint256',\n *   },\n * ])\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param parameters - The ABI Parameters to format.\n * @returns The formatted ABI Parameters  .\n */\nexport function format(parameters) {\n  return abitype.formatAbiParameters(parameters);\n}\n/**\n * Parses arbitrary **JSON ABI Parameters** or **Human Readable ABI Parameters** into typed {@link ox#AbiParameters.AbiParameters}.\n *\n * @example\n * ### JSON Parameters\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from([\n *   {\n *     name: 'spender',\n *     type: 'address',\n *   },\n *   {\n *     name: 'amount',\n *     type: 'uint256',\n *   },\n * ])\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable Parameters\n *\n * Human Readable ABI Parameters can be parsed into a typed {@link ox#AbiParameters.AbiParameters}:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from('address spender, uint256 amount')\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from([\n *   'struct Foo { address spender; uint256 amount; }', // [!code hl]\n *   'Foo foo, address bar',\n * ])\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param parameters - The ABI Parameters to parse.\n * @returns The typed ABI Parameters.\n */\nexport function from(parameters) {\n  if (Array.isArray(parameters) && typeof parameters[0] === 'string') return abitype.parseAbiParameters(parameters);\n  if (typeof parameters === 'string') return abitype.parseAbiParameters(parameters);\n  return parameters;\n}\n/**\n * Throws when the data size is too small for the given parameters.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x010f')\n * //                                             ↑ ❌ 2 bytes\n * // @error: AbiParameters.DataSizeTooSmallError: Data size of 2 bytes is too small for given parameters.\n * // @error: Params: (uint256)\n * // @error: Data:   0x010f (2 bytes)\n * ```\n *\n * ### Solution\n *\n * Pass a valid data size.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x00000000000000000000000000000000000000000000000000000000000010f')\n * //                                             ↑ ✅ 32 bytes\n * ```\n */\nexport class DataSizeTooSmallError extends Errors.BaseError {\n  constructor(_ref) {\n    let {\n      data,\n      parameters,\n      size\n    } = _ref;\n    super(\"Data size of \".concat(size, \" bytes is too small for given parameters.\"), {\n      metaMessages: [\"Params: (\".concat(abitype.formatAbiParameters(parameters), \")\"), \"Data:   \".concat(data, \" (\").concat(size, \" bytes)\")]\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'AbiParameters.DataSizeTooSmallError'\n    });\n  }\n}\n/**\n * Throws when zero data is provided, but data is expected.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x')\n * //                                           ↑ ❌ zero data\n * // @error: AbiParameters.DataSizeTooSmallError: Data size of 2 bytes is too small for given parameters.\n * // @error: Params: (uint256)\n * // @error: Data:   0x010f (2 bytes)\n * ```\n *\n * ### Solution\n *\n * Pass valid data.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x00000000000000000000000000000000000000000000000000000000000010f')\n * //                                             ↑ ✅ 32 bytes\n * ```\n */\nexport class ZeroDataError extends Errors.BaseError {\n  constructor() {\n    super('Cannot decode zero data (\"0x\") with ABI parameters.');\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'AbiParameters.ZeroDataError'\n    });\n  }\n}\n/**\n * The length of the array value does not match the length specified in the corresponding ABI parameter.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from('uint256[3]'), [[69n, 420n]])\n * //                                               ↑ expected: 3  ↑ ❌ length: 2\n * // @error: AbiParameters.ArrayLengthMismatchError: ABI encoding array length mismatch\n * // @error: for type `uint256[3]`. Expected: `3`. Given: `2`.\n * ```\n *\n * ### Solution\n *\n * Pass an array of the correct length.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['uint256[3]']), [[69n, 420n, 69n]])\n * //                                                         ↑ ✅ length: 3\n * ```\n */\nexport class ArrayLengthMismatchError extends Errors.BaseError {\n  constructor(_ref2) {\n    let {\n      expectedLength,\n      givenLength,\n      type\n    } = _ref2;\n    super(\"Array length mismatch for type `\".concat(type, \"`. Expected: `\").concat(expectedLength, \"`. Given: `\").concat(givenLength, \"`.\"));\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'AbiParameters.ArrayLengthMismatchError'\n    });\n  }\n}\n/**\n * The size of the bytes value does not match the size specified in the corresponding ABI parameter.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from('bytes8'), [['0xdeadbeefdeadbeefdeadbeef']])\n * //                                            ↑ expected: 8 bytes  ↑ ❌ size: 12 bytes\n * // @error: BytesSizeMismatchError: Size of bytes \"0xdeadbeefdeadbeefdeadbeef\"\n * // @error: (bytes12) does not match expected size (bytes8).\n * ```\n *\n * ### Solution\n *\n * Pass a bytes value of the correct size.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['bytes8']), ['0xdeadbeefdeadbeef'])\n * //                                                       ↑ ✅ size: 8 bytes\n * ```\n */\nexport class BytesSizeMismatchError extends Errors.BaseError {\n  constructor(_ref3) {\n    let {\n      expectedSize,\n      value\n    } = _ref3;\n    super(\"Size of bytes \\\"\".concat(value, \"\\\" (bytes\").concat(Hex.size(value), \") does not match expected size (bytes\").concat(expectedSize, \").\"));\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'AbiParameters.BytesSizeMismatchError'\n    });\n  }\n}\n/**\n * The length of the values to encode does not match the length of the ABI parameters.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['string', 'uint256']), ['hello'])\n * // @error: LengthMismatchError: ABI encoding params/values length mismatch.\n * // @error: Expected length (params): 2\n * // @error: Given length (values): 1\n * ```\n *\n * ### Solution\n *\n * Pass the correct number of values to encode.\n *\n * ### Solution\n *\n * Pass a [valid ABI type](https://docs.soliditylang.org/en/develop/abi-spec.html#types).\n */\nexport class LengthMismatchError extends Errors.BaseError {\n  constructor(_ref4) {\n    let {\n      expectedLength,\n      givenLength\n    } = _ref4;\n    super(['ABI encoding parameters/values length mismatch.', \"Expected length (parameters): \".concat(expectedLength), \"Given length (values): \".concat(givenLength)].join('\\n'));\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'AbiParameters.LengthMismatchError'\n    });\n  }\n}\n/**\n * The value provided is not a valid array as specified in the corresponding ABI parameter.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['uint256[3]']), [69])\n * ```\n *\n * ### Solution\n *\n * Pass an array value.\n */\nexport class InvalidArrayError extends Errors.BaseError {\n  constructor(value) {\n    super(\"Value `\".concat(value, \"` is not a valid array.\"));\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'AbiParameters.InvalidArrayError'\n    });\n  }\n}\n/**\n * Throws when the ABI parameter type is invalid.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'lol' }], '0x00000000000000000000000000000000000000000000000000000000000010f')\n * //                             ↑ ❌ invalid type\n * // @error: AbiParameters.InvalidTypeError: Type `lol` is not a valid ABI Type.\n * ```\n */\nexport class InvalidTypeError extends Errors.BaseError {\n  constructor(type) {\n    super(\"Type `\".concat(type, \"` is not a valid ABI Type.\"));\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'AbiParameters.InvalidTypeError'\n    });\n  }\n}","map":{"version":3,"names":["abitype","Address","Bytes","Errors","Hex","internal","Cursor","Solidity","decode","parameters","data","options","arguments","length","undefined","as","checksumAddress","bytes","fromHex","cursor","create","size","ZeroDataError","DataSizeTooSmallError","fromBytes","consumed","values","i","_param$name","param","setPosition","consumed_","decodeParameter","staticPosition","push","name","encode","LengthMismatchError","expectedLength","givenLength","preparedParameters","prepareParameters","encodePacked","types","type","value","concat","isArray","address","assert","padLeft","toLowerCase","fromString","fromBoolean","intMatch","match","integerRegex","_type","baseType","bits","Number","parseInt","fromNumber","signed","bytesMatch","bytesRegex","BytesSizeMismatchError","expectedSize","padRight","arrayMatch","arrayRegex","Array","childType","InvalidTypeError","format","formatAbiParameters","from","parseAbiParameters","BaseError","constructor","_ref","metaMessages","Object","defineProperty","ArrayLengthMismatchError","_ref2","_ref3","_ref4","join","InvalidArrayError"],"sources":["/Users/mac/Desktop/topl1/frontend/node_modules/ox/core/AbiParameters.ts"],"sourcesContent":["import * as abitype from 'abitype'\nimport * as Address from './Address.js'\nimport * as Bytes from './Bytes.js'\nimport * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport * as internal from './internal/abiParameters.js'\nimport * as Cursor from './internal/cursor.js'\nimport * as Solidity from './Solidity.js'\n\n/** Root type for ABI parameters. */\nexport type AbiParameters = readonly abitype.AbiParameter[]\n\n/** A parameter on an {@link ox#AbiParameters.AbiParameters}. */\nexport type Parameter = abitype.AbiParameter\n\n/** A packed ABI type. */\nexport type PackedAbiType =\n  | abitype.SolidityAddress\n  | abitype.SolidityBool\n  | abitype.SolidityBytes\n  | abitype.SolidityInt\n  | abitype.SolidityString\n  | abitype.SolidityArrayWithoutTuple\n\n/**\n * Decodes ABI-encoded data into its respective primitive values based on ABI Parameters.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const data = AbiParameters.decode(\n *   AbiParameters.from(['string', 'uint', 'bool']),\n *   '0x000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000001a4000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000057761676d69000000000000000000000000000000000000000000000000000000',\n * )\n * // @log: ['wagmi', 420n, true]\n * ```\n *\n * @example\n * ### JSON Parameters\n *\n * You can pass **JSON ABI** Parameters:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const data = AbiParameters.decode(\n *   [\n *     { name: 'x', type: 'string' },\n *     { name: 'y', type: 'uint' },\n *     { name: 'z', type: 'bool' },\n *   ],\n *   '0x000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000001a4000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000057761676d69000000000000000000000000000000000000000000000000000000',\n * )\n * // @log: ['wagmi', 420n, true]\n * ```\n *\n * @param parameters - The set of ABI parameters to decode, in the shape of the `inputs` or `outputs` attribute of an ABI Item. These parameters must include valid [ABI types](https://docs.soliditylang.org/en/latest/types.html).\n * @param data - ABI encoded data.\n * @param options - Decoding options.\n * @returns Array of decoded values.\n */\nexport function decode<\n  const parameters extends AbiParameters,\n  as extends 'Object' | 'Array' = 'Array',\n>(\n  parameters: parameters,\n  data: Bytes.Bytes | Hex.Hex,\n  options?: decode.Options<as>,\n): decode.ReturnType<parameters, as>\n\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function decode(\n  parameters: AbiParameters,\n  data: Bytes.Bytes | Hex.Hex,\n  options: {\n    as?: 'Array' | 'Object' | undefined\n    checksumAddress?: boolean | undefined\n  } = {},\n): readonly unknown[] | Record<string, unknown> {\n  const { as = 'Array', checksumAddress = false } = options\n\n  const bytes = typeof data === 'string' ? Bytes.fromHex(data) : data\n  const cursor = Cursor.create(bytes)\n\n  if (Bytes.size(bytes) === 0 && parameters.length > 0)\n    throw new ZeroDataError()\n  if (Bytes.size(bytes) && Bytes.size(bytes) < 32)\n    throw new DataSizeTooSmallError({\n      data: typeof data === 'string' ? data : Hex.fromBytes(data),\n      parameters: parameters as readonly Parameter[],\n      size: Bytes.size(bytes),\n    })\n\n  let consumed = 0\n  const values: any = as === 'Array' ? [] : {}\n  for (let i = 0; i < parameters.length; ++i) {\n    const param = parameters[i] as Parameter\n    cursor.setPosition(consumed)\n    const [data, consumed_] = internal.decodeParameter(cursor, param, {\n      checksumAddress,\n      staticPosition: 0,\n    })\n    consumed += consumed_\n    if (as === 'Array') values.push(data)\n    else values[param.name ?? i] = data\n  }\n  return values\n}\n\nexport declare namespace decode {\n  type Options<as extends 'Object' | 'Array'> = {\n    /**\n     * Whether the decoded values should be returned as an `Object` or `Array`.\n     *\n     * @default \"Array\"\n     */\n    as?: as | 'Object' | 'Array' | undefined\n    /**\n     * Whether decoded addresses should be checksummed.\n     *\n     * @default false\n     */\n    checksumAddress?: boolean | undefined\n  }\n\n  type ReturnType<\n    parameters extends AbiParameters = AbiParameters,\n    as extends 'Object' | 'Array' = 'Array',\n  > = parameters extends readonly []\n    ? as extends 'Object'\n      ? {}\n      : []\n    : as extends 'Object'\n      ? internal.ToObject<parameters>\n      : internal.ToPrimitiveTypes<parameters>\n\n  type ErrorType =\n    | Bytes.fromHex.ErrorType\n    | internal.decodeParameter.ErrorType\n    | ZeroDataError\n    | DataSizeTooSmallError\n    | Errors.GlobalErrorType\n}\n\n/**\n * Encodes primitive values into ABI encoded data as per the [Application Binary Interface (ABI) Specification](https://docs.soliditylang.org/en/latest/abi-spec).\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const data = AbiParameters.encode(\n *   AbiParameters.from(['string', 'uint', 'bool']),\n *   ['wagmi', 420n, true],\n * )\n * ```\n *\n * @example\n * ### JSON Parameters\n *\n * Specify **JSON ABI** Parameters as schema:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const data = AbiParameters.encode(\n *   [\n *     { type: 'string', name: 'name' },\n *     { type: 'uint', name: 'age' },\n *     { type: 'bool', name: 'isOwner' },\n *   ],\n *   ['wagmi', 420n, true],\n * )\n * ```\n *\n * @param parameters - The set of ABI parameters to encode, in the shape of the `inputs` or `outputs` attribute of an ABI Item. These parameters must include valid [ABI types](https://docs.soliditylang.org/en/latest/types.html).\n * @param values - The set of primitive values that correspond to the ABI types defined in `parameters`.\n * @returns ABI encoded data.\n */\nexport function encode<\n  const parameters extends AbiParameters | readonly unknown[],\n>(\n  parameters: parameters,\n  values: parameters extends AbiParameters\n    ? internal.ToPrimitiveTypes<parameters>\n    : never,\n  options?: encode.Options,\n): Hex.Hex {\n  const { checksumAddress = false } = options ?? {}\n\n  if (parameters.length !== values.length)\n    throw new LengthMismatchError({\n      expectedLength: parameters.length as number,\n      givenLength: values.length as any,\n    })\n  // Prepare the parameters to determine dynamic types to encode.\n  const preparedParameters = internal.prepareParameters({\n    checksumAddress,\n    parameters: parameters as readonly Parameter[],\n    values: values as any,\n  })\n  const data = internal.encode(preparedParameters)\n  if (data.length === 0) return '0x'\n  return data\n}\n\nexport declare namespace encode {\n  type ErrorType =\n    | LengthMismatchError\n    | internal.encode.ErrorType\n    | internal.prepareParameters.ErrorType\n    | Errors.GlobalErrorType\n\n  type Options = {\n    /**\n     * Whether addresses should be checked against their checksum.\n     *\n     * @default false\n     */\n    checksumAddress?: boolean | undefined\n  }\n}\n\n/**\n * Encodes an array of primitive values to a [packed ABI encoding](https://docs.soliditylang.org/en/latest/abi-spec.html#non-standard-packed-mode).\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const encoded = AbiParameters.encodePacked(\n *   ['address', 'string'],\n *   ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 'hello world'],\n * )\n * // @log: '0xd8da6bf26964af9d7eed9e03e53415d37aa9604568656c6c6f20776f726c64'\n * ```\n *\n * @param types - Set of ABI types to pack encode.\n * @param values - The set of primitive values that correspond to the ABI types defined in `types`.\n * @returns The encoded packed data.\n */\nexport function encodePacked<\n  const packedAbiTypes extends readonly PackedAbiType[] | readonly unknown[],\n>(types: packedAbiTypes, values: encodePacked.Values<packedAbiTypes>): Hex.Hex {\n  if (types.length !== values.length)\n    throw new LengthMismatchError({\n      expectedLength: types.length as number,\n      givenLength: values.length as number,\n    })\n\n  const data: Hex.Hex[] = []\n  for (let i = 0; i < (types as unknown[]).length; i++) {\n    const type = types[i]\n    const value = values[i]\n    data.push(encodePacked.encode(type, value))\n  }\n  return Hex.concat(...data)\n}\n\nexport namespace encodePacked {\n  export type ErrorType =\n    | Hex.concat.ErrorType\n    | LengthMismatchError\n    | Errors.GlobalErrorType\n\n  export type Values<\n    packedAbiTypes extends readonly PackedAbiType[] | readonly unknown[],\n  > = {\n    [key in keyof packedAbiTypes]: packedAbiTypes[key] extends abitype.AbiType\n      ? abitype.AbiParameterToPrimitiveType<{ type: packedAbiTypes[key] }>\n      : unknown\n  }\n\n  // eslint-disable-next-line jsdoc/require-jsdoc\n  export function encode<const packedAbiType extends PackedAbiType | unknown>(\n    type: packedAbiType,\n    value: Values<[packedAbiType]>[0],\n    isArray = false,\n  ): Hex.Hex {\n    if (type === 'address') {\n      const address = value as Address.Address\n      Address.assert(address)\n      return Hex.padLeft(\n        address.toLowerCase() as Hex.Hex,\n        isArray ? 32 : 0,\n      ) as Address.Address\n    }\n    if (type === 'string') return Hex.fromString(value as string)\n    if (type === 'bytes') return value as Hex.Hex\n    if (type === 'bool')\n      return Hex.padLeft(Hex.fromBoolean(value as boolean), isArray ? 32 : 1)\n\n    const intMatch = (type as string).match(Solidity.integerRegex)\n    if (intMatch) {\n      const [_type, baseType, bits = '256'] = intMatch\n      const size = Number.parseInt(bits, 10) / 8\n      return Hex.fromNumber(value as number, {\n        size: isArray ? 32 : size,\n        signed: baseType === 'int',\n      })\n    }\n\n    const bytesMatch = (type as string).match(Solidity.bytesRegex)\n    if (bytesMatch) {\n      const [_type, size] = bytesMatch\n      if (Number.parseInt(size!, 10) !== ((value as Hex.Hex).length - 2) / 2)\n        throw new BytesSizeMismatchError({\n          expectedSize: Number.parseInt(size!, 10),\n          value: value as Hex.Hex,\n        })\n      return Hex.padRight(value as Hex.Hex, isArray ? 32 : 0) as Hex.Hex\n    }\n\n    const arrayMatch = (type as string).match(Solidity.arrayRegex)\n    if (arrayMatch && Array.isArray(value)) {\n      const [_type, childType] = arrayMatch\n      const data: Hex.Hex[] = []\n      for (let i = 0; i < value.length; i++) {\n        data.push(encode(childType, value[i], true))\n      }\n      if (data.length === 0) return '0x'\n      return Hex.concat(...data)\n    }\n\n    throw new InvalidTypeError(type as string)\n  }\n}\n\n/**\n * Formats {@link ox#AbiParameters.AbiParameters} into **Human Readable ABI Parameters**.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const formatted = AbiParameters.format([\n *   {\n *     name: 'spender',\n *     type: 'address',\n *   },\n *   {\n *     name: 'amount',\n *     type: 'uint256',\n *   },\n * ])\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param parameters - The ABI Parameters to format.\n * @returns The formatted ABI Parameters  .\n */\nexport function format<\n  const parameters extends readonly [\n    Parameter | abitype.AbiEventParameter,\n    ...(readonly (Parameter | abitype.AbiEventParameter)[]),\n  ],\n>(\n  parameters:\n    | parameters\n    | readonly [\n        Parameter | abitype.AbiEventParameter,\n        ...(readonly (Parameter | abitype.AbiEventParameter)[]),\n      ],\n): abitype.FormatAbiParameters<parameters> {\n  return abitype.formatAbiParameters(parameters)\n}\n\nexport declare namespace format {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Parses arbitrary **JSON ABI Parameters** or **Human Readable ABI Parameters** into typed {@link ox#AbiParameters.AbiParameters}.\n *\n * @example\n * ### JSON Parameters\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from([\n *   {\n *     name: 'spender',\n *     type: 'address',\n *   },\n *   {\n *     name: 'amount',\n *     type: 'uint256',\n *   },\n * ])\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable Parameters\n *\n * Human Readable ABI Parameters can be parsed into a typed {@link ox#AbiParameters.AbiParameters}:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from('address spender, uint256 amount')\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from([\n *   'struct Foo { address spender; uint256 amount; }', // [!code hl]\n *   'Foo foo, address bar',\n * ])\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param parameters - The ABI Parameters to parse.\n * @returns The typed ABI Parameters.\n */\nexport function from<\n  const parameters extends AbiParameters | string | readonly string[],\n>(\n  parameters: parameters | AbiParameters | string | readonly string[],\n): from.ReturnType<parameters> {\n  if (Array.isArray(parameters) && typeof parameters[0] === 'string')\n    return abitype.parseAbiParameters(parameters) as never\n  if (typeof parameters === 'string')\n    return abitype.parseAbiParameters(parameters) as never\n  return parameters as never\n}\n\nexport declare namespace from {\n  type ReturnType<\n    parameters extends AbiParameters | string | readonly string[],\n  > = parameters extends string\n    ? abitype.ParseAbiParameters<parameters>\n    : parameters extends readonly string[]\n      ? abitype.ParseAbiParameters<parameters>\n      : parameters\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Throws when the data size is too small for the given parameters.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x010f')\n * //                                             ↑ ❌ 2 bytes\n * // @error: AbiParameters.DataSizeTooSmallError: Data size of 2 bytes is too small for given parameters.\n * // @error: Params: (uint256)\n * // @error: Data:   0x010f (2 bytes)\n * ```\n *\n * ### Solution\n *\n * Pass a valid data size.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x00000000000000000000000000000000000000000000000000000000000010f')\n * //                                             ↑ ✅ 32 bytes\n * ```\n */\nexport class DataSizeTooSmallError extends Errors.BaseError {\n  override readonly name = 'AbiParameters.DataSizeTooSmallError'\n  constructor({\n    data,\n    parameters,\n    size,\n  }: { data: Hex.Hex; parameters: readonly Parameter[]; size: number }) {\n    super(`Data size of ${size} bytes is too small for given parameters.`, {\n      metaMessages: [\n        `Params: (${abitype.formatAbiParameters(parameters as readonly [Parameter])})`,\n        `Data:   ${data} (${size} bytes)`,\n      ],\n    })\n  }\n}\n\n/**\n * Throws when zero data is provided, but data is expected.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x')\n * //                                           ↑ ❌ zero data\n * // @error: AbiParameters.DataSizeTooSmallError: Data size of 2 bytes is too small for given parameters.\n * // @error: Params: (uint256)\n * // @error: Data:   0x010f (2 bytes)\n * ```\n *\n * ### Solution\n *\n * Pass valid data.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x00000000000000000000000000000000000000000000000000000000000010f')\n * //                                             ↑ ✅ 32 bytes\n * ```\n */\nexport class ZeroDataError extends Errors.BaseError {\n  override readonly name = 'AbiParameters.ZeroDataError'\n  constructor() {\n    super('Cannot decode zero data (\"0x\") with ABI parameters.')\n  }\n}\n\n/**\n * The length of the array value does not match the length specified in the corresponding ABI parameter.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from('uint256[3]'), [[69n, 420n]])\n * //                                               ↑ expected: 3  ↑ ❌ length: 2\n * // @error: AbiParameters.ArrayLengthMismatchError: ABI encoding array length mismatch\n * // @error: for type `uint256[3]`. Expected: `3`. Given: `2`.\n * ```\n *\n * ### Solution\n *\n * Pass an array of the correct length.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['uint256[3]']), [[69n, 420n, 69n]])\n * //                                                         ↑ ✅ length: 3\n * ```\n */\nexport class ArrayLengthMismatchError extends Errors.BaseError {\n  override readonly name = 'AbiParameters.ArrayLengthMismatchError'\n  constructor({\n    expectedLength,\n    givenLength,\n    type,\n  }: { expectedLength: number; givenLength: number; type: string }) {\n    super(\n      `Array length mismatch for type \\`${type}\\`. Expected: \\`${expectedLength}\\`. Given: \\`${givenLength}\\`.`,\n    )\n  }\n}\n\n/**\n * The size of the bytes value does not match the size specified in the corresponding ABI parameter.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from('bytes8'), [['0xdeadbeefdeadbeefdeadbeef']])\n * //                                            ↑ expected: 8 bytes  ↑ ❌ size: 12 bytes\n * // @error: BytesSizeMismatchError: Size of bytes \"0xdeadbeefdeadbeefdeadbeef\"\n * // @error: (bytes12) does not match expected size (bytes8).\n * ```\n *\n * ### Solution\n *\n * Pass a bytes value of the correct size.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['bytes8']), ['0xdeadbeefdeadbeef'])\n * //                                                       ↑ ✅ size: 8 bytes\n * ```\n */\nexport class BytesSizeMismatchError extends Errors.BaseError {\n  override readonly name = 'AbiParameters.BytesSizeMismatchError'\n  constructor({\n    expectedSize,\n    value,\n  }: { expectedSize: number; value: Hex.Hex }) {\n    super(\n      `Size of bytes \"${value}\" (bytes${Hex.size(\n        value,\n      )}) does not match expected size (bytes${expectedSize}).`,\n    )\n  }\n}\n\n/**\n * The length of the values to encode does not match the length of the ABI parameters.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['string', 'uint256']), ['hello'])\n * // @error: LengthMismatchError: ABI encoding params/values length mismatch.\n * // @error: Expected length (params): 2\n * // @error: Given length (values): 1\n * ```\n *\n * ### Solution\n *\n * Pass the correct number of values to encode.\n *\n * ### Solution\n *\n * Pass a [valid ABI type](https://docs.soliditylang.org/en/develop/abi-spec.html#types).\n */\nexport class LengthMismatchError extends Errors.BaseError {\n  override readonly name = 'AbiParameters.LengthMismatchError'\n  constructor({\n    expectedLength,\n    givenLength,\n  }: { expectedLength: number; givenLength: number }) {\n    super(\n      [\n        'ABI encoding parameters/values length mismatch.',\n        `Expected length (parameters): ${expectedLength}`,\n        `Given length (values): ${givenLength}`,\n      ].join('\\n'),\n    )\n  }\n}\n\n/**\n * The value provided is not a valid array as specified in the corresponding ABI parameter.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['uint256[3]']), [69])\n * ```\n *\n * ### Solution\n *\n * Pass an array value.\n */\nexport class InvalidArrayError extends Errors.BaseError {\n  override readonly name = 'AbiParameters.InvalidArrayError'\n  constructor(value: unknown) {\n    super(`Value \\`${value}\\` is not a valid array.`)\n  }\n}\n\n/**\n * Throws when the ABI parameter type is invalid.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'lol' }], '0x00000000000000000000000000000000000000000000000000000000000010f')\n * //                             ↑ ❌ invalid type\n * // @error: AbiParameters.InvalidTypeError: Type `lol` is not a valid ABI Type.\n * ```\n */\nexport class InvalidTypeError extends Errors.BaseError {\n  override readonly name = 'AbiParameters.InvalidTypeError'\n  constructor(type: string) {\n    super(`Type \\`${type}\\` is not a valid ABI Type.`)\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}