{"ast":null,"code":"import * as Errors from '../Errors.js';\nconst staticCursor = {\n  bytes: new Uint8Array(),\n  dataView: new DataView(new ArrayBuffer(0)),\n  position: 0,\n  positionReadCount: new Map(),\n  recursiveReadCount: 0,\n  recursiveReadLimit: Number.POSITIVE_INFINITY,\n  assertReadLimit() {\n    if (this.recursiveReadCount >= this.recursiveReadLimit) throw new RecursiveReadLimitExceededError({\n      count: this.recursiveReadCount + 1,\n      limit: this.recursiveReadLimit\n    });\n  },\n  assertPosition(position) {\n    if (position < 0 || position > this.bytes.length - 1) throw new PositionOutOfBoundsError({\n      length: this.bytes.length,\n      position\n    });\n  },\n  decrementPosition(offset) {\n    if (offset < 0) throw new NegativeOffsetError({\n      offset\n    });\n    const position = this.position - offset;\n    this.assertPosition(position);\n    this.position = position;\n  },\n  getReadCount(position) {\n    return this.positionReadCount.get(position || this.position) || 0;\n  },\n  incrementPosition(offset) {\n    if (offset < 0) throw new NegativeOffsetError({\n      offset\n    });\n    const position = this.position + offset;\n    this.assertPosition(position);\n    this.position = position;\n  },\n  inspectByte(position_) {\n    const position = position_ !== null && position_ !== void 0 ? position_ : this.position;\n    this.assertPosition(position);\n    return this.bytes[position];\n  },\n  inspectBytes(length, position_) {\n    const position = position_ !== null && position_ !== void 0 ? position_ : this.position;\n    this.assertPosition(position + length - 1);\n    return this.bytes.subarray(position, position + length);\n  },\n  inspectUint8(position_) {\n    const position = position_ !== null && position_ !== void 0 ? position_ : this.position;\n    this.assertPosition(position);\n    return this.bytes[position];\n  },\n  inspectUint16(position_) {\n    const position = position_ !== null && position_ !== void 0 ? position_ : this.position;\n    this.assertPosition(position + 1);\n    return this.dataView.getUint16(position);\n  },\n  inspectUint24(position_) {\n    const position = position_ !== null && position_ !== void 0 ? position_ : this.position;\n    this.assertPosition(position + 2);\n    return (this.dataView.getUint16(position) << 8) + this.dataView.getUint8(position + 2);\n  },\n  inspectUint32(position_) {\n    const position = position_ !== null && position_ !== void 0 ? position_ : this.position;\n    this.assertPosition(position + 3);\n    return this.dataView.getUint32(position);\n  },\n  pushByte(byte) {\n    this.assertPosition(this.position);\n    this.bytes[this.position] = byte;\n    this.position++;\n  },\n  pushBytes(bytes) {\n    this.assertPosition(this.position + bytes.length - 1);\n    this.bytes.set(bytes, this.position);\n    this.position += bytes.length;\n  },\n  pushUint8(value) {\n    this.assertPosition(this.position);\n    this.bytes[this.position] = value;\n    this.position++;\n  },\n  pushUint16(value) {\n    this.assertPosition(this.position + 1);\n    this.dataView.setUint16(this.position, value);\n    this.position += 2;\n  },\n  pushUint24(value) {\n    this.assertPosition(this.position + 2);\n    this.dataView.setUint16(this.position, value >> 8);\n    this.dataView.setUint8(this.position + 2, value & ~4294967040);\n    this.position += 3;\n  },\n  pushUint32(value) {\n    this.assertPosition(this.position + 3);\n    this.dataView.setUint32(this.position, value);\n    this.position += 4;\n  },\n  readByte() {\n    this.assertReadLimit();\n    this._touch();\n    const value = this.inspectByte();\n    this.position++;\n    return value;\n  },\n  readBytes(length, size) {\n    this.assertReadLimit();\n    this._touch();\n    const value = this.inspectBytes(length);\n    this.position += size !== null && size !== void 0 ? size : length;\n    return value;\n  },\n  readUint8() {\n    this.assertReadLimit();\n    this._touch();\n    const value = this.inspectUint8();\n    this.position += 1;\n    return value;\n  },\n  readUint16() {\n    this.assertReadLimit();\n    this._touch();\n    const value = this.inspectUint16();\n    this.position += 2;\n    return value;\n  },\n  readUint24() {\n    this.assertReadLimit();\n    this._touch();\n    const value = this.inspectUint24();\n    this.position += 3;\n    return value;\n  },\n  readUint32() {\n    this.assertReadLimit();\n    this._touch();\n    const value = this.inspectUint32();\n    this.position += 4;\n    return value;\n  },\n  get remaining() {\n    return this.bytes.length - this.position;\n  },\n  setPosition(position) {\n    const oldPosition = this.position;\n    this.assertPosition(position);\n    this.position = position;\n    return () => this.position = oldPosition;\n  },\n  _touch() {\n    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY) return;\n    const count = this.getReadCount();\n    this.positionReadCount.set(this.position, count + 1);\n    if (count > 0) this.recursiveReadCount++;\n  }\n};\n/** @internal */\nexport function create(bytes) {\n  let {\n    recursiveReadLimit = 8192\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const cursor = Object.create(staticCursor);\n  cursor.bytes = bytes;\n  cursor.dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n  cursor.positionReadCount = new Map();\n  cursor.recursiveReadLimit = recursiveReadLimit;\n  return cursor;\n}\n/** @internal */\nexport class NegativeOffsetError extends Errors.BaseError {\n  constructor(_ref) {\n    let {\n      offset\n    } = _ref;\n    super(\"Offset `\".concat(offset, \"` cannot be negative.\"));\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Cursor.NegativeOffsetError'\n    });\n  }\n}\n/** @internal */\nexport class PositionOutOfBoundsError extends Errors.BaseError {\n  constructor(_ref2) {\n    let {\n      length,\n      position\n    } = _ref2;\n    super(\"Position `\".concat(position, \"` is out of bounds (`0 < position < \").concat(length, \"`).\"));\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Cursor.PositionOutOfBoundsError'\n    });\n  }\n}\n/** @internal */\nexport class RecursiveReadLimitExceededError extends Errors.BaseError {\n  constructor(_ref3) {\n    let {\n      count,\n      limit\n    } = _ref3;\n    super(\"Recursive read limit of `\".concat(limit, \"` exceeded (recursive read count: `\").concat(count, \"`).\"));\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Cursor.RecursiveReadLimitExceededError'\n    });\n  }\n}","map":{"version":3,"names":["Errors","staticCursor","bytes","Uint8Array","dataView","DataView","ArrayBuffer","position","positionReadCount","Map","recursiveReadCount","recursiveReadLimit","Number","POSITIVE_INFINITY","assertReadLimit","RecursiveReadLimitExceededError","count","limit","assertPosition","length","PositionOutOfBoundsError","decrementPosition","offset","NegativeOffsetError","getReadCount","get","incrementPosition","inspectByte","position_","inspectBytes","subarray","inspectUint8","inspectUint16","getUint16","inspectUint24","getUint8","inspectUint32","getUint32","pushByte","byte","pushBytes","set","pushUint8","value","pushUint16","setUint16","pushUint24","setUint8","pushUint32","setUint32","readByte","_touch","readBytes","size","readUint8","readUint16","readUint24","readUint32","remaining","setPosition","oldPosition","create","arguments","undefined","cursor","Object","buffer","byteOffset","byteLength","BaseError","constructor","_ref","concat","defineProperty","_ref2","_ref3"],"sources":["/Users/mac/Desktop/topl1/frontend/node_modules/ox/core/internal/cursor.ts"],"sourcesContent":["import type { Bytes } from '../Bytes.js'\nimport * as Errors from '../Errors.js'\n\n/** @internal */\nexport type Cursor = {\n  bytes: Bytes\n  dataView: DataView\n  position: number\n  positionReadCount: Map<number, number>\n  recursiveReadCount: number\n  recursiveReadLimit: number\n  remaining: number\n  assertReadLimit(position?: number): void\n  assertPosition(position: number): void\n  decrementPosition(offset: number): void\n  getReadCount(position?: number): number\n  incrementPosition(offset: number): void\n  inspectByte(position?: number): Bytes[number]\n  inspectBytes(length: number, position?: number): Bytes\n  inspectUint8(position?: number): number\n  inspectUint16(position?: number): number\n  inspectUint24(position?: number): number\n  inspectUint32(position?: number): number\n  pushByte(byte: Bytes[number]): void\n  pushBytes(bytes: Bytes): void\n  pushUint8(value: number): void\n  pushUint16(value: number): void\n  pushUint24(value: number): void\n  pushUint32(value: number): void\n  readByte(): Bytes[number]\n  readBytes(length: number, size?: number): Bytes\n  readUint8(): number\n  readUint16(): number\n  readUint24(): number\n  readUint32(): number\n  setPosition(position: number): () => void\n  _touch(): void\n}\n\nconst staticCursor: Cursor = {\n  bytes: new Uint8Array(),\n  dataView: new DataView(new ArrayBuffer(0)),\n  position: 0,\n  positionReadCount: new Map(),\n  recursiveReadCount: 0,\n  recursiveReadLimit: Number.POSITIVE_INFINITY,\n  assertReadLimit() {\n    if (this.recursiveReadCount >= this.recursiveReadLimit)\n      throw new RecursiveReadLimitExceededError({\n        count: this.recursiveReadCount + 1,\n        limit: this.recursiveReadLimit,\n      })\n  },\n  assertPosition(position) {\n    if (position < 0 || position > this.bytes.length - 1)\n      throw new PositionOutOfBoundsError({\n        length: this.bytes.length,\n        position,\n      })\n  },\n  decrementPosition(offset) {\n    if (offset < 0) throw new NegativeOffsetError({ offset })\n    const position = this.position - offset\n    this.assertPosition(position)\n    this.position = position\n  },\n  getReadCount(position) {\n    return this.positionReadCount.get(position || this.position) || 0\n  },\n  incrementPosition(offset) {\n    if (offset < 0) throw new NegativeOffsetError({ offset })\n    const position = this.position + offset\n    this.assertPosition(position)\n    this.position = position\n  },\n  inspectByte(position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position)\n    return this.bytes[position]!\n  },\n  inspectBytes(length, position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position + length - 1)\n    return this.bytes.subarray(position, position + length)\n  },\n  inspectUint8(position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position)\n    return this.bytes[position]!\n  },\n  inspectUint16(position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position + 1)\n    return this.dataView.getUint16(position)\n  },\n  inspectUint24(position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position + 2)\n    return (\n      (this.dataView.getUint16(position) << 8) +\n      this.dataView.getUint8(position + 2)\n    )\n  },\n  inspectUint32(position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position + 3)\n    return this.dataView.getUint32(position)\n  },\n  pushByte(byte: Bytes[number]) {\n    this.assertPosition(this.position)\n    this.bytes[this.position] = byte\n    this.position++\n  },\n  pushBytes(bytes: Bytes) {\n    this.assertPosition(this.position + bytes.length - 1)\n    this.bytes.set(bytes, this.position)\n    this.position += bytes.length\n  },\n  pushUint8(value: number) {\n    this.assertPosition(this.position)\n    this.bytes[this.position] = value\n    this.position++\n  },\n  pushUint16(value: number) {\n    this.assertPosition(this.position + 1)\n    this.dataView.setUint16(this.position, value)\n    this.position += 2\n  },\n  pushUint24(value: number) {\n    this.assertPosition(this.position + 2)\n    this.dataView.setUint16(this.position, value >> 8)\n    this.dataView.setUint8(this.position + 2, value & ~4294967040)\n    this.position += 3\n  },\n  pushUint32(value: number) {\n    this.assertPosition(this.position + 3)\n    this.dataView.setUint32(this.position, value)\n    this.position += 4\n  },\n  readByte() {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectByte()\n    this.position++\n    return value\n  },\n  readBytes(length, size) {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectBytes(length)\n    this.position += size ?? length\n    return value\n  },\n  readUint8() {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectUint8()\n    this.position += 1\n    return value\n  },\n  readUint16() {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectUint16()\n    this.position += 2\n    return value\n  },\n  readUint24() {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectUint24()\n    this.position += 3\n    return value\n  },\n  readUint32() {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectUint32()\n    this.position += 4\n    return value\n  },\n  get remaining() {\n    return this.bytes.length - this.position\n  },\n  setPosition(position) {\n    const oldPosition = this.position\n    this.assertPosition(position)\n    this.position = position\n    return () => (this.position = oldPosition)\n  },\n  _touch() {\n    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY) return\n    const count = this.getReadCount()\n    this.positionReadCount.set(this.position, count + 1)\n    if (count > 0) this.recursiveReadCount++\n  },\n}\n\n/** @internal */\nexport function create(\n  bytes: Bytes,\n  { recursiveReadLimit = 8_192 }: create.Config = {},\n): Cursor {\n  const cursor: Cursor = Object.create(staticCursor)\n  cursor.bytes = bytes\n  cursor.dataView = new DataView(\n    bytes.buffer,\n    bytes.byteOffset,\n    bytes.byteLength,\n  )\n  cursor.positionReadCount = new Map()\n  cursor.recursiveReadLimit = recursiveReadLimit\n  return cursor\n}\n\n/** @internal */\nexport declare namespace create {\n  type Config = { recursiveReadLimit?: number | undefined }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/** @internal */\nexport class NegativeOffsetError extends Errors.BaseError {\n  override readonly name = 'Cursor.NegativeOffsetError'\n\n  constructor({ offset }: { offset: number }) {\n    super(`Offset \\`${offset}\\` cannot be negative.`)\n  }\n}\n\n/** @internal */\nexport class PositionOutOfBoundsError extends Errors.BaseError {\n  override readonly name = 'Cursor.PositionOutOfBoundsError'\n\n  constructor({ length, position }: { length: number; position: number }) {\n    super(\n      `Position \\`${position}\\` is out of bounds (\\`0 < position < ${length}\\`).`,\n    )\n  }\n}\n\n/** @internal */\nexport class RecursiveReadLimitExceededError extends Errors.BaseError {\n  override readonly name = 'Cursor.RecursiveReadLimitExceededError'\n\n  constructor({ count, limit }: { count: number; limit: number }) {\n    super(\n      `Recursive read limit of \\`${limit}\\` exceeded (recursive read count: \\`${count}\\`).`,\n    )\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}