{"ast":null,"code":"import { stringify } from '../utils/stringify.js';\nimport { BaseError } from './base.js';\nimport { getUrl } from './utils.js';\nexport class OffchainLookupError extends BaseError {\n  constructor(_ref) {\n    var _cause$metaMessages;\n    let {\n      callbackSelector,\n      cause,\n      data,\n      extraData,\n      sender,\n      urls\n    } = _ref;\n    super(cause.shortMessage || 'An error occurred while fetching for an offchain result.', {\n      cause,\n      metaMessages: [...(cause.metaMessages || []), (_cause$metaMessages = cause.metaMessages) !== null && _cause$metaMessages !== void 0 && _cause$metaMessages.length ? '' : [], 'Offchain Gateway Call:', urls && ['  Gateway URL(s):', ...urls.map(url => \"    \".concat(getUrl(url)))], \"  Sender: \".concat(sender), \"  Data: \".concat(data), \"  Callback selector: \".concat(callbackSelector), \"  Extra data: \".concat(extraData)].flat(),\n      name: 'OffchainLookupError'\n    });\n  }\n}\nexport class OffchainLookupResponseMalformedError extends BaseError {\n  constructor(_ref2) {\n    let {\n      result,\n      url\n    } = _ref2;\n    super('Offchain gateway response is malformed. Response data must be a hex value.', {\n      metaMessages: [\"Gateway URL: \".concat(getUrl(url)), \"Response: \".concat(stringify(result))],\n      name: 'OffchainLookupResponseMalformedError'\n    });\n  }\n}\nexport class OffchainLookupSenderMismatchError extends BaseError {\n  constructor(_ref3) {\n    let {\n      sender,\n      to\n    } = _ref3;\n    super('Reverted sender address does not match target contract address (`to`).', {\n      metaMessages: [\"Contract address: \".concat(to), \"OffchainLookup sender address: \".concat(sender)],\n      name: 'OffchainLookupSenderMismatchError'\n    });\n  }\n}","map":{"version":3,"names":["stringify","BaseError","getUrl","OffchainLookupError","constructor","_ref","_cause$metaMessages","callbackSelector","cause","data","extraData","sender","urls","shortMessage","metaMessages","length","map","url","concat","flat","name","OffchainLookupResponseMalformedError","_ref2","result","OffchainLookupSenderMismatchError","_ref3","to"],"sources":["/Users/mac/Desktop/topl1/frontend/node_modules/viem/errors/ccip.ts"],"sourcesContent":["import type { Address } from 'abitype'\n\nimport type { Hex } from '../types/misc.js'\nimport { stringify } from '../utils/stringify.js'\n\nimport { BaseError } from './base.js'\nimport { getUrl } from './utils.js'\n\nexport type OffchainLookupErrorType = OffchainLookupError & {\n  name: 'OffchainLookupError'\n}\nexport class OffchainLookupError extends BaseError {\n  constructor({\n    callbackSelector,\n    cause,\n    data,\n    extraData,\n    sender,\n    urls,\n  }: {\n    callbackSelector: Hex\n    cause: BaseError\n    data: Hex\n    extraData: Hex\n    sender: Address\n    urls: readonly string[]\n  }) {\n    super(\n      cause.shortMessage ||\n        'An error occurred while fetching for an offchain result.',\n      {\n        cause,\n        metaMessages: [\n          ...(cause.metaMessages || []),\n          cause.metaMessages?.length ? '' : [],\n          'Offchain Gateway Call:',\n          urls && [\n            '  Gateway URL(s):',\n            ...urls.map((url) => `    ${getUrl(url)}`),\n          ],\n          `  Sender: ${sender}`,\n          `  Data: ${data}`,\n          `  Callback selector: ${callbackSelector}`,\n          `  Extra data: ${extraData}`,\n        ].flat(),\n        name: 'OffchainLookupError',\n      },\n    )\n  }\n}\n\nexport type OffchainLookupResponseMalformedErrorType =\n  OffchainLookupResponseMalformedError & {\n    name: 'OffchainLookupResponseMalformedError'\n  }\nexport class OffchainLookupResponseMalformedError extends BaseError {\n  constructor({ result, url }: { result: any; url: string }) {\n    super(\n      'Offchain gateway response is malformed. Response data must be a hex value.',\n      {\n        metaMessages: [\n          `Gateway URL: ${getUrl(url)}`,\n          `Response: ${stringify(result)}`,\n        ],\n        name: 'OffchainLookupResponseMalformedError',\n      },\n    )\n  }\n}\n\n/** @internal */\nexport type OffchainLookupSenderMismatchErrorType =\n  OffchainLookupSenderMismatchError & {\n    name: 'OffchainLookupSenderMismatchError'\n  }\nexport class OffchainLookupSenderMismatchError extends BaseError {\n  constructor({ sender, to }: { sender: Address; to: Address }) {\n    super(\n      'Reverted sender address does not match target contract address (`to`).',\n      {\n        metaMessages: [\n          `Contract address: ${to}`,\n          `OffchainLookup sender address: ${sender}`,\n        ],\n        name: 'OffchainLookupSenderMismatchError',\n      },\n    )\n  }\n}\n"],"mappings":"AAGA,SAASA,SAAS,QAAQ,uBAAuB;AAEjD,SAASC,SAAS,QAAQ,WAAW;AACrC,SAASC,MAAM,QAAQ,YAAY;AAKnC,OAAM,MAAOC,mBAAoB,SAAQF,SAAS;EAChDG,YAAAC,IAAA,EAcC;IAAA,IAAAC,mBAAA;IAAA,IAdW;MACVC,gBAAgB;MAChBC,KAAK;MACLC,IAAI;MACJC,SAAS;MACTC,MAAM;MACNC;IAAI,CAQL,GAAAP,IAAA;IACC,KAAK,CACHG,KAAK,CAACK,YAAY,IAChB,0DAA0D,EAC5D;MACEL,KAAK;MACLM,YAAY,EAAE,CACZ,IAAIN,KAAK,CAACM,YAAY,IAAI,EAAE,CAAC,EAC7B,CAAAR,mBAAA,GAAAE,KAAK,CAACM,YAAY,cAAAR,mBAAA,eAAlBA,mBAAA,CAAoBS,MAAM,GAAG,EAAE,GAAG,EAAE,EACpC,wBAAwB,EACxBH,IAAI,IAAI,CACN,mBAAmB,EACnB,GAAGA,IAAI,CAACI,GAAG,CAAEC,GAAG,WAAAC,MAAA,CAAYhB,MAAM,CAACe,GAAG,CAAC,CAAE,CAAC,CAC3C,eAAAC,MAAA,CACYP,MAAM,cAAAO,MAAA,CACRT,IAAI,2BAAAS,MAAA,CACSX,gBAAgB,oBAAAW,MAAA,CACvBR,SAAS,EAC3B,CAACS,IAAI,EAAE;MACRC,IAAI,EAAE;KACP,CACF;EACH;;AAOF,OAAM,MAAOC,oCAAqC,SAAQpB,SAAS;EACjEG,YAAAkB,KAAA,EAAyD;IAAA,IAA7C;MAAEC,MAAM;MAAEN;IAAG,CAAgC,GAAAK,KAAA;IACvD,KAAK,CACH,4EAA4E,EAC5E;MACER,YAAY,EAAE,iBAAAI,MAAA,CACIhB,MAAM,CAACe,GAAG,CAAC,gBAAAC,MAAA,CACdlB,SAAS,CAACuB,MAAM,CAAC,EAC/B;MACDH,IAAI,EAAE;KACP,CACF;EACH;;AAQF,OAAM,MAAOI,iCAAkC,SAAQvB,SAAS;EAC9DG,YAAAqB,KAAA,EAA4D;IAAA,IAAhD;MAAEd,MAAM;MAAEe;IAAE,CAAoC,GAAAD,KAAA;IAC1D,KAAK,CACH,wEAAwE,EACxE;MACEX,YAAY,EAAE,sBAAAI,MAAA,CACSQ,EAAE,qCAAAR,MAAA,CACWP,MAAM,EACzC;MACDS,IAAI,EAAE;KACP,CACF;EACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}