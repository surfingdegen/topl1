{"ast":null,"code":"import { SizeExceedsPaddingSizeError } from '../../errors/data.js';\nexport function pad(hexOrBytes) {\n  let {\n    dir,\n    size = 32\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (typeof hexOrBytes === 'string') return padHex(hexOrBytes, {\n    dir,\n    size\n  });\n  return padBytes(hexOrBytes, {\n    dir,\n    size\n  });\n}\nexport function padHex(hex_) {\n  let {\n    dir,\n    size = 32\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (size === null) return hex_;\n  const hex = hex_.replace('0x', '');\n  if (hex.length > size * 2) throw new SizeExceedsPaddingSizeError({\n    size: Math.ceil(hex.length / 2),\n    targetSize: size,\n    type: 'hex'\n  });\n  return \"0x\".concat(hex[dir === 'right' ? 'padEnd' : 'padStart'](size * 2, '0'));\n}\nexport function padBytes(bytes) {\n  let {\n    dir,\n    size = 32\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (size === null) return bytes;\n  if (bytes.length > size) throw new SizeExceedsPaddingSizeError({\n    size: bytes.length,\n    targetSize: size,\n    type: 'bytes'\n  });\n  const paddedBytes = new Uint8Array(size);\n  for (let i = 0; i < size; i++) {\n    const padEnd = dir === 'right';\n    paddedBytes[padEnd ? i : size - i - 1] = bytes[padEnd ? i : bytes.length - i - 1];\n  }\n  return paddedBytes;\n}","map":{"version":3,"names":["SizeExceedsPaddingSizeError","pad","hexOrBytes","dir","size","arguments","length","undefined","padHex","padBytes","hex_","hex","replace","Math","ceil","targetSize","type","concat","bytes","paddedBytes","Uint8Array","i","padEnd"],"sources":["/Users/mac/Desktop/topl1/frontend/node_modules/viem/utils/data/pad.ts"],"sourcesContent":["import {\n  SizeExceedsPaddingSizeError,\n  type SizeExceedsPaddingSizeErrorType,\n} from '../../errors/data.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\ntype PadOptions = {\n  dir?: 'left' | 'right' | undefined\n  size?: number | null | undefined\n}\nexport type PadReturnType<value extends ByteArray | Hex> = value extends Hex\n  ? Hex\n  : ByteArray\n\nexport type PadErrorType = PadHexErrorType | PadBytesErrorType | ErrorType\n\nexport function pad<value extends ByteArray | Hex>(\n  hexOrBytes: value,\n  { dir, size = 32 }: PadOptions = {},\n): PadReturnType<value> {\n  if (typeof hexOrBytes === 'string')\n    return padHex(hexOrBytes, { dir, size }) as PadReturnType<value>\n  return padBytes(hexOrBytes, { dir, size }) as PadReturnType<value>\n}\n\nexport type PadHexErrorType = SizeExceedsPaddingSizeErrorType | ErrorType\n\nexport function padHex(hex_: Hex, { dir, size = 32 }: PadOptions = {}) {\n  if (size === null) return hex_\n  const hex = hex_.replace('0x', '')\n  if (hex.length > size * 2)\n    throw new SizeExceedsPaddingSizeError({\n      size: Math.ceil(hex.length / 2),\n      targetSize: size,\n      type: 'hex',\n    })\n\n  return `0x${hex[dir === 'right' ? 'padEnd' : 'padStart'](\n    size * 2,\n    '0',\n  )}` as Hex\n}\n\nexport type PadBytesErrorType = SizeExceedsPaddingSizeErrorType | ErrorType\n\nexport function padBytes(\n  bytes: ByteArray,\n  { dir, size = 32 }: PadOptions = {},\n) {\n  if (size === null) return bytes\n  if (bytes.length > size)\n    throw new SizeExceedsPaddingSizeError({\n      size: bytes.length,\n      targetSize: size,\n      type: 'bytes',\n    })\n  const paddedBytes = new Uint8Array(size)\n  for (let i = 0; i < size; i++) {\n    const padEnd = dir === 'right'\n    paddedBytes[padEnd ? i : size - i - 1] =\n      bytes[padEnd ? i : bytes.length - i - 1]\n  }\n  return paddedBytes\n}\n"],"mappings":"AAAA,SACEA,2BAA2B,QAEtB,sBAAsB;AAc7B,OAAM,SAAUC,GAAGA,CACjBC,UAAiB,EACkB;EAAA,IAAnC;IAAEC,GAAG;IAAEC,IAAI,GAAG;EAAE,IAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAiB,EAAE;EAEnC,IAAI,OAAOH,UAAU,KAAK,QAAQ,EAChC,OAAOM,MAAM,CAACN,UAAU,EAAE;IAAEC,GAAG;IAAEC;EAAI,CAAE,CAAyB;EAClE,OAAOK,QAAQ,CAACP,UAAU,EAAE;IAAEC,GAAG;IAAEC;EAAI,CAAE,CAAyB;AACpE;AAIA,OAAM,SAAUI,MAAMA,CAACE,IAAS,EAAqC;EAAA,IAAnC;IAAEP,GAAG;IAAEC,IAAI,GAAG;EAAE,IAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAiB,EAAE;EACnE,IAAID,IAAI,KAAK,IAAI,EAAE,OAAOM,IAAI;EAC9B,MAAMC,GAAG,GAAGD,IAAI,CAACE,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC;EAClC,IAAID,GAAG,CAACL,MAAM,GAAGF,IAAI,GAAG,CAAC,EACvB,MAAM,IAAIJ,2BAA2B,CAAC;IACpCI,IAAI,EAAES,IAAI,CAACC,IAAI,CAACH,GAAG,CAACL,MAAM,GAAG,CAAC,CAAC;IAC/BS,UAAU,EAAEX,IAAI;IAChBY,IAAI,EAAE;GACP,CAAC;EAEJ,YAAAC,MAAA,CAAYN,GAAG,CAACR,GAAG,KAAK,OAAO,GAAG,QAAQ,GAAG,UAAU,CAAC,CACtDC,IAAI,GAAG,CAAC,EACR,GAAG,CACJ;AACH;AAIA,OAAM,SAAUK,QAAQA,CACtBS,KAAgB,EACmB;EAAA,IAAnC;IAAEf,GAAG;IAAEC,IAAI,GAAG;EAAE,IAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAiB,EAAE;EAEnC,IAAID,IAAI,KAAK,IAAI,EAAE,OAAOc,KAAK;EAC/B,IAAIA,KAAK,CAACZ,MAAM,GAAGF,IAAI,EACrB,MAAM,IAAIJ,2BAA2B,CAAC;IACpCI,IAAI,EAAEc,KAAK,CAACZ,MAAM;IAClBS,UAAU,EAAEX,IAAI;IAChBY,IAAI,EAAE;GACP,CAAC;EACJ,MAAMG,WAAW,GAAG,IAAIC,UAAU,CAAChB,IAAI,CAAC;EACxC,KAAK,IAAIiB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGjB,IAAI,EAAEiB,CAAC,EAAE,EAAE;IAC7B,MAAMC,MAAM,GAAGnB,GAAG,KAAK,OAAO;IAC9BgB,WAAW,CAACG,MAAM,GAAGD,CAAC,GAAGjB,IAAI,GAAGiB,CAAC,GAAG,CAAC,CAAC,GACpCH,KAAK,CAACI,MAAM,GAAGD,CAAC,GAAGH,KAAK,CAACZ,MAAM,GAAGe,CAAC,GAAG,CAAC,CAAC;EAC5C;EACA,OAAOF,WAAW;AACpB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}