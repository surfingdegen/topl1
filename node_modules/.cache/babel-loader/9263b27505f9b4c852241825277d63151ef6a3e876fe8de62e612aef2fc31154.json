{"ast":null,"code":"import _objectSpread from \"/Users/mac/Desktop/topl1/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport * as AbiParameters from '../core/AbiParameters.js';\nimport * as Authorization from '../core/Authorization.js';\nimport * as Errors from '../core/Errors.js';\nimport * as Hex from '../core/Hex.js';\nimport * as Secp256k1 from '../core/Secp256k1.js';\nimport * as Signature from '../core/Signature.js';\n/**\n * Magic bytes used to identify ERC-8010 wrapped signatures.\n */\nexport const magicBytes = '0x8010801080108010801080108010801080108010801080108010801080108010';\n/** Suffix ABI parameters for the ERC-8010 wrapped signature. */\nexport const suffixParameters = AbiParameters.from('(uint256 chainId, address delegation, uint256 nonce, uint8 yParity, uint256 r, uint256 s), address to, bytes data');\n/**\n * Asserts that the wrapped signature is valid.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc8010 } from 'ox/erc8010'\n *\n * SignatureErc8010.assert('0xdeadbeef')\n * // @error: InvalidWrappedSignatureError: Value `0xdeadbeef` is an invalid ERC-8010 wrapped signature.\n * ```\n *\n * @param value - The value to assert.\n */\nexport function assert(value) {\n  if (typeof value === 'string') {\n    if (Hex.slice(value, -32) !== magicBytes) throw new InvalidWrappedSignatureError(value);\n  } else Signature.assert(value.authorization);\n}\n/**\n * Parses an [ERC-8010 wrapped signature](https://github.com/jxom/ERCs/blob/16f7e3891fff2e1e9c25dea0485497739db8a816/ERCS/erc-8010.md) into its constituent parts.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1 } from 'ox'\n * import { SignatureErc8010 } from 'ox/erc8010' // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload: '0x...',\n *   privateKey: '0x...',\n * })\n *\n * // Instantiate from serialized format. // [!code focus]\n * const wrapped = SignatureErc8010.from('0x...') // [!code focus]\n * // @log: { authorization: { ... }, data: '0x...', signature: { ... } } // [!code focus]\n *\n * // Instantiate from constituent parts. // [!code focus]\n * const wrapped = SignatureErc8010.from({ // [!code focus]\n *   authorization: { ... }, // [!code focus]\n *   data: '0x...', // [!code focus]\n *   signature, // [!code focus]\n * })\n * // @log: { authorization: { ... }, data: '0x...', signature: { ... } }\n * ```\n *\n * @param value - Value to parse.\n * @returns Parsed value.\n */\nexport function from(value) {\n  if (typeof value === 'string') return unwrap(value);\n  return value;\n}\n/**\n * Unwraps an [ERC-8010 wrapped signature](https://github.com/jxom/ERCs/blob/16f7e3891fff2e1e9c25dea0485497739db8a816/ERCS/erc-8010.md) into its constituent parts.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc8010 } from 'ox/erc8010'\n *\n * const { authorization, data, signature } = SignatureErc8010.unwrap('0x...')\n * ```\n *\n * @param wrapped - Wrapped signature to unwrap.\n * @returns Unwrapped signature.\n */\nexport function unwrap(wrapped) {\n  assert(wrapped);\n  const suffixLength = Hex.toNumber(Hex.slice(wrapped, -64, -32));\n  const suffix = Hex.slice(wrapped, -suffixLength - 64, -64);\n  const signature = Hex.slice(wrapped, 0, -suffixLength - 64);\n  const [auth, to, data] = AbiParameters.decode(suffixParameters, suffix);\n  const authorization = Authorization.from({\n    address: auth.delegation,\n    chainId: Number(auth.chainId),\n    nonce: auth.nonce,\n    yParity: auth.yParity,\n    r: auth.r,\n    s: auth.s\n  });\n  return _objectSpread({\n    authorization,\n    signature\n  }, data && data !== '0x' ? {\n    data,\n    to\n  } : {});\n}\n/**\n * Wraps a signature into [ERC-8010 format](https://github.com/jxom/ERCs/blob/16f7e3891fff2e1e9c25dea0485497739db8a816/ERCS/erc-8010.md).\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, Signature } from 'ox'\n * import { SignatureErc8010 } from 'ox/erc8010' // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload: '0x...',\n *   privateKey: '0x...',\n * })\n *\n * const wrapped = SignatureErc8010.wrap({ // [!code focus]\n *   authorization: { ... }, // [!code focus]\n *   data: '0xdeadbeef', // [!code focus]\n *   signature: Signature.toHex(signature), // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param value - Values to wrap.\n * @returns Wrapped signature.\n */\nexport function wrap(value) {\n  var _value$to;\n  const {\n    data,\n    signature\n  } = value;\n  assert(value);\n  const self = Secp256k1.recoverAddress({\n    payload: Authorization.getSignPayload(value.authorization),\n    signature: Signature.from(value.authorization)\n  });\n  const suffix = AbiParameters.encode(suffixParameters, [_objectSpread(_objectSpread({}, value.authorization), {}, {\n    delegation: value.authorization.address,\n    chainId: BigInt(value.authorization.chainId)\n  }), (_value$to = value.to) !== null && _value$to !== void 0 ? _value$to : self, data !== null && data !== void 0 ? data : '0x']);\n  const suffixLength = Hex.fromNumber(Hex.size(suffix), {\n    size: 32\n  });\n  return Hex.concat(signature, suffix, suffixLength, magicBytes);\n}\n/**\n * Validates a wrapped signature. Returns `true` if the wrapped signature is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc8010 } from 'ox/erc8010'\n *\n * const valid = SignatureErc8010.validate('0xdeadbeef')\n * // @log: false\n * ```\n *\n * @param value - The value to validate.\n * @returns `true` if the value is valid, `false` otherwise.\n */\nexport function validate(value) {\n  try {\n    assert(value);\n    return true;\n  } catch (_unused) {\n    return false;\n  }\n}\n/** Thrown when the ERC-8010 wrapped signature is invalid. */\nexport class InvalidWrappedSignatureError extends Errors.BaseError {\n  constructor(wrapped) {\n    super(\"Value `\".concat(wrapped, \"` is an invalid ERC-8010 wrapped signature.\"));\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'SignatureErc8010.InvalidWrappedSignatureError'\n    });\n  }\n}","map":{"version":3,"names":["AbiParameters","Authorization","Errors","Hex","Secp256k1","Signature","magicBytes","suffixParameters","from","assert","value","slice","InvalidWrappedSignatureError","authorization","unwrap","wrapped","suffixLength","toNumber","suffix","signature","auth","to","data","decode","address","delegation","chainId","Number","nonce","yParity","r","s","_objectSpread","wrap","_value$to","self","recoverAddress","payload","getSignPayload","encode","BigInt","fromNumber","size","concat","validate","_unused","BaseError","constructor","Object","defineProperty"],"sources":["/Users/mac/Desktop/topl1/frontend/node_modules/ox/erc8010/SignatureErc8010.ts"],"sourcesContent":["import * as AbiParameters from '../core/AbiParameters.js'\nimport type * as Address from '../core/Address.js'\nimport * as Authorization from '../core/Authorization.js'\nimport * as Errors from '../core/Errors.js'\nimport * as Hex from '../core/Hex.js'\nimport * as Secp256k1 from '../core/Secp256k1.js'\nimport * as Signature from '../core/Signature.js'\n\n/** Unwrapped ERC-8010 signature. */\nexport type Unwrapped = {\n  /** Authorization signed by the delegatee. */\n  authorization: Authorization.Authorization<true>\n  /** Data to initialize the delegation. */\n  data?: Hex.Hex | undefined\n  /** The original signature. */\n  signature: Hex.Hex\n  /** Address of the initializer. */\n  to?: Address.Address | undefined\n}\n\n/** Wrapped ERC-8010 signature. */\nexport type Wrapped = Hex.Hex\n\n/**\n * Magic bytes used to identify ERC-8010 wrapped signatures.\n */\nexport const magicBytes =\n  '0x8010801080108010801080108010801080108010801080108010801080108010' as const\n\n/** Suffix ABI parameters for the ERC-8010 wrapped signature. */\nexport const suffixParameters = AbiParameters.from(\n  '(uint256 chainId, address delegation, uint256 nonce, uint8 yParity, uint256 r, uint256 s), address to, bytes data',\n)\n\n/**\n * Asserts that the wrapped signature is valid.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc8010 } from 'ox/erc8010'\n *\n * SignatureErc8010.assert('0xdeadbeef')\n * // @error: InvalidWrappedSignatureError: Value `0xdeadbeef` is an invalid ERC-8010 wrapped signature.\n * ```\n *\n * @param value - The value to assert.\n */\nexport function assert(value: Unwrapped | Wrapped) {\n  if (typeof value === 'string') {\n    if (Hex.slice(value, -32) !== magicBytes)\n      throw new InvalidWrappedSignatureError(value)\n  } else Signature.assert(value.authorization)\n}\n\nexport declare namespace assert {\n  type ErrorType =\n    | InvalidWrappedSignatureError\n    | Hex.slice.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Parses an [ERC-8010 wrapped signature](https://github.com/jxom/ERCs/blob/16f7e3891fff2e1e9c25dea0485497739db8a816/ERCS/erc-8010.md) into its constituent parts.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1 } from 'ox'\n * import { SignatureErc8010 } from 'ox/erc8010' // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload: '0x...',\n *   privateKey: '0x...',\n * })\n *\n * // Instantiate from serialized format. // [!code focus]\n * const wrapped = SignatureErc8010.from('0x...') // [!code focus]\n * // @log: { authorization: { ... }, data: '0x...', signature: { ... } } // [!code focus]\n *\n * // Instantiate from constituent parts. // [!code focus]\n * const wrapped = SignatureErc8010.from({ // [!code focus]\n *   authorization: { ... }, // [!code focus]\n *   data: '0x...', // [!code focus]\n *   signature, // [!code focus]\n * })\n * // @log: { authorization: { ... }, data: '0x...', signature: { ... } }\n * ```\n *\n * @param value - Value to parse.\n * @returns Parsed value.\n */\nexport function from(value: Unwrapped | Wrapped): Unwrapped {\n  if (typeof value === 'string') return unwrap(value)\n  return value\n}\n\nexport declare namespace from {\n  type ErrorType = unwrap.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Unwraps an [ERC-8010 wrapped signature](https://github.com/jxom/ERCs/blob/16f7e3891fff2e1e9c25dea0485497739db8a816/ERCS/erc-8010.md) into its constituent parts.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc8010 } from 'ox/erc8010'\n *\n * const { authorization, data, signature } = SignatureErc8010.unwrap('0x...')\n * ```\n *\n * @param wrapped - Wrapped signature to unwrap.\n * @returns Unwrapped signature.\n */\nexport function unwrap(wrapped: Wrapped): Unwrapped {\n  assert(wrapped)\n\n  const suffixLength = Hex.toNumber(Hex.slice(wrapped, -64, -32))\n  const suffix = Hex.slice(wrapped, -suffixLength - 64, -64)\n  const signature = Hex.slice(wrapped, 0, -suffixLength - 64)\n\n  const [auth, to, data] = AbiParameters.decode(suffixParameters, suffix)\n\n  const authorization = Authorization.from({\n    address: auth.delegation,\n    chainId: Number(auth.chainId),\n    nonce: auth.nonce,\n    yParity: auth.yParity,\n    r: auth.r,\n    s: auth.s,\n  })\n\n  return {\n    authorization,\n    signature,\n    ...(data && data !== '0x' ? { data, to } : {}),\n  }\n}\n\nexport declare namespace unwrap {\n  type ErrorType = assert.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Wraps a signature into [ERC-8010 format](https://github.com/jxom/ERCs/blob/16f7e3891fff2e1e9c25dea0485497739db8a816/ERCS/erc-8010.md).\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, Signature } from 'ox'\n * import { SignatureErc8010 } from 'ox/erc8010' // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload: '0x...',\n *   privateKey: '0x...',\n * })\n *\n * const wrapped = SignatureErc8010.wrap({ // [!code focus]\n *   authorization: { ... }, // [!code focus]\n *   data: '0xdeadbeef', // [!code focus]\n *   signature: Signature.toHex(signature), // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param value - Values to wrap.\n * @returns Wrapped signature.\n */\nexport function wrap(value: Unwrapped): Wrapped {\n  const { data, signature } = value\n\n  assert(value)\n\n  const self = Secp256k1.recoverAddress({\n    payload: Authorization.getSignPayload(value.authorization),\n    signature: Signature.from(value.authorization),\n  })\n\n  const suffix = AbiParameters.encode(suffixParameters, [\n    {\n      ...value.authorization,\n      delegation: value.authorization.address,\n      chainId: BigInt(value.authorization.chainId),\n    },\n    value.to ?? self,\n    data ?? '0x',\n  ])\n  const suffixLength = Hex.fromNumber(Hex.size(suffix), { size: 32 })\n  return Hex.concat(signature, suffix, suffixLength, magicBytes)\n}\n\nexport declare namespace wrap {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Validates a wrapped signature. Returns `true` if the wrapped signature is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc8010 } from 'ox/erc8010'\n *\n * const valid = SignatureErc8010.validate('0xdeadbeef')\n * // @log: false\n * ```\n *\n * @param value - The value to validate.\n * @returns `true` if the value is valid, `false` otherwise.\n */\nexport function validate(value: Unwrapped | Wrapped): boolean {\n  try {\n    assert(value)\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport declare namespace validate {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/** Thrown when the ERC-8010 wrapped signature is invalid. */\nexport class InvalidWrappedSignatureError extends Errors.BaseError {\n  override readonly name = 'SignatureErc8010.InvalidWrappedSignatureError'\n\n  constructor(wrapped: Wrapped) {\n    super(`Value \\`${wrapped}\\` is an invalid ERC-8010 wrapped signature.`)\n  }\n}\n"],"mappings":";AAAA,OAAO,KAAKA,aAAa,MAAM,0BAA0B;AAEzD,OAAO,KAAKC,aAAa,MAAM,0BAA0B;AACzD,OAAO,KAAKC,MAAM,MAAM,mBAAmB;AAC3C,OAAO,KAAKC,GAAG,MAAM,gBAAgB;AACrC,OAAO,KAAKC,SAAS,MAAM,sBAAsB;AACjD,OAAO,KAAKC,SAAS,MAAM,sBAAsB;AAiBjD;;;AAGA,OAAO,MAAMC,UAAU,GACrB,oEAA6E;AAE/E;AACA,OAAO,MAAMC,gBAAgB,GAAGP,aAAa,CAACQ,IAAI,CAChD,mHAAmH,CACpH;AAED;;;;;;;;;;;;;AAaA,OAAM,SAAUC,MAAMA,CAACC,KAA0B;EAC/C,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;IAC7B,IAAIP,GAAG,CAACQ,KAAK,CAACD,KAAK,EAAE,CAAC,EAAE,CAAC,KAAKJ,UAAU,EACtC,MAAM,IAAIM,4BAA4B,CAACF,KAAK,CAAC;EACjD,CAAC,MAAML,SAAS,CAACI,MAAM,CAACC,KAAK,CAACG,aAAa,CAAC;AAC9C;AASA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8BA,OAAM,SAAUL,IAAIA,CAACE,KAA0B;EAC7C,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE,OAAOI,MAAM,CAACJ,KAAK,CAAC;EACnD,OAAOA,KAAK;AACd;AAMA;;;;;;;;;;;;;AAaA,OAAM,SAAUI,MAAMA,CAACC,OAAgB;EACrCN,MAAM,CAACM,OAAO,CAAC;EAEf,MAAMC,YAAY,GAAGb,GAAG,CAACc,QAAQ,CAACd,GAAG,CAACQ,KAAK,CAACI,OAAO,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC,CAAC;EAC/D,MAAMG,MAAM,GAAGf,GAAG,CAACQ,KAAK,CAACI,OAAO,EAAE,CAACC,YAAY,GAAG,EAAE,EAAE,CAAC,EAAE,CAAC;EAC1D,MAAMG,SAAS,GAAGhB,GAAG,CAACQ,KAAK,CAACI,OAAO,EAAE,CAAC,EAAE,CAACC,YAAY,GAAG,EAAE,CAAC;EAE3D,MAAM,CAACI,IAAI,EAAEC,EAAE,EAAEC,IAAI,CAAC,GAAGtB,aAAa,CAACuB,MAAM,CAAChB,gBAAgB,EAAEW,MAAM,CAAC;EAEvE,MAAML,aAAa,GAAGZ,aAAa,CAACO,IAAI,CAAC;IACvCgB,OAAO,EAAEJ,IAAI,CAACK,UAAU;IACxBC,OAAO,EAAEC,MAAM,CAACP,IAAI,CAACM,OAAO,CAAC;IAC7BE,KAAK,EAAER,IAAI,CAACQ,KAAK;IACjBC,OAAO,EAAET,IAAI,CAACS,OAAO;IACrBC,CAAC,EAAEV,IAAI,CAACU,CAAC;IACTC,CAAC,EAAEX,IAAI,CAACW;GACT,CAAC;EAEF,OAAAC,aAAA;IACEnB,aAAa;IACbM;EAAS,GACLG,IAAI,IAAIA,IAAI,KAAK,IAAI,GAAG;IAAEA,IAAI;IAAED;EAAE,CAAE,GAAG,EAAE;AAEjD;AAMA;;;;;;;;;;;;;;;;;;;;;;;;AAwBA,OAAM,SAAUY,IAAIA,CAACvB,KAAgB;EAAA,IAAAwB,SAAA;EACnC,MAAM;IAAEZ,IAAI;IAAEH;EAAS,CAAE,GAAGT,KAAK;EAEjCD,MAAM,CAACC,KAAK,CAAC;EAEb,MAAMyB,IAAI,GAAG/B,SAAS,CAACgC,cAAc,CAAC;IACpCC,OAAO,EAAEpC,aAAa,CAACqC,cAAc,CAAC5B,KAAK,CAACG,aAAa,CAAC;IAC1DM,SAAS,EAAEd,SAAS,CAACG,IAAI,CAACE,KAAK,CAACG,aAAa;GAC9C,CAAC;EAEF,MAAMK,MAAM,GAAGlB,aAAa,CAACuC,MAAM,CAAChC,gBAAgB,EAAE,CAAAyB,aAAA,CAAAA,aAAA,KAE/CtB,KAAK,CAACG,aAAa;IACtBY,UAAU,EAAEf,KAAK,CAACG,aAAa,CAACW,OAAO;IACvCE,OAAO,EAAEc,MAAM,CAAC9B,KAAK,CAACG,aAAa,CAACa,OAAO;EAAC,KAAAQ,SAAA,GAE9CxB,KAAK,CAACW,EAAE,cAAAa,SAAA,cAAAA,SAAA,GAAIC,IAAI,EAChBb,IAAI,aAAJA,IAAI,cAAJA,IAAI,GAAI,IAAI,CACb,CAAC;EACF,MAAMN,YAAY,GAAGb,GAAG,CAACsC,UAAU,CAACtC,GAAG,CAACuC,IAAI,CAACxB,MAAM,CAAC,EAAE;IAAEwB,IAAI,EAAE;EAAE,CAAE,CAAC;EACnE,OAAOvC,GAAG,CAACwC,MAAM,CAACxB,SAAS,EAAED,MAAM,EAAEF,YAAY,EAAEV,UAAU,CAAC;AAChE;AAMA;;;;;;;;;;;;;;AAcA,OAAM,SAAUsC,QAAQA,CAAClC,KAA0B;EACjD,IAAI;IACFD,MAAM,CAACC,KAAK,CAAC;IACb,OAAO,IAAI;EACb,CAAC,CAAC,OAAAmC,OAAA,EAAM;IACN,OAAO,KAAK;EACd;AACF;AAMA;AACA,OAAM,MAAOjC,4BAA6B,SAAQV,MAAM,CAAC4C,SAAS;EAGhEC,YAAYhC,OAAgB;IAC1B,KAAK,WAAA4B,MAAA,CAAY5B,OAAO,gDAA8C,CAAC;IAHvDiC,MAAA,CAAAC,cAAA;;;;aAAO;;EAIzB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}