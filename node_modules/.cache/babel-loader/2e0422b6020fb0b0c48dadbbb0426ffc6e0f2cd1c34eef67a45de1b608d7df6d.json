{"ast":null,"code":"import { equalBytes } from '@noble/curves/abstract/utils';\nimport * as Errors from './Errors.js';\nimport * as Hex from './Hex.js';\nimport * as internal from './internal/bytes.js';\nimport * as internal_hex from './internal/hex.js';\nimport * as Json from './Json.js';\nconst decoder = /*#__PURE__*/new TextDecoder();\nconst encoder = /*#__PURE__*/new TextEncoder();\n/**\n * Asserts if the given value is {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.assert('abc')\n * // @error: Bytes.InvalidBytesTypeError:\n * // @error: Value `\"abc\"` of type `string` is an invalid Bytes value.\n * // @error: Bytes values must be of type `Uint8Array`.\n * ```\n *\n * @param value - Value to assert.\n */\nexport function assert(value) {\n  if (value instanceof Uint8Array) return;\n  if (!value) throw new InvalidBytesTypeError(value);\n  if (typeof value !== 'object') throw new InvalidBytesTypeError(value);\n  if (!('BYTES_PER_ELEMENT' in value)) throw new InvalidBytesTypeError(value);\n  if (value.BYTES_PER_ELEMENT !== 1 || value.constructor.name !== 'Uint8Array') throw new InvalidBytesTypeError(value);\n}\n/**\n * Concatenates two or more {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const bytes = Bytes.concat(\n *   Bytes.from([1]),\n *   Bytes.from([69]),\n *   Bytes.from([420, 69]),\n * )\n * // @log: Uint8Array [ 1, 69, 420, 69 ]\n * ```\n *\n * @param values - Values to concatenate.\n * @returns Concatenated {@link ox#Bytes.Bytes}.\n */\nexport function concat() {\n  let length = 0;\n  for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n    values[_key] = arguments[_key];\n  }\n  for (const arr of values) {\n    length += arr.length;\n  }\n  const result = new Uint8Array(length);\n  for (let i = 0, index = 0; i < values.length; i++) {\n    const arr = values[i];\n    result.set(arr, index);\n    index += arr.length;\n  }\n  return result;\n}\n/**\n * Instantiates a {@link ox#Bytes.Bytes} value from a `Uint8Array`, a hex string, or an array of unsigned 8-bit integers.\n *\n * :::tip\n *\n * To instantiate from a **Boolean**, **String**, or **Number**, use one of the following:\n *\n * - `Bytes.fromBoolean`\n *\n * - `Bytes.fromString`\n *\n * - `Bytes.fromNumber`\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.from([255, 124, 5, 4])\n * // @log: Uint8Array([255, 124, 5, 4])\n *\n * const data = Bytes.from('0xdeadbeef')\n * // @log: Uint8Array([222, 173, 190, 239])\n * ```\n *\n * @param value - Value to convert.\n * @returns A {@link ox#Bytes.Bytes} instance.\n */\nexport function from(value) {\n  if (value instanceof Uint8Array) return value;\n  if (typeof value === 'string') return fromHex(value);\n  return fromArray(value);\n}\n/**\n * Converts an array of unsigned 8-bit integers into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromArray([255, 124, 5, 4])\n * // @log: Uint8Array([255, 124, 5, 4])\n * ```\n *\n * @param value - Value to convert.\n * @returns A {@link ox#Bytes.Bytes} instance.\n */\nexport function fromArray(value) {\n  return value instanceof Uint8Array ? value : new Uint8Array(value);\n}\n/**\n * Encodes a boolean value into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromBoolean(true)\n * // @log: Uint8Array([1])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromBoolean(true, { size: 32 })\n * // @log: Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])\n * ```\n *\n * @param value - Boolean value to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nexport function fromBoolean(value) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    size\n  } = options;\n  const bytes = new Uint8Array(1);\n  bytes[0] = Number(value);\n  if (typeof size === 'number') {\n    internal.assertSize(bytes, size);\n    return padLeft(bytes, size);\n  }\n  return bytes;\n}\n/**\n * Encodes a {@link ox#Hex.Hex} value into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromHex('0x48656c6c6f20776f726c6421')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromHex('0x48656c6c6f20776f726c6421', { size: 32 })\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n * ```\n *\n * @param value - {@link ox#Hex.Hex} value to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nexport function fromHex(value) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    size\n  } = options;\n  let hex = value;\n  if (size) {\n    internal_hex.assertSize(value, size);\n    hex = Hex.padRight(value, size);\n  }\n  let hexString = hex.slice(2);\n  if (hexString.length % 2) hexString = \"0\".concat(hexString);\n  const length = hexString.length / 2;\n  const bytes = new Uint8Array(length);\n  for (let index = 0, j = 0; index < length; index++) {\n    const nibbleLeft = internal.charCodeToBase16(hexString.charCodeAt(j++));\n    const nibbleRight = internal.charCodeToBase16(hexString.charCodeAt(j++));\n    if (nibbleLeft === undefined || nibbleRight === undefined) {\n      throw new Errors.BaseError(\"Invalid byte sequence (\\\"\".concat(hexString[j - 2]).concat(hexString[j - 1], \"\\\" in \\\"\").concat(hexString, \"\\\").\"));\n    }\n    bytes[index] = nibbleLeft << 4 | nibbleRight;\n  }\n  return bytes;\n}\n/**\n * Encodes a number value into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromNumber(420)\n * // @log: Uint8Array([1, 164])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromNumber(420, { size: 4 })\n * // @log: Uint8Array([0, 0, 1, 164])\n * ```\n *\n * @param value - Number value to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nexport function fromNumber(value, options) {\n  const hex = Hex.fromNumber(value, options);\n  return fromHex(hex);\n}\n/**\n * Encodes a string into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromString('Hello world!')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromString('Hello world!', { size: 32 })\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n * ```\n *\n * @param value - String to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nexport function fromString(value) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    size\n  } = options;\n  const bytes = encoder.encode(value);\n  if (typeof size === 'number') {\n    internal.assertSize(bytes, size);\n    return padRight(bytes, size);\n  }\n  return bytes;\n}\n/**\n * Checks if two {@link ox#Bytes.Bytes} values are equal.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.isEqual(Bytes.from([1]), Bytes.from([1]))\n * // @log: true\n *\n * Bytes.isEqual(Bytes.from([1]), Bytes.from([2]))\n * // @log: false\n * ```\n *\n * @param bytesA - First {@link ox#Bytes.Bytes} value.\n * @param bytesB - Second {@link ox#Bytes.Bytes} value.\n * @returns `true` if the two values are equal, otherwise `false`.\n */\nexport function isEqual(bytesA, bytesB) {\n  return equalBytes(bytesA, bytesB);\n}\n/**\n * Pads a {@link ox#Bytes.Bytes} value to the left with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.padLeft(Bytes.from([1]), 4)\n * // @log: Uint8Array([0, 0, 0, 1])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value to pad.\n * @param size - Size to pad the {@link ox#Bytes.Bytes} value to.\n * @returns Padded {@link ox#Bytes.Bytes} value.\n */\nexport function padLeft(value, size) {\n  return internal.pad(value, {\n    dir: 'left',\n    size\n  });\n}\n/**\n * Pads a {@link ox#Bytes.Bytes} value to the right with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.padRight(Bytes.from([1]), 4)\n * // @log: Uint8Array([1, 0, 0, 0])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value to pad.\n * @param size - Size to pad the {@link ox#Bytes.Bytes} value to.\n * @returns Padded {@link ox#Bytes.Bytes} value.\n */\nexport function padRight(value, size) {\n  return internal.pad(value, {\n    dir: 'right',\n    size\n  });\n}\n/**\n * Generates random {@link ox#Bytes.Bytes} of the specified length.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const bytes = Bytes.random(32)\n * // @log: Uint8Array([... x32])\n * ```\n *\n * @param length - Length of the random {@link ox#Bytes.Bytes} to generate.\n * @returns Random {@link ox#Bytes.Bytes} of the specified length.\n */\nexport function random(length) {\n  return crypto.getRandomValues(new Uint8Array(length));\n}\n/**\n * Retrieves the size of a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.size(Bytes.from([1, 2, 3, 4]))\n * // @log: 4\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value.\n * @returns Size of the {@link ox#Bytes.Bytes} value.\n */\nexport function size(value) {\n  return value.length;\n}\n/**\n * Returns a section of a {@link ox#Bytes.Bytes} value given a start/end bytes offset.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.slice(\n *   Bytes.from([1, 2, 3, 4, 5, 6, 7, 8, 9]),\n *   1,\n *   4,\n * )\n * // @log: Uint8Array([2, 3, 4])\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value.\n * @param start - Start offset.\n * @param end - End offset.\n * @param options - Slice options.\n * @returns Sliced {@link ox#Bytes.Bytes} value.\n */\nexport function slice(value, start, end) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const {\n    strict\n  } = options;\n  internal.assertStartOffset(value, start);\n  const value_ = value.slice(start, end);\n  if (strict) internal.assertEndOffset(value_, start, end);\n  return value_;\n}\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a bigint.\n *\n * @example\n * ```ts\n * import { Bytes } from 'ox'\n *\n * Bytes.toBigInt(Bytes.from([1, 164]))\n * // @log: 420n\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Decoding options.\n * @returns Decoded bigint.\n */\nexport function toBigInt(bytes) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    size\n  } = options;\n  if (typeof size !== 'undefined') internal.assertSize(bytes, size);\n  const hex = Hex.fromBytes(bytes, options);\n  return Hex.toBigInt(hex, options);\n}\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a boolean.\n *\n * @example\n * ```ts\n * import { Bytes } from 'ox'\n *\n * Bytes.toBoolean(Bytes.from([1]))\n * // @log: true\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Decoding options.\n * @returns Decoded boolean.\n */\nexport function toBoolean(bytes) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    size\n  } = options;\n  let bytes_ = bytes;\n  if (typeof size !== 'undefined') {\n    internal.assertSize(bytes_, size);\n    bytes_ = trimLeft(bytes_);\n  }\n  if (bytes_.length > 1 || bytes_[0] > 1) throw new InvalidBytesBooleanError(bytes_);\n  return Boolean(bytes_[0]);\n}\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.toHex(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Options.\n * @returns Decoded {@link ox#Hex.Hex} value.\n */\nexport function toHex(value) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return Hex.fromBytes(value, options);\n}\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a number.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.toNumber(Bytes.from([1, 164]))\n * // @log: 420\n * ```\n */\nexport function toNumber(bytes) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    size\n  } = options;\n  if (typeof size !== 'undefined') internal.assertSize(bytes, size);\n  const hex = Hex.fromBytes(bytes, options);\n  return Hex.toNumber(hex, options);\n}\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a string.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.toString(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: 'Hello world'\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Options.\n * @returns Decoded string.\n */\nexport function toString(bytes) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    size\n  } = options;\n  let bytes_ = bytes;\n  if (typeof size !== 'undefined') {\n    internal.assertSize(bytes_, size);\n    bytes_ = trimRight(bytes_);\n  }\n  return decoder.decode(bytes_);\n}\n/**\n * Trims leading zeros from a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.trimLeft(Bytes.from([0, 0, 0, 0, 1, 2, 3]))\n * // @log: Uint8Array([1, 2, 3])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value.\n * @returns Trimmed {@link ox#Bytes.Bytes} value.\n */\nexport function trimLeft(value) {\n  return internal.trim(value, {\n    dir: 'left'\n  });\n}\n/**\n * Trims trailing zeros from a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.trimRight(Bytes.from([1, 2, 3, 0, 0, 0, 0]))\n * // @log: Uint8Array([1, 2, 3])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value.\n * @returns Trimmed {@link ox#Bytes.Bytes} value.\n */\nexport function trimRight(value) {\n  return internal.trim(value, {\n    dir: 'right'\n  });\n}\n/**\n * Checks if the given value is {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.validate('0x')\n * // @log: false\n *\n * Bytes.validate(Bytes.from([1, 2, 3]))\n * // @log: true\n * ```\n *\n * @param value - Value to check.\n * @returns `true` if the value is {@link ox#Bytes.Bytes}, otherwise `false`.\n */\nexport function validate(value) {\n  try {\n    assert(value);\n    return true;\n  } catch (_unused) {\n    return false;\n  }\n}\n/**\n * Thrown when the bytes value cannot be represented as a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.toBoolean(Bytes.from([5]))\n * // @error: Bytes.InvalidBytesBooleanError: Bytes value `[5]` is not a valid boolean.\n * // @error: The bytes array must contain a single byte of either a `0` or `1` value.\n * ```\n */\nexport class InvalidBytesBooleanError extends Errors.BaseError {\n  constructor(bytes) {\n    super(\"Bytes value `\".concat(bytes, \"` is not a valid boolean.\"), {\n      metaMessages: ['The bytes array must contain a single byte of either a `0` or `1` value.']\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Bytes.InvalidBytesBooleanError'\n    });\n  }\n}\n/**\n * Thrown when a value cannot be converted to bytes.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Bytes } from 'ox'\n *\n * Bytes.from('foo')\n * // @error: Bytes.InvalidBytesTypeError: Value `foo` of type `string` is an invalid Bytes value.\n * ```\n */\nexport class InvalidBytesTypeError extends Errors.BaseError {\n  constructor(value) {\n    super(\"Value `\".concat(typeof value === 'object' ? Json.stringify(value) : value, \"` of type `\").concat(typeof value, \"` is an invalid Bytes value.\"), {\n      metaMessages: ['Bytes values must be of type `Bytes`.']\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Bytes.InvalidBytesTypeError'\n    });\n  }\n}\n/**\n * Thrown when a size exceeds the maximum allowed size.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.fromString('Hello World!', { size: 8 })\n * // @error: Bytes.SizeOverflowError: Size cannot exceed `8` bytes. Given size: `12` bytes.\n * ```\n */\nexport class SizeOverflowError extends Errors.BaseError {\n  constructor(_ref) {\n    let {\n      givenSize,\n      maxSize\n    } = _ref;\n    super(\"Size cannot exceed `\".concat(maxSize, \"` bytes. Given size: `\").concat(givenSize, \"` bytes.\"));\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Bytes.SizeOverflowError'\n    });\n  }\n}\n/**\n * Thrown when a slice offset is out-of-bounds.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.slice(Bytes.from([1, 2, 3]), 4)\n * // @error: Bytes.SliceOffsetOutOfBoundsError: Slice starting at offset `4` is out-of-bounds (size: `3`).\n * ```\n */\nexport class SliceOffsetOutOfBoundsError extends Errors.BaseError {\n  constructor(_ref2) {\n    let {\n      offset,\n      position,\n      size\n    } = _ref2;\n    super(\"Slice \".concat(position === 'start' ? 'starting' : 'ending', \" at offset `\").concat(offset, \"` is out-of-bounds (size: `\").concat(size, \"`).\"));\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Bytes.SliceOffsetOutOfBoundsError'\n    });\n  }\n}\n/**\n * Thrown when a the padding size exceeds the maximum allowed size.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.padLeft(Bytes.fromString('Hello World!'), 8)\n * // @error: [Bytes.SizeExceedsPaddingSizeError: Bytes size (`12`) exceeds padding size (`8`).\n * ```\n */\nexport class SizeExceedsPaddingSizeError extends Errors.BaseError {\n  constructor(_ref3) {\n    let {\n      size,\n      targetSize,\n      type\n    } = _ref3;\n    super(\"\".concat(type.charAt(0).toUpperCase()).concat(type.slice(1).toLowerCase(), \" size (`\").concat(size, \"`) exceeds padding size (`\").concat(targetSize, \"`).\"));\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Bytes.SizeExceedsPaddingSizeError'\n    });\n  }\n}","map":{"version":3,"names":["equalBytes","Errors","Hex","internal","internal_hex","Json","decoder","TextDecoder","encoder","TextEncoder","assert","value","Uint8Array","InvalidBytesTypeError","BYTES_PER_ELEMENT","constructor","name","concat","length","_len","arguments","values","Array","_key","arr","result","i","index","set","from","fromHex","fromArray","fromBoolean","options","undefined","size","bytes","Number","assertSize","padLeft","hex","padRight","hexString","slice","j","nibbleLeft","charCodeToBase16","charCodeAt","nibbleRight","BaseError","fromNumber","fromString","encode","isEqual","bytesA","bytesB","pad","dir","random","crypto","getRandomValues","start","end","strict","assertStartOffset","value_","assertEndOffset","toBigInt","fromBytes","toBoolean","bytes_","trimLeft","InvalidBytesBooleanError","Boolean","toHex","toNumber","toString","trimRight","decode","trim","validate","_unused","metaMessages","Object","defineProperty","stringify","SizeOverflowError","_ref","givenSize","maxSize","SliceOffsetOutOfBoundsError","_ref2","offset","position","SizeExceedsPaddingSizeError","_ref3","targetSize","type","charAt","toUpperCase","toLowerCase"],"sources":["/Users/mac/Desktop/topl1/frontend/node_modules/ox/core/Bytes.ts"],"sourcesContent":["import { equalBytes } from '@noble/curves/abstract/utils'\nimport * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport * as internal from './internal/bytes.js'\nimport * as internal_hex from './internal/hex.js'\nimport * as Json from './Json.js'\n\nconst decoder = /*#__PURE__*/ new TextDecoder()\nconst encoder = /*#__PURE__*/ new TextEncoder()\n\n/** Root type for a Bytes array. */\nexport type Bytes = Uint8Array\n\n/**\n * Asserts if the given value is {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.assert('abc')\n * // @error: Bytes.InvalidBytesTypeError:\n * // @error: Value `\"abc\"` of type `string` is an invalid Bytes value.\n * // @error: Bytes values must be of type `Uint8Array`.\n * ```\n *\n * @param value - Value to assert.\n */\nexport function assert(value: unknown): asserts value is Bytes {\n  if (value instanceof Uint8Array) return\n  if (!value) throw new InvalidBytesTypeError(value)\n  if (typeof value !== 'object') throw new InvalidBytesTypeError(value)\n  if (!('BYTES_PER_ELEMENT' in value)) throw new InvalidBytesTypeError(value)\n  if (value.BYTES_PER_ELEMENT !== 1 || value.constructor.name !== 'Uint8Array')\n    throw new InvalidBytesTypeError(value)\n}\n\nexport declare namespace assert {\n  type ErrorType = InvalidBytesTypeError | Errors.GlobalErrorType\n}\n\n/**\n * Concatenates two or more {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const bytes = Bytes.concat(\n *   Bytes.from([1]),\n *   Bytes.from([69]),\n *   Bytes.from([420, 69]),\n * )\n * // @log: Uint8Array [ 1, 69, 420, 69 ]\n * ```\n *\n * @param values - Values to concatenate.\n * @returns Concatenated {@link ox#Bytes.Bytes}.\n */\nexport function concat(...values: readonly Bytes[]): Bytes {\n  let length = 0\n  for (const arr of values) {\n    length += arr.length\n  }\n  const result = new Uint8Array(length)\n  for (let i = 0, index = 0; i < values.length; i++) {\n    const arr = values[i]\n    result.set(arr!, index)\n    index += arr!.length\n  }\n  return result\n}\n\nexport declare namespace concat {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Instantiates a {@link ox#Bytes.Bytes} value from a `Uint8Array`, a hex string, or an array of unsigned 8-bit integers.\n *\n * :::tip\n *\n * To instantiate from a **Boolean**, **String**, or **Number**, use one of the following:\n *\n * - `Bytes.fromBoolean`\n *\n * - `Bytes.fromString`\n *\n * - `Bytes.fromNumber`\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.from([255, 124, 5, 4])\n * // @log: Uint8Array([255, 124, 5, 4])\n *\n * const data = Bytes.from('0xdeadbeef')\n * // @log: Uint8Array([222, 173, 190, 239])\n * ```\n *\n * @param value - Value to convert.\n * @returns A {@link ox#Bytes.Bytes} instance.\n */\nexport function from(value: Hex.Hex | Bytes | readonly number[]): Bytes {\n  if (value instanceof Uint8Array) return value\n  if (typeof value === 'string') return fromHex(value)\n  return fromArray(value)\n}\n\nexport declare namespace from {\n  type ErrorType =\n    | fromHex.ErrorType\n    | fromArray.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Converts an array of unsigned 8-bit integers into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromArray([255, 124, 5, 4])\n * // @log: Uint8Array([255, 124, 5, 4])\n * ```\n *\n * @param value - Value to convert.\n * @returns A {@link ox#Bytes.Bytes} instance.\n */\nexport function fromArray(value: readonly number[] | Uint8Array): Bytes {\n  return value instanceof Uint8Array ? value : new Uint8Array(value)\n}\n\nexport declare namespace fromArray {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Encodes a boolean value into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromBoolean(true)\n * // @log: Uint8Array([1])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromBoolean(true, { size: 32 })\n * // @log: Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])\n * ```\n *\n * @param value - Boolean value to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nexport function fromBoolean(value: boolean, options: fromBoolean.Options = {}) {\n  const { size } = options\n  const bytes = new Uint8Array(1)\n  bytes[0] = Number(value)\n  if (typeof size === 'number') {\n    internal.assertSize(bytes, size)\n    return padLeft(bytes, size)\n  }\n  return bytes\n}\n\nexport declare namespace fromBoolean {\n  type Options = {\n    /** Size of the output bytes. */\n    size?: number | undefined\n  }\n\n  type ErrorType =\n    | internal.assertSize.ErrorType\n    | padLeft.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a {@link ox#Hex.Hex} value into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromHex('0x48656c6c6f20776f726c6421')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromHex('0x48656c6c6f20776f726c6421', { size: 32 })\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n * ```\n *\n * @param value - {@link ox#Hex.Hex} value to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nexport function fromHex(value: Hex.Hex, options: fromHex.Options = {}): Bytes {\n  const { size } = options\n\n  let hex = value\n  if (size) {\n    internal_hex.assertSize(value, size)\n    hex = Hex.padRight(value, size)\n  }\n\n  let hexString = hex.slice(2) as string\n  if (hexString.length % 2) hexString = `0${hexString}`\n\n  const length = hexString.length / 2\n  const bytes = new Uint8Array(length)\n  for (let index = 0, j = 0; index < length; index++) {\n    const nibbleLeft = internal.charCodeToBase16(hexString.charCodeAt(j++))\n    const nibbleRight = internal.charCodeToBase16(hexString.charCodeAt(j++))\n    if (nibbleLeft === undefined || nibbleRight === undefined) {\n      throw new Errors.BaseError(\n        `Invalid byte sequence (\"${hexString[j - 2]}${hexString[j - 1]}\" in \"${hexString}\").`,\n      )\n    }\n    bytes[index] = (nibbleLeft << 4) | nibbleRight\n  }\n  return bytes\n}\n\nexport declare namespace fromHex {\n  type Options = {\n    /** Size of the output bytes. */\n    size?: number | undefined\n  }\n\n  type ErrorType =\n    | internal_hex.assertSize.ErrorType\n    | Hex.padRight.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a number value into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromNumber(420)\n * // @log: Uint8Array([1, 164])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromNumber(420, { size: 4 })\n * // @log: Uint8Array([0, 0, 1, 164])\n * ```\n *\n * @param value - Number value to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nexport function fromNumber(\n  value: bigint | number,\n  options?: fromNumber.Options | undefined,\n) {\n  const hex = Hex.fromNumber(value, options)\n  return fromHex(hex)\n}\n\nexport declare namespace fromNumber {\n  export type Options = Hex.fromNumber.Options\n\n  export type ErrorType =\n    | Hex.fromNumber.ErrorType\n    | fromHex.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a string into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromString('Hello world!')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromString('Hello world!', { size: 32 })\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n * ```\n *\n * @param value - String to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nexport function fromString(\n  value: string,\n  options: fromString.Options = {},\n): Bytes {\n  const { size } = options\n\n  const bytes = encoder.encode(value)\n  if (typeof size === 'number') {\n    internal.assertSize(bytes, size)\n    return padRight(bytes, size)\n  }\n  return bytes\n}\n\nexport declare namespace fromString {\n  type Options = {\n    /** Size of the output bytes. */\n    size?: number | undefined\n  }\n\n  type ErrorType =\n    | internal.assertSize.ErrorType\n    | padRight.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Checks if two {@link ox#Bytes.Bytes} values are equal.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.isEqual(Bytes.from([1]), Bytes.from([1]))\n * // @log: true\n *\n * Bytes.isEqual(Bytes.from([1]), Bytes.from([2]))\n * // @log: false\n * ```\n *\n * @param bytesA - First {@link ox#Bytes.Bytes} value.\n * @param bytesB - Second {@link ox#Bytes.Bytes} value.\n * @returns `true` if the two values are equal, otherwise `false`.\n */\nexport function isEqual(bytesA: Bytes, bytesB: Bytes) {\n  return equalBytes(bytesA, bytesB)\n}\n\nexport declare namespace isEqual {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Pads a {@link ox#Bytes.Bytes} value to the left with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.padLeft(Bytes.from([1]), 4)\n * // @log: Uint8Array([0, 0, 0, 1])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value to pad.\n * @param size - Size to pad the {@link ox#Bytes.Bytes} value to.\n * @returns Padded {@link ox#Bytes.Bytes} value.\n */\nexport function padLeft(\n  value: Bytes,\n  size?: number | undefined,\n): padLeft.ReturnType {\n  return internal.pad(value, { dir: 'left', size })\n}\n\nexport declare namespace padLeft {\n  type ReturnType = internal.pad.ReturnType\n  type ErrorType = internal.pad.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Pads a {@link ox#Bytes.Bytes} value to the right with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.padRight(Bytes.from([1]), 4)\n * // @log: Uint8Array([1, 0, 0, 0])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value to pad.\n * @param size - Size to pad the {@link ox#Bytes.Bytes} value to.\n * @returns Padded {@link ox#Bytes.Bytes} value.\n */\nexport function padRight(\n  value: Bytes,\n  size?: number | undefined,\n): padRight.ReturnType {\n  return internal.pad(value, { dir: 'right', size })\n}\n\nexport declare namespace padRight {\n  type ReturnType = internal.pad.ReturnType\n  type ErrorType = internal.pad.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Generates random {@link ox#Bytes.Bytes} of the specified length.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const bytes = Bytes.random(32)\n * // @log: Uint8Array([... x32])\n * ```\n *\n * @param length - Length of the random {@link ox#Bytes.Bytes} to generate.\n * @returns Random {@link ox#Bytes.Bytes} of the specified length.\n */\nexport function random(length: number): Bytes {\n  return crypto.getRandomValues(new Uint8Array(length))\n}\n\nexport declare namespace random {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Retrieves the size of a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.size(Bytes.from([1, 2, 3, 4]))\n * // @log: 4\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value.\n * @returns Size of the {@link ox#Bytes.Bytes} value.\n */\nexport function size(value: Bytes): number {\n  return value.length\n}\n\nexport declare namespace size {\n  export type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Returns a section of a {@link ox#Bytes.Bytes} value given a start/end bytes offset.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.slice(\n *   Bytes.from([1, 2, 3, 4, 5, 6, 7, 8, 9]),\n *   1,\n *   4,\n * )\n * // @log: Uint8Array([2, 3, 4])\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value.\n * @param start - Start offset.\n * @param end - End offset.\n * @param options - Slice options.\n * @returns Sliced {@link ox#Bytes.Bytes} value.\n */\nexport function slice(\n  value: Bytes,\n  start?: number | undefined,\n  end?: number | undefined,\n  options: slice.Options = {},\n): Bytes {\n  const { strict } = options\n  internal.assertStartOffset(value, start)\n  const value_ = value.slice(start, end)\n  if (strict) internal.assertEndOffset(value_, start, end)\n  return value_\n}\n\nexport declare namespace slice {\n  type Options = {\n    /** Asserts that the sliced value is the same size as the given start/end offsets. */\n    strict?: boolean | undefined\n  }\n\n  export type ErrorType =\n    | internal.assertStartOffset.ErrorType\n    | internal.assertEndOffset.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a bigint.\n *\n * @example\n * ```ts\n * import { Bytes } from 'ox'\n *\n * Bytes.toBigInt(Bytes.from([1, 164]))\n * // @log: 420n\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Decoding options.\n * @returns Decoded bigint.\n */\nexport function toBigInt(bytes: Bytes, options: toBigInt.Options = {}): bigint {\n  const { size } = options\n  if (typeof size !== 'undefined') internal.assertSize(bytes, size)\n  const hex = Hex.fromBytes(bytes, options)\n  return Hex.toBigInt(hex, options)\n}\n\nexport declare namespace toBigInt {\n  type Options = {\n    /** Whether or not the number of a signed representation. */\n    signed?: boolean | undefined\n    /** Size of the bytes. */\n    size?: number | undefined\n  }\n\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | Hex.toBigInt.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a boolean.\n *\n * @example\n * ```ts\n * import { Bytes } from 'ox'\n *\n * Bytes.toBoolean(Bytes.from([1]))\n * // @log: true\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Decoding options.\n * @returns Decoded boolean.\n */\nexport function toBoolean(\n  bytes: Bytes,\n  options: toBoolean.Options = {},\n): boolean {\n  const { size } = options\n  let bytes_ = bytes\n  if (typeof size !== 'undefined') {\n    internal.assertSize(bytes_, size)\n    bytes_ = trimLeft(bytes_)\n  }\n  if (bytes_.length > 1 || bytes_[0]! > 1)\n    throw new InvalidBytesBooleanError(bytes_)\n  return Boolean(bytes_[0])\n}\n\nexport declare namespace toBoolean {\n  type Options = {\n    /** Size of the bytes. */\n    size?: number | undefined\n  }\n\n  type ErrorType =\n    | internal.assertSize.ErrorType\n    | trimLeft.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.toHex(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Options.\n * @returns Decoded {@link ox#Hex.Hex} value.\n */\nexport function toHex(value: Bytes, options: toHex.Options = {}): Hex.Hex {\n  return Hex.fromBytes(value, options)\n}\n\nexport declare namespace toHex {\n  type Options = {\n    /** Size of the bytes. */\n    size?: number | undefined\n  }\n\n  type ErrorType = Hex.fromBytes.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a number.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.toNumber(Bytes.from([1, 164]))\n * // @log: 420\n * ```\n */\nexport function toNumber(bytes: Bytes, options: toNumber.Options = {}): number {\n  const { size } = options\n  if (typeof size !== 'undefined') internal.assertSize(bytes, size)\n  const hex = Hex.fromBytes(bytes, options)\n  return Hex.toNumber(hex, options)\n}\n\nexport declare namespace toNumber {\n  type Options = {\n    /** Whether or not the number of a signed representation. */\n    signed?: boolean | undefined\n    /** Size of the bytes. */\n    size?: number | undefined\n  }\n\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | Hex.toNumber.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a string.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.toString(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: 'Hello world'\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Options.\n * @returns Decoded string.\n */\nexport function toString(bytes: Bytes, options: toString.Options = {}): string {\n  const { size } = options\n\n  let bytes_ = bytes\n  if (typeof size !== 'undefined') {\n    internal.assertSize(bytes_, size)\n    bytes_ = trimRight(bytes_)\n  }\n  return decoder.decode(bytes_)\n}\n\nexport declare namespace toString {\n  export type Options = {\n    /** Size of the bytes. */\n    size?: number | undefined\n  }\n\n  export type ErrorType =\n    | internal.assertSize.ErrorType\n    | trimRight.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Trims leading zeros from a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.trimLeft(Bytes.from([0, 0, 0, 0, 1, 2, 3]))\n * // @log: Uint8Array([1, 2, 3])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value.\n * @returns Trimmed {@link ox#Bytes.Bytes} value.\n */\nexport function trimLeft(value: Bytes): Bytes {\n  return internal.trim(value, { dir: 'left' })\n}\n\nexport declare namespace trimLeft {\n  type ErrorType = internal.trim.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Trims trailing zeros from a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.trimRight(Bytes.from([1, 2, 3, 0, 0, 0, 0]))\n * // @log: Uint8Array([1, 2, 3])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value.\n * @returns Trimmed {@link ox#Bytes.Bytes} value.\n */\nexport function trimRight(value: Bytes): Bytes {\n  return internal.trim(value, { dir: 'right' })\n}\n\nexport declare namespace trimRight {\n  export type ErrorType = internal.trim.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Checks if the given value is {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.validate('0x')\n * // @log: false\n *\n * Bytes.validate(Bytes.from([1, 2, 3]))\n * // @log: true\n * ```\n *\n * @param value - Value to check.\n * @returns `true` if the value is {@link ox#Bytes.Bytes}, otherwise `false`.\n */\nexport function validate(value: unknown): value is Bytes {\n  try {\n    assert(value)\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport declare namespace validate {\n  export type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Thrown when the bytes value cannot be represented as a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.toBoolean(Bytes.from([5]))\n * // @error: Bytes.InvalidBytesBooleanError: Bytes value `[5]` is not a valid boolean.\n * // @error: The bytes array must contain a single byte of either a `0` or `1` value.\n * ```\n */\nexport class InvalidBytesBooleanError extends Errors.BaseError {\n  override readonly name = 'Bytes.InvalidBytesBooleanError'\n\n  constructor(bytes: Bytes) {\n    super(`Bytes value \\`${bytes}\\` is not a valid boolean.`, {\n      metaMessages: [\n        'The bytes array must contain a single byte of either a `0` or `1` value.',\n      ],\n    })\n  }\n}\n\n/**\n * Thrown when a value cannot be converted to bytes.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Bytes } from 'ox'\n *\n * Bytes.from('foo')\n * // @error: Bytes.InvalidBytesTypeError: Value `foo` of type `string` is an invalid Bytes value.\n * ```\n */\nexport class InvalidBytesTypeError extends Errors.BaseError {\n  override readonly name = 'Bytes.InvalidBytesTypeError'\n\n  constructor(value: unknown) {\n    super(\n      `Value \\`${typeof value === 'object' ? Json.stringify(value) : value}\\` of type \\`${typeof value}\\` is an invalid Bytes value.`,\n      {\n        metaMessages: ['Bytes values must be of type `Bytes`.'],\n      },\n    )\n  }\n}\n\n/**\n * Thrown when a size exceeds the maximum allowed size.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.fromString('Hello World!', { size: 8 })\n * // @error: Bytes.SizeOverflowError: Size cannot exceed `8` bytes. Given size: `12` bytes.\n * ```\n */\nexport class SizeOverflowError extends Errors.BaseError {\n  override readonly name = 'Bytes.SizeOverflowError'\n\n  constructor({ givenSize, maxSize }: { givenSize: number; maxSize: number }) {\n    super(\n      `Size cannot exceed \\`${maxSize}\\` bytes. Given size: \\`${givenSize}\\` bytes.`,\n    )\n  }\n}\n\n/**\n * Thrown when a slice offset is out-of-bounds.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.slice(Bytes.from([1, 2, 3]), 4)\n * // @error: Bytes.SliceOffsetOutOfBoundsError: Slice starting at offset `4` is out-of-bounds (size: `3`).\n * ```\n */\nexport class SliceOffsetOutOfBoundsError extends Errors.BaseError {\n  override readonly name = 'Bytes.SliceOffsetOutOfBoundsError'\n\n  constructor({\n    offset,\n    position,\n    size,\n  }: { offset: number; position: 'start' | 'end'; size: number }) {\n    super(\n      `Slice ${\n        position === 'start' ? 'starting' : 'ending'\n      } at offset \\`${offset}\\` is out-of-bounds (size: \\`${size}\\`).`,\n    )\n  }\n}\n\n/**\n * Thrown when a the padding size exceeds the maximum allowed size.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.padLeft(Bytes.fromString('Hello World!'), 8)\n * // @error: [Bytes.SizeExceedsPaddingSizeError: Bytes size (`12`) exceeds padding size (`8`).\n * ```\n */\nexport class SizeExceedsPaddingSizeError extends Errors.BaseError {\n  override readonly name = 'Bytes.SizeExceedsPaddingSizeError'\n\n  constructor({\n    size,\n    targetSize,\n    type,\n  }: {\n    size: number\n    targetSize: number\n    type: 'Hex' | 'Bytes'\n  }) {\n    super(\n      `${type.charAt(0).toUpperCase()}${type\n        .slice(1)\n        .toLowerCase()} size (\\`${size}\\`) exceeds padding size (\\`${targetSize}\\`).`,\n    )\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}