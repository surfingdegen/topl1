{"ast":null,"code":"import { parseAccount } from '../../accounts/utils/parseAccount.js';\nimport { BaseError } from '../../errors/base.js';\nimport { AtomicityNotSupportedError, UnsupportedNonOptionalCapabilityError } from '../../errors/rpc.js';\nimport { encodeFunctionData } from '../../utils/abi/encodeFunctionData.js';\nimport { concat } from '../../utils/data/concat.js';\nimport { hexToBigInt } from '../../utils/encoding/fromHex.js';\nimport { numberToHex } from '../../utils/encoding/toHex.js';\nimport { getTransactionError } from '../../utils/errors/getTransactionError.js';\nimport { sendTransaction } from './sendTransaction.js';\nexport const fallbackMagicIdentifier = '0x5792579257925792579257925792579257925792579257925792579257925792';\nexport const fallbackTransactionErrorMagicIdentifier = numberToHex(0, {\n  size: 32\n});\n/**\n * Requests the connected wallet to send a batch of calls.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/sendCalls\n * - JSON-RPC Methods: [`wallet_sendCalls`](https://eips.ethereum.org/EIPS/eip-5792)\n *\n * @param client - Client to use\n * @returns Transaction identifier. {@link SendCallsReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { sendCalls } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const id = await sendCalls(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   calls: [\n *     {\n *       data: '0xdeadbeef',\n *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *     },\n *     {\n *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *       value: 69420n,\n *     },\n *   ],\n * })\n */\nexport async function sendCalls(client, parameters) {\n  const {\n    account: account_ = client.account,\n    capabilities,\n    chain = client.chain,\n    experimental_fallback,\n    experimental_fallbackDelay = 32,\n    forceAtomic = false,\n    id,\n    version = '2.0.0'\n  } = parameters;\n  const account = account_ ? parseAccount(account_) : null;\n  const calls = parameters.calls.map(call_ => {\n    const call = call_;\n    const data = call.abi ? encodeFunctionData({\n      abi: call.abi,\n      functionName: call.functionName,\n      args: call.args\n    }) : call.data;\n    return {\n      data: call.dataSuffix && data ? concat([data, call.dataSuffix]) : data,\n      to: call.to,\n      value: call.value ? numberToHex(call.value) : undefined\n    };\n  });\n  try {\n    const response = await client.request({\n      method: 'wallet_sendCalls',\n      params: [{\n        atomicRequired: forceAtomic,\n        calls,\n        capabilities,\n        chainId: numberToHex(chain.id),\n        from: account?.address,\n        id,\n        version\n      }]\n    }, {\n      retryCount: 0\n    });\n    if (typeof response === 'string') return {\n      id: response\n    };\n    return response;\n  } catch (err) {\n    const error = err;\n    // If the transport does not support EIP-5792, fall back to\n    // `eth_sendTransaction`.\n    if (experimental_fallback && (error.name === 'MethodNotFoundRpcError' || error.name === 'MethodNotSupportedRpcError' || error.name === 'UnknownRpcError' || error.details.toLowerCase().includes('does not exist / is not available') || error.details.toLowerCase().includes('missing or invalid. request()') || error.details.toLowerCase().includes('did not match any variant of untagged enum') || error.details.toLowerCase().includes('account upgraded to unsupported contract') || error.details.toLowerCase().includes('eip-7702 not supported') || error.details.toLowerCase().includes('unsupported wc_ method') ||\n    // magic.link\n    error.details.toLowerCase().includes('feature toggled misconfigured') ||\n    // Trust Wallet\n    error.details.toLowerCase().includes('jsonrpcengine: response has no error or result for request'))) {\n      if (capabilities) {\n        const hasNonOptionalCapability = Object.values(capabilities).some(capability => !capability.optional);\n        if (hasNonOptionalCapability) {\n          const message = 'non-optional `capabilities` are not supported on fallback to `eth_sendTransaction`.';\n          throw new UnsupportedNonOptionalCapabilityError(new BaseError(message, {\n            details: message\n          }));\n        }\n      }\n      if (forceAtomic && calls.length > 1) {\n        const message = '`forceAtomic` is not supported on fallback to `eth_sendTransaction`.';\n        throw new AtomicityNotSupportedError(new BaseError(message, {\n          details: message\n        }));\n      }\n      const promises = [];\n      for (const call of calls) {\n        const promise = sendTransaction(client, {\n          account,\n          chain,\n          data: call.data,\n          to: call.to,\n          value: call.value ? hexToBigInt(call.value) : undefined\n        });\n        promises.push(promise);\n        // Note: some browser wallets require a small delay between transactions\n        // to prevent duplicate JSON-RPC requests.\n        if (experimental_fallbackDelay > 0) await new Promise(resolve => setTimeout(resolve, experimental_fallbackDelay));\n      }\n      const results = await Promise.allSettled(promises);\n      if (results.every(r => r.status === 'rejected')) throw results[0].reason;\n      const hashes = results.map(result => {\n        if (result.status === 'fulfilled') return result.value;\n        return fallbackTransactionErrorMagicIdentifier;\n      });\n      return {\n        id: concat([...hashes, numberToHex(chain.id, {\n          size: 32\n        }), fallbackMagicIdentifier])\n      };\n    }\n    throw getTransactionError(err, {\n      ...parameters,\n      account,\n      chain: parameters.chain\n    });\n  }\n}","map":{"version":3,"names":["parseAccount","BaseError","AtomicityNotSupportedError","UnsupportedNonOptionalCapabilityError","encodeFunctionData","concat","hexToBigInt","numberToHex","getTransactionError","sendTransaction","fallbackMagicIdentifier","fallbackTransactionErrorMagicIdentifier","size","sendCalls","client","parameters","account","account_","capabilities","chain","experimental_fallback","experimental_fallbackDelay","forceAtomic","id","version","calls","map","call_","call","data","abi","functionName","args","dataSuffix","to","value","undefined","response","request","method","params","atomicRequired","chainId","from","address","retryCount","err","error","name","details","toLowerCase","includes","hasNonOptionalCapability","Object","values","some","capability","optional","message","length","promises","promise","push","Promise","resolve","setTimeout","results","allSettled","every","r","status","reason","hashes","result"],"sources":["/Users/mac/Desktop/topl1/frontend/node_modules/viem/actions/wallet/sendCalls.ts"],"sourcesContent":["import type { Address, Narrow } from 'abitype'\nimport { parseAccount } from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { BaseError } from '../../errors/base.js'\nimport {\n  AtomicityNotSupportedError,\n  UnsupportedNonOptionalCapabilityError,\n} from '../../errors/rpc.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account, GetAccountParameter } from '../../types/account.js'\nimport type { Call, Calls } from '../../types/calls.js'\nimport type { ExtractCapabilities } from '../../types/capabilities.js'\nimport type { Chain, DeriveChain } from '../../types/chain.js'\nimport type { WalletSendCallsParameters } from '../../types/eip1193.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { Prettify } from '../../types/utils.js'\nimport { encodeFunctionData } from '../../utils/abi/encodeFunctionData.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport { concat } from '../../utils/data/concat.js'\nimport { hexToBigInt } from '../../utils/encoding/fromHex.js'\nimport { numberToHex } from '../../utils/encoding/toHex.js'\nimport { getTransactionError } from '../../utils/errors/getTransactionError.js'\nimport { sendTransaction } from './sendTransaction.js'\n\nexport const fallbackMagicIdentifier =\n  '0x5792579257925792579257925792579257925792579257925792579257925792'\nexport const fallbackTransactionErrorMagicIdentifier = numberToHex(0, {\n  size: 32,\n})\n\nexport type SendCallsParameters<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  calls extends readonly unknown[] = readonly unknown[],\n  //\n  _chain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = {\n  chain?: chainOverride | Chain | undefined\n  calls: Calls<Narrow<calls>>\n  capabilities?: ExtractCapabilities<'sendCalls', 'Request'> | undefined\n  experimental_fallback?: boolean | undefined\n  experimental_fallbackDelay?: number | undefined\n  forceAtomic?: boolean | undefined\n  id?: string | undefined\n  version?: WalletSendCallsParameters[number]['version'] | undefined\n} & GetAccountParameter<account, Account | Address, false, true>\n\nexport type SendCallsReturnType = Prettify<{\n  capabilities?: ExtractCapabilities<'sendCalls', 'ReturnType'> | undefined\n  id: string\n}>\n\nexport type SendCallsErrorType = RequestErrorType | ErrorType\n\n/**\n * Requests the connected wallet to send a batch of calls.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/sendCalls\n * - JSON-RPC Methods: [`wallet_sendCalls`](https://eips.ethereum.org/EIPS/eip-5792)\n *\n * @param client - Client to use\n * @returns Transaction identifier. {@link SendCallsReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { sendCalls } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const id = await sendCalls(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   calls: [\n *     {\n *       data: '0xdeadbeef',\n *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *     },\n *     {\n *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *       value: 69420n,\n *     },\n *   ],\n * })\n */\nexport async function sendCalls<\n  const calls extends readonly unknown[],\n  chain extends Chain | undefined,\n  account extends Account | undefined = undefined,\n  chainOverride extends Chain | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: SendCallsParameters<chain, account, chainOverride, calls>,\n): Promise<SendCallsReturnType> {\n  const {\n    account: account_ = client.account,\n    capabilities,\n    chain = client.chain,\n    experimental_fallback,\n    experimental_fallbackDelay = 32,\n    forceAtomic = false,\n    id,\n    version = '2.0.0',\n  } = parameters\n\n  const account = account_ ? parseAccount(account_) : null\n\n  const calls = parameters.calls.map((call_: unknown) => {\n    const call = call_ as Call\n\n    const data = call.abi\n      ? encodeFunctionData({\n          abi: call.abi,\n          functionName: call.functionName,\n          args: call.args,\n        })\n      : call.data\n\n    return {\n      data: call.dataSuffix && data ? concat([data, call.dataSuffix]) : data,\n      to: call.to,\n      value: call.value ? numberToHex(call.value) : undefined,\n    }\n  })\n\n  try {\n    const response = await client.request(\n      {\n        method: 'wallet_sendCalls',\n        params: [\n          {\n            atomicRequired: forceAtomic,\n            calls,\n            capabilities,\n            chainId: numberToHex(chain!.id),\n            from: account?.address,\n            id,\n            version,\n          },\n        ],\n      },\n      { retryCount: 0 },\n    )\n    if (typeof response === 'string') return { id: response }\n    return response as never\n  } catch (err) {\n    const error = err as BaseError\n\n    // If the transport does not support EIP-5792, fall back to\n    // `eth_sendTransaction`.\n    if (\n      experimental_fallback &&\n      (error.name === 'MethodNotFoundRpcError' ||\n        error.name === 'MethodNotSupportedRpcError' ||\n        error.name === 'UnknownRpcError' ||\n        error.details\n          .toLowerCase()\n          .includes('does not exist / is not available') ||\n        error.details.toLowerCase().includes('missing or invalid. request()') ||\n        error.details\n          .toLowerCase()\n          .includes('did not match any variant of untagged enum') ||\n        error.details\n          .toLowerCase()\n          .includes('account upgraded to unsupported contract') ||\n        error.details.toLowerCase().includes('eip-7702 not supported') ||\n        error.details.toLowerCase().includes('unsupported wc_ method') ||\n        // magic.link\n        error.details\n          .toLowerCase()\n          .includes('feature toggled misconfigured') ||\n        // Trust Wallet\n        error.details\n          .toLowerCase()\n          .includes(\n            'jsonrpcengine: response has no error or result for request',\n          ))\n    ) {\n      if (capabilities) {\n        const hasNonOptionalCapability = Object.values(capabilities).some(\n          (capability) => !capability.optional,\n        )\n        if (hasNonOptionalCapability) {\n          const message =\n            'non-optional `capabilities` are not supported on fallback to `eth_sendTransaction`.'\n          throw new UnsupportedNonOptionalCapabilityError(\n            new BaseError(message, {\n              details: message,\n            }),\n          )\n        }\n      }\n      if (forceAtomic && calls.length > 1) {\n        const message =\n          '`forceAtomic` is not supported on fallback to `eth_sendTransaction`.'\n        throw new AtomicityNotSupportedError(\n          new BaseError(message, {\n            details: message,\n          }),\n        )\n      }\n\n      const promises: Promise<Hex>[] = []\n      for (const call of calls) {\n        const promise = sendTransaction(client, {\n          account,\n          chain,\n          data: call.data,\n          to: call.to,\n          value: call.value ? hexToBigInt(call.value) : undefined,\n        })\n        promises.push(promise)\n\n        // Note: some browser wallets require a small delay between transactions\n        // to prevent duplicate JSON-RPC requests.\n        if (experimental_fallbackDelay > 0)\n          await new Promise((resolve) =>\n            setTimeout(resolve, experimental_fallbackDelay),\n          )\n      }\n\n      const results = await Promise.allSettled(promises)\n      if (results.every((r) => r.status === 'rejected')) throw results[0].reason\n\n      const hashes = results.map((result) => {\n        if (result.status === 'fulfilled') return result.value\n        return fallbackTransactionErrorMagicIdentifier\n      })\n      return {\n        id: concat([\n          ...hashes,\n          numberToHex(chain!.id, { size: 32 }),\n          fallbackMagicIdentifier,\n        ]),\n      }\n    }\n\n    throw getTransactionError(err as BaseError, {\n      ...parameters,\n      account,\n      chain: parameters.chain!,\n    })\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}