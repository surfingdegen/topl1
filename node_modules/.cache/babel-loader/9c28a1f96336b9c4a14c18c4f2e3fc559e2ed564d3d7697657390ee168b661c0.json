{"ast":null,"code":"/** @internal */\nexport const listenersCache = /*#__PURE__*/new Map();\n/** @internal */\nexport const cleanupCache = /*#__PURE__*/new Map();\nlet callbackCount = 0;\n/**\n * @description Sets up an observer for a given function. If another function\n * is set up under the same observer id, the function will only be called once\n * for both instances of the observer.\n */\nexport function observe(observerId, callbacks, fn) {\n  const callbackId = ++callbackCount;\n  const getListeners = () => listenersCache.get(observerId) || [];\n  const unsubscribe = () => {\n    const listeners = getListeners();\n    listenersCache.set(observerId, listeners.filter(cb => cb.id !== callbackId));\n  };\n  const unwatch = () => {\n    const listeners = getListeners();\n    if (!listeners.some(cb => cb.id === callbackId)) return;\n    const cleanup = cleanupCache.get(observerId);\n    if (listeners.length === 1 && cleanup) {\n      const p = cleanup();\n      if (p instanceof Promise) p.catch(() => {});\n    }\n    unsubscribe();\n  };\n  const listeners = getListeners();\n  listenersCache.set(observerId, [...listeners, {\n    id: callbackId,\n    fns: callbacks\n  }]);\n  if (listeners && listeners.length > 0) return unwatch;\n  const emit = {};\n  for (const key in callbacks) {\n    emit[key] = function () {\n      const listeners = getListeners();\n      if (listeners.length === 0) return;\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      for (const listener of listeners) {\n        var _listener$fns$key, _listener$fns;\n        (_listener$fns$key = (_listener$fns = listener.fns)[key]) === null || _listener$fns$key === void 0 || _listener$fns$key.call(_listener$fns, ...args);\n      }\n    };\n  }\n  const cleanup = fn(emit);\n  if (typeof cleanup === 'function') cleanupCache.set(observerId, cleanup);\n  return unwatch;\n}","map":{"version":3,"names":["listenersCache","Map","cleanupCache","callbackCount","observe","observerId","callbacks","fn","callbackId","getListeners","get","unsubscribe","listeners","set","filter","cb","id","unwatch","some","cleanup","length","p","Promise","catch","fns","emit","key","_len","arguments","args","Array","_key","listener","_listener$fns$key","_listener$fns","call"],"sources":["/Users/mac/Desktop/topl1/frontend/node_modules/viem/utils/observe.ts"],"sourcesContent":["import type { ErrorType } from '../errors/utils.js'\nimport type { MaybePromise } from '../types/utils.js'\n\ntype Callback = ((...args: any[]) => any) | undefined\ntype Callbacks = Record<string, Callback>\n\nexport type ObserveErrorType = ErrorType\n\n/** @internal */\nexport const listenersCache = /*#__PURE__*/ new Map<\n  string,\n  { id: number; fns: Callbacks }[]\n>()\n/** @internal */\nexport const cleanupCache = /*#__PURE__*/ new Map<\n  string,\n  () => void | Promise<void>\n>()\n\ntype EmitFunction<callbacks extends Callbacks> = (\n  emit: callbacks,\n) => MaybePromise<void | (() => void) | (() => Promise<void>)>\n\nlet callbackCount = 0\n\n/**\n * @description Sets up an observer for a given function. If another function\n * is set up under the same observer id, the function will only be called once\n * for both instances of the observer.\n */\nexport function observe<callbacks extends Callbacks>(\n  observerId: string,\n  callbacks: callbacks,\n  fn: EmitFunction<callbacks>,\n) {\n  const callbackId = ++callbackCount\n\n  const getListeners = () => listenersCache.get(observerId) || []\n\n  const unsubscribe = () => {\n    const listeners = getListeners()\n    listenersCache.set(\n      observerId,\n      listeners.filter((cb: any) => cb.id !== callbackId),\n    )\n  }\n\n  const unwatch = () => {\n    const listeners = getListeners()\n    if (!listeners.some((cb: any) => cb.id === callbackId)) return\n    const cleanup = cleanupCache.get(observerId)\n    if (listeners.length === 1 && cleanup) {\n      const p = cleanup()\n      if (p instanceof Promise) p.catch(() => {})\n    }\n    unsubscribe()\n  }\n\n  const listeners = getListeners()\n  listenersCache.set(observerId, [\n    ...listeners,\n    { id: callbackId, fns: callbacks },\n  ])\n\n  if (listeners && listeners.length > 0) return unwatch\n\n  const emit: callbacks = {} as callbacks\n  for (const key in callbacks) {\n    emit[key] = ((\n      ...args: Parameters<NonNullable<callbacks[keyof callbacks]>>\n    ) => {\n      const listeners = getListeners()\n      if (listeners.length === 0) return\n      for (const listener of listeners) listener.fns[key]?.(...args)\n    }) as callbacks[Extract<keyof callbacks, string>]\n  }\n\n  const cleanup = fn(emit)\n  if (typeof cleanup === 'function') cleanupCache.set(observerId, cleanup)\n\n  return unwatch\n}\n"],"mappings":"AAQA;AACA,OAAO,MAAMA,cAAc,GAAG,aAAc,IAAIC,GAAG,EAGhD;AACH;AACA,OAAO,MAAMC,YAAY,GAAG,aAAc,IAAID,GAAG,EAG9C;AAMH,IAAIE,aAAa,GAAG,CAAC;AAErB;;;;;AAKA,OAAM,SAAUC,OAAOA,CACrBC,UAAkB,EAClBC,SAAoB,EACpBC,EAA2B;EAE3B,MAAMC,UAAU,GAAG,EAAEL,aAAa;EAElC,MAAMM,YAAY,GAAGA,CAAA,KAAMT,cAAc,CAACU,GAAG,CAACL,UAAU,CAAC,IAAI,EAAE;EAE/D,MAAMM,WAAW,GAAGA,CAAA,KAAK;IACvB,MAAMC,SAAS,GAAGH,YAAY,EAAE;IAChCT,cAAc,CAACa,GAAG,CAChBR,UAAU,EACVO,SAAS,CAACE,MAAM,CAAEC,EAAO,IAAKA,EAAE,CAACC,EAAE,KAAKR,UAAU,CAAC,CACpD;EACH,CAAC;EAED,MAAMS,OAAO,GAAGA,CAAA,KAAK;IACnB,MAAML,SAAS,GAAGH,YAAY,EAAE;IAChC,IAAI,CAACG,SAAS,CAACM,IAAI,CAAEH,EAAO,IAAKA,EAAE,CAACC,EAAE,KAAKR,UAAU,CAAC,EAAE;IACxD,MAAMW,OAAO,GAAGjB,YAAY,CAACQ,GAAG,CAACL,UAAU,CAAC;IAC5C,IAAIO,SAAS,CAACQ,MAAM,KAAK,CAAC,IAAID,OAAO,EAAE;MACrC,MAAME,CAAC,GAAGF,OAAO,EAAE;MACnB,IAAIE,CAAC,YAAYC,OAAO,EAAED,CAAC,CAACE,KAAK,CAAC,MAAK,CAAE,CAAC,CAAC;IAC7C;IACAZ,WAAW,EAAE;EACf,CAAC;EAED,MAAMC,SAAS,GAAGH,YAAY,EAAE;EAChCT,cAAc,CAACa,GAAG,CAACR,UAAU,EAAE,CAC7B,GAAGO,SAAS,EACZ;IAAEI,EAAE,EAAER,UAAU;IAAEgB,GAAG,EAAElB;EAAS,CAAE,CACnC,CAAC;EAEF,IAAIM,SAAS,IAAIA,SAAS,CAACQ,MAAM,GAAG,CAAC,EAAE,OAAOH,OAAO;EAErD,MAAMQ,IAAI,GAAc,EAAe;EACvC,KAAK,MAAMC,GAAG,IAAIpB,SAAS,EAAE;IAC3BmB,IAAI,CAACC,GAAG,CAAC,GAAI,YAET;MACF,MAAMd,SAAS,GAAGH,YAAY,EAAE;MAChC,IAAIG,SAAS,CAACQ,MAAM,KAAK,CAAC,EAAE;MAAM,SAAAO,IAAA,GAAAC,SAAA,CAAAR,MAAA,EAH/BS,IAAyD,OAAAC,KAAA,CAAAH,IAAA,GAAAI,IAAA,MAAAA,IAAA,GAAAJ,IAAA,EAAAI,IAAA;QAAzDF,IAAyD,CAAAE,IAAA,IAAAH,SAAA,CAAAG,IAAA;MAAA;MAI5D,KAAK,MAAMC,QAAQ,IAAIpB,SAAS;QAAA,IAAAqB,iBAAA,EAAAC,aAAA;QAAE,CAAAD,iBAAA,IAAAC,aAAA,GAAAF,QAAQ,CAACR,GAAG,EAACE,GAAG,CAAC,cAAAO,iBAAA,eAAjBA,iBAAA,CAAAE,IAAA,CAAAD,aAAA,EAAoB,GAAGL,IAAI,CAAC;MAAA;IAChE,CAAiD;EACnD;EAEA,MAAMV,OAAO,GAAGZ,EAAE,CAACkB,IAAI,CAAC;EACxB,IAAI,OAAON,OAAO,KAAK,UAAU,EAAEjB,YAAY,CAACW,GAAG,CAACR,UAAU,EAAEc,OAAO,CAAC;EAExE,OAAOF,OAAO;AAChB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}