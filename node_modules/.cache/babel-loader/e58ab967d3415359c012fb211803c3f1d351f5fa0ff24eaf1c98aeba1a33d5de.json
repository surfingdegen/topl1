{"ast":null,"code":"import { BaseError } from '../../errors/base.js';\nimport { BundleFailedError } from '../../errors/calls.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { observe } from '../../utils/observe.js';\nimport { poll } from '../../utils/poll.js';\nimport { withResolvers } from '../../utils/promise/withResolvers.js';\nimport { withRetry } from '../../utils/promise/withRetry.js';\nimport { stringify } from '../../utils/stringify.js';\nimport { getCallsStatus } from './getCallsStatus.js';\n/**\n * Waits for the status & receipts of a call bundle that was sent via `sendCalls`.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/waitForCallsStatus\n * - JSON-RPC Methods: [`wallet_getCallsStatus`](https://eips.ethereum.org/EIPS/eip-5792)\n *\n * @param client - Client to use\n * @param parameters - {@link WaitForCallsStatusParameters}\n * @returns Status & receipts of the call bundle. {@link WaitForCallsStatusReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { waitForCallsStatus } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n *\n * const { receipts, status } = await waitForCallsStatus(client, { id: '0xdeadbeef' })\n */\nexport async function waitForCallsStatus(client, parameters) {\n  const {\n    id,\n    pollingInterval = client.pollingInterval,\n    status = ({\n      statusCode\n    }) => statusCode === 200 || statusCode >= 300,\n    retryCount = 4,\n    retryDelay = ({\n      count\n    }) => ~~(1 << count) * 200,\n    // exponential backoff\n    timeout = 60_000,\n    throwOnFailure = false\n  } = parameters;\n  const observerId = stringify(['waitForCallsStatus', client.uid, id]);\n  const {\n    promise,\n    resolve,\n    reject\n  } = withResolvers();\n  let timer;\n  const unobserve = observe(observerId, {\n    resolve,\n    reject\n  }, emit => {\n    const unpoll = poll(async () => {\n      const done = fn => {\n        clearTimeout(timer);\n        unpoll();\n        fn();\n        unobserve();\n      };\n      try {\n        const result = await withRetry(async () => {\n          const result = await getAction(client, getCallsStatus, 'getCallsStatus')({\n            id\n          });\n          if (throwOnFailure && result.status === 'failure') throw new BundleFailedError(result);\n          return result;\n        }, {\n          retryCount,\n          delay: retryDelay\n        });\n        if (!status(result)) return;\n        done(() => emit.resolve(result));\n      } catch (error) {\n        done(() => emit.reject(error));\n      }\n    }, {\n      interval: pollingInterval,\n      emitOnBegin: true\n    });\n    return unpoll;\n  });\n  timer = timeout ? setTimeout(() => {\n    unobserve();\n    clearTimeout(timer);\n    reject(new WaitForCallsStatusTimeoutError({\n      id\n    }));\n  }, timeout) : undefined;\n  return await promise;\n}\nexport class WaitForCallsStatusTimeoutError extends BaseError {\n  constructor({\n    id\n  }) {\n    super(`Timed out while waiting for call bundle with id \"${id}\" to be confirmed.`, {\n      name: 'WaitForCallsStatusTimeoutError'\n    });\n  }\n}","map":{"version":3,"names":["BaseError","BundleFailedError","getAction","observe","poll","withResolvers","withRetry","stringify","getCallsStatus","waitForCallsStatus","client","parameters","id","pollingInterval","status","statusCode","retryCount","retryDelay","count","timeout","throwOnFailure","observerId","uid","promise","resolve","reject","timer","unobserve","emit","unpoll","done","fn","clearTimeout","result","delay","error","interval","emitOnBegin","setTimeout","WaitForCallsStatusTimeoutError","undefined","constructor","name"],"sources":["/Users/mac/Desktop/topl1/frontend/node_modules/viem/actions/wallet/waitForCallsStatus.ts"],"sourcesContent":["import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { BaseError } from '../../errors/base.js'\nimport { BundleFailedError } from '../../errors/calls.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport { getAction } from '../../utils/getAction.js'\nimport { type ObserveErrorType, observe } from '../../utils/observe.js'\nimport { type PollErrorType, poll } from '../../utils/poll.js'\nimport { withResolvers } from '../../utils/promise/withResolvers.js'\nimport {\n  type WithRetryParameters,\n  withRetry,\n} from '../../utils/promise/withRetry.js'\nimport { stringify } from '../../utils/stringify.js'\nimport {\n  type GetCallsStatusErrorType,\n  type GetCallsStatusReturnType,\n  getCallsStatus,\n} from './getCallsStatus.js'\n\nexport type WaitForCallsStatusParameters = {\n  /**\n   * The id of the call batch to wait for.\n   */\n  id: string\n  /**\n   * Polling frequency (in ms). Defaults to the client's pollingInterval config.\n   *\n   * @default client.pollingInterval\n   */\n  pollingInterval?: number | undefined\n  /**\n   * Number of times to retry if the call bundle failed.\n   * @default 4 (exponential backoff)\n   */\n  retryCount?: WithRetryParameters['retryCount'] | undefined\n  /**\n   * Time to wait (in ms) between retries.\n   * @default `({ count }) => ~~(1 << count) * 200` (exponential backoff)\n   */\n  retryDelay?: WithRetryParameters['delay'] | undefined\n  /**\n   * The status range to wait for.\n   *\n   * @default (status) => status >= 200\n   */\n  status?: ((parameters: GetCallsStatusReturnType) => boolean) | undefined\n  /**\n   * Whether to throw an error if the call bundle fails.\n   *\n   * @default false\n   */\n  throwOnFailure?: boolean | undefined\n  /**\n   * Optional timeout (in milliseconds) to wait before stopping polling.\n   *\n   * @default 60_000\n   */\n  timeout?: number | undefined\n}\n\nexport type WaitForCallsStatusReturnType = GetCallsStatusReturnType\n\nexport type WaitForCallsStatusErrorType =\n  | ObserveErrorType\n  | PollErrorType\n  | GetCallsStatusErrorType\n  | WaitForCallsStatusTimeoutError\n  | ErrorType\n\n/**\n * Waits for the status & receipts of a call bundle that was sent via `sendCalls`.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/waitForCallsStatus\n * - JSON-RPC Methods: [`wallet_getCallsStatus`](https://eips.ethereum.org/EIPS/eip-5792)\n *\n * @param client - Client to use\n * @param parameters - {@link WaitForCallsStatusParameters}\n * @returns Status & receipts of the call bundle. {@link WaitForCallsStatusReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { waitForCallsStatus } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n *\n * const { receipts, status } = await waitForCallsStatus(client, { id: '0xdeadbeef' })\n */\nexport async function waitForCallsStatus<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: WaitForCallsStatusParameters,\n): Promise<WaitForCallsStatusReturnType> {\n  const {\n    id,\n    pollingInterval = client.pollingInterval,\n    status = ({ statusCode }) => statusCode === 200 || statusCode >= 300,\n    retryCount = 4,\n    retryDelay = ({ count }) => ~~(1 << count) * 200, // exponential backoff\n    timeout = 60_000,\n    throwOnFailure = false,\n  } = parameters\n  const observerId = stringify(['waitForCallsStatus', client.uid, id])\n\n  const { promise, resolve, reject } =\n    withResolvers<WaitForCallsStatusReturnType>()\n\n  let timer: Timer | undefined\n\n  const unobserve = observe(observerId, { resolve, reject }, (emit) => {\n    const unpoll = poll(\n      async () => {\n        const done = (fn: () => void) => {\n          clearTimeout(timer)\n          unpoll()\n          fn()\n          unobserve()\n        }\n\n        try {\n          const result = await withRetry(\n            async () => {\n              const result = await getAction(\n                client,\n                getCallsStatus,\n                'getCallsStatus',\n              )({ id })\n              if (throwOnFailure && result.status === 'failure')\n                throw new BundleFailedError(result)\n              return result\n            },\n            {\n              retryCount,\n              delay: retryDelay,\n            },\n          )\n          if (!status(result)) return\n          done(() => emit.resolve(result))\n        } catch (error) {\n          done(() => emit.reject(error))\n        }\n      },\n      {\n        interval: pollingInterval,\n        emitOnBegin: true,\n      },\n    )\n\n    return unpoll\n  })\n\n  timer = timeout\n    ? setTimeout(() => {\n        unobserve()\n        clearTimeout(timer)\n        reject(new WaitForCallsStatusTimeoutError({ id }))\n      }, timeout)\n    : undefined\n\n  return await promise\n}\n\nexport type WaitForCallsStatusTimeoutErrorType =\n  WaitForCallsStatusTimeoutError & {\n    name: 'WaitForCallsStatusTimeoutError'\n  }\nexport class WaitForCallsStatusTimeoutError extends BaseError {\n  constructor({ id }: { id: string }) {\n    super(\n      `Timed out while waiting for call bundle with id \"${id}\" to be confirmed.`,\n      { name: 'WaitForCallsStatusTimeoutError' },\n    )\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}