{"ast":null,"code":"import { BaseError } from '../../errors/base.js';\nimport { BundleFailedError } from '../../errors/calls.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { observe } from '../../utils/observe.js';\nimport { poll } from '../../utils/poll.js';\nimport { withResolvers } from '../../utils/promise/withResolvers.js';\nimport { withRetry } from '../../utils/promise/withRetry.js';\nimport { stringify } from '../../utils/stringify.js';\nimport { getCallsStatus } from './getCallsStatus.js';\n/**\n * Waits for the status & receipts of a call bundle that was sent via `sendCalls`.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/waitForCallsStatus\n * - JSON-RPC Methods: [`wallet_getCallsStatus`](https://eips.ethereum.org/EIPS/eip-5792)\n *\n * @param client - Client to use\n * @param parameters - {@link WaitForCallsStatusParameters}\n * @returns Status & receipts of the call bundle. {@link WaitForCallsStatusReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { waitForCallsStatus } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n *\n * const { receipts, status } = await waitForCallsStatus(client, { id: '0xdeadbeef' })\n */\nexport async function waitForCallsStatus(client, parameters) {\n  const {\n    id,\n    pollingInterval = client.pollingInterval,\n    status = _ref => {\n      let {\n        statusCode\n      } = _ref;\n      return statusCode === 200 || statusCode >= 300;\n    },\n    retryCount = 4,\n    retryDelay = _ref2 => {\n      let {\n        count\n      } = _ref2;\n      return ~~(1 << count) * 200;\n    },\n    // exponential backoff\n    timeout = 60000,\n    throwOnFailure = false\n  } = parameters;\n  const observerId = stringify(['waitForCallsStatus', client.uid, id]);\n  const {\n    promise,\n    resolve,\n    reject\n  } = withResolvers();\n  let timer;\n  const unobserve = observe(observerId, {\n    resolve,\n    reject\n  }, emit => {\n    const unpoll = poll(async () => {\n      const done = fn => {\n        clearTimeout(timer);\n        unpoll();\n        fn();\n        unobserve();\n      };\n      try {\n        const result = await withRetry(async () => {\n          const result = await getAction(client, getCallsStatus, 'getCallsStatus')({\n            id\n          });\n          if (throwOnFailure && result.status === 'failure') throw new BundleFailedError(result);\n          return result;\n        }, {\n          retryCount,\n          delay: retryDelay\n        });\n        if (!status(result)) return;\n        done(() => emit.resolve(result));\n      } catch (error) {\n        done(() => emit.reject(error));\n      }\n    }, {\n      interval: pollingInterval,\n      emitOnBegin: true\n    });\n    return unpoll;\n  });\n  timer = timeout ? setTimeout(() => {\n    unobserve();\n    clearTimeout(timer);\n    reject(new WaitForCallsStatusTimeoutError({\n      id\n    }));\n  }, timeout) : undefined;\n  return await promise;\n}\nexport class WaitForCallsStatusTimeoutError extends BaseError {\n  constructor(_ref3) {\n    let {\n      id\n    } = _ref3;\n    super(\"Timed out while waiting for call bundle with id \\\"\".concat(id, \"\\\" to be confirmed.\"), {\n      name: 'WaitForCallsStatusTimeoutError'\n    });\n  }\n}","map":{"version":3,"names":["BaseError","BundleFailedError","getAction","observe","poll","withResolvers","withRetry","stringify","getCallsStatus","waitForCallsStatus","client","parameters","id","pollingInterval","status","_ref","statusCode","retryCount","retryDelay","_ref2","count","timeout","throwOnFailure","observerId","uid","promise","resolve","reject","timer","unobserve","emit","unpoll","done","fn","clearTimeout","result","delay","error","interval","emitOnBegin","setTimeout","WaitForCallsStatusTimeoutError","undefined","constructor","_ref3","concat","name"],"sources":["/Users/mac/Desktop/topl1/frontend/node_modules/viem/actions/wallet/waitForCallsStatus.ts"],"sourcesContent":["import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { BaseError } from '../../errors/base.js'\nimport { BundleFailedError } from '../../errors/calls.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport { getAction } from '../../utils/getAction.js'\nimport { type ObserveErrorType, observe } from '../../utils/observe.js'\nimport { type PollErrorType, poll } from '../../utils/poll.js'\nimport { withResolvers } from '../../utils/promise/withResolvers.js'\nimport {\n  type WithRetryParameters,\n  withRetry,\n} from '../../utils/promise/withRetry.js'\nimport { stringify } from '../../utils/stringify.js'\nimport {\n  type GetCallsStatusErrorType,\n  type GetCallsStatusReturnType,\n  getCallsStatus,\n} from './getCallsStatus.js'\n\nexport type WaitForCallsStatusParameters = {\n  /**\n   * The id of the call batch to wait for.\n   */\n  id: string\n  /**\n   * Polling frequency (in ms). Defaults to the client's pollingInterval config.\n   *\n   * @default client.pollingInterval\n   */\n  pollingInterval?: number | undefined\n  /**\n   * Number of times to retry if the call bundle failed.\n   * @default 4 (exponential backoff)\n   */\n  retryCount?: WithRetryParameters['retryCount'] | undefined\n  /**\n   * Time to wait (in ms) between retries.\n   * @default `({ count }) => ~~(1 << count) * 200` (exponential backoff)\n   */\n  retryDelay?: WithRetryParameters['delay'] | undefined\n  /**\n   * The status range to wait for.\n   *\n   * @default (status) => status >= 200\n   */\n  status?: ((parameters: GetCallsStatusReturnType) => boolean) | undefined\n  /**\n   * Whether to throw an error if the call bundle fails.\n   *\n   * @default false\n   */\n  throwOnFailure?: boolean | undefined\n  /**\n   * Optional timeout (in milliseconds) to wait before stopping polling.\n   *\n   * @default 60_000\n   */\n  timeout?: number | undefined\n}\n\nexport type WaitForCallsStatusReturnType = GetCallsStatusReturnType\n\nexport type WaitForCallsStatusErrorType =\n  | ObserveErrorType\n  | PollErrorType\n  | GetCallsStatusErrorType\n  | WaitForCallsStatusTimeoutError\n  | ErrorType\n\n/**\n * Waits for the status & receipts of a call bundle that was sent via `sendCalls`.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/waitForCallsStatus\n * - JSON-RPC Methods: [`wallet_getCallsStatus`](https://eips.ethereum.org/EIPS/eip-5792)\n *\n * @param client - Client to use\n * @param parameters - {@link WaitForCallsStatusParameters}\n * @returns Status & receipts of the call bundle. {@link WaitForCallsStatusReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { waitForCallsStatus } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n *\n * const { receipts, status } = await waitForCallsStatus(client, { id: '0xdeadbeef' })\n */\nexport async function waitForCallsStatus<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: WaitForCallsStatusParameters,\n): Promise<WaitForCallsStatusReturnType> {\n  const {\n    id,\n    pollingInterval = client.pollingInterval,\n    status = ({ statusCode }) => statusCode === 200 || statusCode >= 300,\n    retryCount = 4,\n    retryDelay = ({ count }) => ~~(1 << count) * 200, // exponential backoff\n    timeout = 60_000,\n    throwOnFailure = false,\n  } = parameters\n  const observerId = stringify(['waitForCallsStatus', client.uid, id])\n\n  const { promise, resolve, reject } =\n    withResolvers<WaitForCallsStatusReturnType>()\n\n  let timer: Timer | undefined\n\n  const unobserve = observe(observerId, { resolve, reject }, (emit) => {\n    const unpoll = poll(\n      async () => {\n        const done = (fn: () => void) => {\n          clearTimeout(timer)\n          unpoll()\n          fn()\n          unobserve()\n        }\n\n        try {\n          const result = await withRetry(\n            async () => {\n              const result = await getAction(\n                client,\n                getCallsStatus,\n                'getCallsStatus',\n              )({ id })\n              if (throwOnFailure && result.status === 'failure')\n                throw new BundleFailedError(result)\n              return result\n            },\n            {\n              retryCount,\n              delay: retryDelay,\n            },\n          )\n          if (!status(result)) return\n          done(() => emit.resolve(result))\n        } catch (error) {\n          done(() => emit.reject(error))\n        }\n      },\n      {\n        interval: pollingInterval,\n        emitOnBegin: true,\n      },\n    )\n\n    return unpoll\n  })\n\n  timer = timeout\n    ? setTimeout(() => {\n        unobserve()\n        clearTimeout(timer)\n        reject(new WaitForCallsStatusTimeoutError({ id }))\n      }, timeout)\n    : undefined\n\n  return await promise\n}\n\nexport type WaitForCallsStatusTimeoutErrorType =\n  WaitForCallsStatusTimeoutError & {\n    name: 'WaitForCallsStatusTimeoutError'\n  }\nexport class WaitForCallsStatusTimeoutError extends BaseError {\n  constructor({ id }: { id: string }) {\n    super(\n      `Timed out while waiting for call bundle with id \"${id}\" to be confirmed.`,\n      { name: 'WaitForCallsStatusTimeoutError' },\n    )\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}