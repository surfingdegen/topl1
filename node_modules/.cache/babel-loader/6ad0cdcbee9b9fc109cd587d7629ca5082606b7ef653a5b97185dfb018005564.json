{"ast":null,"code":"import { equalBytes } from '@noble/curves/abstract/utils';\nimport * as Bytes from './Bytes.js';\nimport * as Errors from './Errors.js';\nimport * as internal_bytes from './internal/bytes.js';\nimport * as internal from './internal/hex.js';\nimport * as Json from './Json.js';\nconst encoder = /*#__PURE__*/new TextEncoder();\nconst hexes = /*#__PURE__*/Array.from({\n  length: 256\n}, (_v, i) => i.toString(16).padStart(2, '0'));\n/**\n * Asserts if the given value is {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert('abc')\n * // @error: InvalidHexValueTypeError:\n * // @error: Value `\"abc\"` of type `string` is an invalid hex type.\n * // @error: Hex types must be represented as `\"0x\\${string}\"`.\n * ```\n *\n * @param value - The value to assert.\n * @param options - Options.\n */\nexport function assert(value) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    strict = false\n  } = options;\n  if (!value) throw new InvalidHexTypeError(value);\n  if (typeof value !== 'string') throw new InvalidHexTypeError(value);\n  if (strict) {\n    if (!/^0x[0-9a-fA-F]*$/.test(value)) throw new InvalidHexValueError(value);\n  }\n  if (!value.startsWith('0x')) throw new InvalidHexValueError(value);\n}\n/**\n * Concatenates two or more {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.concat('0x123', '0x456')\n * // @log: '0x123456'\n * ```\n *\n * @param values - The {@link ox#Hex.Hex} values to concatenate.\n * @returns The concatenated {@link ox#Hex.Hex} value.\n */\nexport function concat() {\n  for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n    values[_key] = arguments[_key];\n  }\n  return \"0x\".concat(values.reduce((acc, x) => acc + x.replace('0x', ''), ''));\n}\n/**\n * Instantiates a {@link ox#Hex.Hex} value from a hex string or {@link ox#Bytes.Bytes} value.\n *\n * :::tip\n *\n * To instantiate from a **Boolean**, **String**, or **Number**, use one of the following:\n *\n * - `Hex.fromBoolean`\n *\n * - `Hex.fromString`\n *\n * - `Hex.fromNumber`\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.from('0x48656c6c6f20576f726c6421')\n * // @log: '0x48656c6c6f20576f726c6421'\n *\n * Hex.from(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value to encode.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function from(value) {\n  if (value instanceof Uint8Array) return fromBytes(value);\n  if (Array.isArray(value)) return fromBytes(new Uint8Array(value));\n  return value;\n}\n/**\n * Encodes a boolean into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromBoolean(true)\n * // @log: '0x1'\n *\n * Hex.fromBoolean(false)\n * // @log: '0x0'\n *\n * Hex.fromBoolean(true, { size: 32 })\n * // @log: '0x0000000000000000000000000000000000000000000000000000000000000001'\n * ```\n *\n * @param value - The boolean value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function fromBoolean(value) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const hex = \"0x\".concat(Number(value));\n  if (typeof options.size === 'number') {\n    internal.assertSize(hex, options.size);\n    return padLeft(hex, options.size);\n  }\n  return hex;\n}\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.fromBytes(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function fromBytes(value) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let string = '';\n  for (let i = 0; i < value.length; i++) string += hexes[value[i]];\n  const hex = \"0x\".concat(string);\n  if (typeof options.size === 'number') {\n    internal.assertSize(hex, options.size);\n    return padRight(hex, options.size);\n  }\n  return hex;\n}\n/**\n * Encodes a number or bigint into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromNumber(420)\n * // @log: '0x1a4'\n *\n * Hex.fromNumber(420, { size: 32 })\n * // @log: '0x00000000000000000000000000000000000000000000000000000000000001a4'\n * ```\n *\n * @param value - The number or bigint value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function fromNumber(value) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    signed,\n    size\n  } = options;\n  const value_ = BigInt(value);\n  let maxValue;\n  if (size) {\n    if (signed) maxValue = (1n << BigInt(size) * 8n - 1n) - 1n;else maxValue = 2n ** (BigInt(size) * 8n) - 1n;\n  } else if (typeof value === 'number') {\n    maxValue = BigInt(Number.MAX_SAFE_INTEGER);\n  }\n  const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0;\n  if (maxValue && value_ > maxValue || value_ < minValue) {\n    const suffix = typeof value === 'bigint' ? 'n' : '';\n    throw new IntegerOutOfRangeError({\n      max: maxValue ? \"\".concat(maxValue).concat(suffix) : undefined,\n      min: \"\".concat(minValue).concat(suffix),\n      signed,\n      size,\n      value: \"\".concat(value).concat(suffix)\n    });\n  }\n  const stringValue = (signed && value_ < 0 ? BigInt.asUintN(size * 8, BigInt(value_)) : value_).toString(16);\n  const hex = \"0x\".concat(stringValue);\n  if (size) return padLeft(hex, size);\n  return hex;\n}\n/**\n * Encodes a string into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n * Hex.fromString('Hello World!')\n * // '0x48656c6c6f20576f726c6421'\n *\n * Hex.fromString('Hello World!', { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n * ```\n *\n * @param value - The string value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function fromString(value) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return fromBytes(encoder.encode(value), options);\n}\n/**\n * Checks if two {@link ox#Hex.Hex} values are equal.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.isEqual('0xdeadbeef', '0xdeadbeef')\n * // @log: true\n *\n * Hex.isEqual('0xda', '0xba')\n * // @log: false\n * ```\n *\n * @param hexA - The first {@link ox#Hex.Hex} value.\n * @param hexB - The second {@link ox#Hex.Hex} value.\n * @returns `true` if the two {@link ox#Hex.Hex} values are equal, `false` otherwise.\n */\nexport function isEqual(hexA, hexB) {\n  return equalBytes(Bytes.fromHex(hexA), Bytes.fromHex(hexB));\n}\n/**\n * Pads a {@link ox#Hex.Hex} value to the left with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.padLeft('0x1234', 4)\n * // @log: '0x00001234'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to pad.\n * @param size - The size (in bytes) of the output hex value.\n * @returns The padded {@link ox#Hex.Hex} value.\n */\nexport function padLeft(value, size) {\n  return internal.pad(value, {\n    dir: 'left',\n    size\n  });\n}\n/**\n * Pads a {@link ox#Hex.Hex} value to the right with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts\n * import { Hex } from 'ox'\n *\n * Hex.padRight('0x1234', 4)\n * // @log: '0x12340000'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to pad.\n * @param size - The size (in bytes) of the output hex value.\n * @returns The padded {@link ox#Hex.Hex} value.\n */\nexport function padRight(value, size) {\n  return internal.pad(value, {\n    dir: 'right',\n    size\n  });\n}\n/**\n * Generates a random {@link ox#Hex.Hex} value of the specified length.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const hex = Hex.random(32)\n * // @log: '0x...'\n * ```\n *\n * @returns Random {@link ox#Hex.Hex} value.\n */\nexport function random(length) {\n  return fromBytes(Bytes.random(length));\n}\n/**\n * Returns a section of a {@link ox#Bytes.Bytes} value given a start/end bytes offset.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.slice('0x0123456789', 1, 4)\n * // @log: '0x234567'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to slice.\n * @param start - The start offset (in bytes).\n * @param end - The end offset (in bytes).\n * @param options - Options.\n * @returns The sliced {@link ox#Hex.Hex} value.\n */\nexport function slice(value, start, end) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const {\n    strict\n  } = options;\n  internal.assertStartOffset(value, start);\n  const value_ = \"0x\".concat(value.replace('0x', '').slice((start !== null && start !== void 0 ? start : 0) * 2, (end !== null && end !== void 0 ? end : value.length) * 2));\n  if (strict) internal.assertEndOffset(value_, start, end);\n  return value_;\n}\n/**\n * Retrieves the size of a {@link ox#Hex.Hex} value (in bytes).\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.size('0xdeadbeef')\n * // @log: 4\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to get the size of.\n * @returns The size of the {@link ox#Hex.Hex} value (in bytes).\n */\nexport function size(value) {\n  return Math.ceil((value.length - 2) / 2);\n}\n/**\n * Trims leading zeros from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.trimLeft('0x00000000deadbeef')\n * // @log: '0xdeadbeef'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to trim.\n * @returns The trimmed {@link ox#Hex.Hex} value.\n */\nexport function trimLeft(value) {\n  return internal.trim(value, {\n    dir: 'left'\n  });\n}\n/**\n * Trims trailing zeros from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.trimRight('0xdeadbeef00000000')\n * // @log: '0xdeadbeef'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to trim.\n * @returns The trimmed {@link ox#Hex.Hex} value.\n */\nexport function trimRight(value) {\n  return internal.trim(value, {\n    dir: 'right'\n  });\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a BigInt.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBigInt('0x1a4')\n * // @log: 420n\n *\n * Hex.toBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // @log: 420n\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded BigInt.\n */\nexport function toBigInt(hex) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    signed\n  } = options;\n  if (options.size) internal.assertSize(hex, options.size);\n  const value = BigInt(hex);\n  if (!signed) return value;\n  const size = (hex.length - 2) / 2;\n  const max_unsigned = (1n << BigInt(size) * 8n) - 1n;\n  const max_signed = max_unsigned >> 1n;\n  if (value <= max_signed) return value;\n  return value - max_unsigned - 1n;\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBoolean('0x01')\n * // @log: true\n *\n * Hex.toBoolean('0x0000000000000000000000000000000000000000000000000000000000000001', { size: 32 })\n * // @log: true\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded boolean.\n */\nexport function toBoolean(hex) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (options.size) internal.assertSize(hex, options.size);\n  const hex_ = trimLeft(hex);\n  if (hex_ === '0x') return false;\n  if (hex_ === '0x1') return true;\n  throw new InvalidHexBooleanError(hex);\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const data = Hex.toBytes('0x48656c6c6f20776f726c6421')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded {@link ox#Bytes.Bytes}.\n */\nexport function toBytes(hex) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return Bytes.fromHex(hex, options);\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a number.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toNumber('0x1a4')\n * // @log: 420\n *\n * Hex.toNumber('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // @log: 420\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded number.\n */\nexport function toNumber(hex) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    signed,\n    size\n  } = options;\n  if (!signed && !size) return Number(hex);\n  return Number(toBigInt(hex, options));\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a string.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toString('0x48656c6c6f20576f726c6421')\n * // @log: 'Hello world!'\n *\n * Hex.toString('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *  size: 32,\n * })\n * // @log: 'Hello world'\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded string.\n */\nexport function toString(hex) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    size\n  } = options;\n  let bytes = Bytes.fromHex(hex);\n  if (size) {\n    internal_bytes.assertSize(bytes, size);\n    bytes = Bytes.trimRight(bytes);\n  }\n  return new TextDecoder().decode(bytes);\n}\n/**\n * Checks if the given value is {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.validate('0xdeadbeef')\n * // @log: true\n *\n * Hex.validate(Bytes.from([1, 2, 3]))\n * // @log: false\n * ```\n *\n * @param value - The value to check.\n * @param options - Options.\n * @returns `true` if the value is a {@link ox#Hex.Hex}, `false` otherwise.\n */\nexport function validate(value) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    strict = false\n  } = options;\n  try {\n    assert(value, {\n      strict\n    });\n    return true;\n  } catch (_unused) {\n    return false;\n  }\n}\n/**\n * Thrown when the provided integer is out of range, and cannot be represented as a hex value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromNumber(420182738912731283712937129)\n * // @error: Hex.IntegerOutOfRangeError: Number \\`4.2018273891273126e+26\\` is not in safe unsigned integer range (`0` to `9007199254740991`)\n * ```\n */\nexport class IntegerOutOfRangeError extends Errors.BaseError {\n  constructor(_ref) {\n    let {\n      max,\n      min,\n      signed,\n      size,\n      value\n    } = _ref;\n    super(\"Number `\".concat(value, \"` is not in safe\").concat(size ? \" \".concat(size * 8, \"-bit\") : '').concat(signed ? ' signed' : ' unsigned', \" integer range \").concat(max ? \"(`\".concat(min, \"` to `\").concat(max, \"`)\") : \"(above `\".concat(min, \"`)\")));\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Hex.IntegerOutOfRangeError'\n    });\n  }\n}\n/**\n * Thrown when the provided hex value cannot be represented as a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBoolean('0xa')\n * // @error: Hex.InvalidHexBooleanError: Hex value `\"0xa\"` is not a valid boolean.\n * // @error: The hex value must be `\"0x0\"` (false) or `\"0x1\"` (true).\n * ```\n */\nexport class InvalidHexBooleanError extends Errors.BaseError {\n  constructor(hex) {\n    super(\"Hex value `\\\"\".concat(hex, \"\\\"` is not a valid boolean.\"), {\n      metaMessages: ['The hex value must be `\"0x0\"` (false) or `\"0x1\"` (true).']\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Hex.InvalidHexBooleanError'\n    });\n  }\n}\n/**\n * Thrown when the provided value is not a valid hex type.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert(1)\n * // @error: Hex.InvalidHexTypeError: Value `1` of type `number` is an invalid hex type.\n * ```\n */\nexport class InvalidHexTypeError extends Errors.BaseError {\n  constructor(value) {\n    super(\"Value `\".concat(typeof value === 'object' ? Json.stringify(value) : value, \"` of type `\").concat(typeof value, \"` is an invalid hex type.\"), {\n      metaMessages: ['Hex types must be represented as `\"0x${string}\"`.']\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Hex.InvalidHexTypeError'\n    });\n  }\n}\n/**\n * Thrown when the provided hex value is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert('0x0123456789abcdefg')\n * // @error: Hex.InvalidHexValueError: Value `0x0123456789abcdefg` is an invalid hex value.\n * // @error: Hex values must start with `\"0x\"` and contain only hexadecimal characters (0-9, a-f, A-F).\n * ```\n */\nexport class InvalidHexValueError extends Errors.BaseError {\n  constructor(value) {\n    super(\"Value `\".concat(value, \"` is an invalid hex value.\"), {\n      metaMessages: ['Hex values must start with `\"0x\"` and contain only hexadecimal characters (0-9, a-f, A-F).']\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Hex.InvalidHexValueError'\n    });\n  }\n}\n/**\n * Thrown when the provided hex value is an odd length.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.fromHex('0xabcde')\n * // @error: Hex.InvalidLengthError: Hex value `\"0xabcde\"` is an odd length (5 nibbles).\n * ```\n */\nexport class InvalidLengthError extends Errors.BaseError {\n  constructor(value) {\n    super(\"Hex value `\\\"\".concat(value, \"\\\"` is an odd length (\").concat(value.length - 2, \" nibbles).\"), {\n      metaMessages: ['It must be an even length.']\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Hex.InvalidLengthError'\n    });\n  }\n}\n/**\n * Thrown when the size of the value exceeds the expected max size.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromString('Hello World!', { size: 8 })\n * // @error: Hex.SizeOverflowError: Size cannot exceed `8` bytes. Given size: `12` bytes.\n * ```\n */\nexport class SizeOverflowError extends Errors.BaseError {\n  constructor(_ref2) {\n    let {\n      givenSize,\n      maxSize\n    } = _ref2;\n    super(\"Size cannot exceed `\".concat(maxSize, \"` bytes. Given size: `\").concat(givenSize, \"` bytes.\"));\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Hex.SizeOverflowError'\n    });\n  }\n}\n/**\n * Thrown when the slice offset exceeds the bounds of the value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.slice('0x0123456789', 6)\n * // @error: Hex.SliceOffsetOutOfBoundsError: Slice starting at offset `6` is out-of-bounds (size: `5`).\n * ```\n */\nexport class SliceOffsetOutOfBoundsError extends Errors.BaseError {\n  constructor(_ref3) {\n    let {\n      offset,\n      position,\n      size\n    } = _ref3;\n    super(\"Slice \".concat(position === 'start' ? 'starting' : 'ending', \" at offset `\").concat(offset, \"` is out-of-bounds (size: `\").concat(size, \"`).\"));\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Hex.SliceOffsetOutOfBoundsError'\n    });\n  }\n}\n/**\n * Thrown when the size of the value exceeds the pad size.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.padLeft('0x1a4e12a45a21323123aaa87a897a897a898a6567a578a867a98778a667a85a875a87a6a787a65a675a6a9', 32)\n * // @error: Hex.SizeExceedsPaddingSizeError: Hex size (`43`) exceeds padding size (`32`).\n * ```\n */\nexport class SizeExceedsPaddingSizeError extends Errors.BaseError {\n  constructor(_ref4) {\n    let {\n      size,\n      targetSize,\n      type\n    } = _ref4;\n    super(\"\".concat(type.charAt(0).toUpperCase()).concat(type.slice(1).toLowerCase(), \" size (`\").concat(size, \"`) exceeds padding size (`\").concat(targetSize, \"`).\"));\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Hex.SizeExceedsPaddingSizeError'\n    });\n  }\n}","map":{"version":3,"names":["equalBytes","Bytes","Errors","internal_bytes","internal","Json","encoder","TextEncoder","hexes","Array","from","length","_v","i","toString","padStart","assert","value","options","arguments","undefined","strict","InvalidHexTypeError","test","InvalidHexValueError","startsWith","concat","_len","values","_key","reduce","acc","x","replace","Uint8Array","fromBytes","isArray","fromBoolean","hex","Number","size","assertSize","padLeft","string","padRight","fromNumber","signed","value_","BigInt","maxValue","MAX_SAFE_INTEGER","minValue","suffix","IntegerOutOfRangeError","max","min","stringValue","asUintN","fromString","encode","isEqual","hexA","hexB","fromHex","pad","dir","random","slice","start","end","assertStartOffset","assertEndOffset","Math","ceil","trimLeft","trim","trimRight","toBigInt","max_unsigned","max_signed","toBoolean","hex_","InvalidHexBooleanError","toBytes","toNumber","bytes","TextDecoder","decode","validate","_unused","BaseError","constructor","_ref","Object","defineProperty","metaMessages","stringify","InvalidLengthError","SizeOverflowError","_ref2","givenSize","maxSize","SliceOffsetOutOfBoundsError","_ref3","offset","position","SizeExceedsPaddingSizeError","_ref4","targetSize","type","charAt","toUpperCase","toLowerCase"],"sources":["/Users/mac/Desktop/topl1/frontend/node_modules/ox/core/Hex.ts"],"sourcesContent":["import { equalBytes } from '@noble/curves/abstract/utils'\nimport * as Bytes from './Bytes.js'\nimport * as Errors from './Errors.js'\nimport * as internal_bytes from './internal/bytes.js'\nimport * as internal from './internal/hex.js'\nimport * as Json from './Json.js'\n\nconst encoder = /*#__PURE__*/ new TextEncoder()\n\nconst hexes = /*#__PURE__*/ Array.from({ length: 256 }, (_v, i) =>\n  i.toString(16).padStart(2, '0'),\n)\n\n/** Root type for a Hex string. */\nexport type Hex = `0x${string}`\n\n/**\n * Asserts if the given value is {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert('abc')\n * // @error: InvalidHexValueTypeError:\n * // @error: Value `\"abc\"` of type `string` is an invalid hex type.\n * // @error: Hex types must be represented as `\"0x\\${string}\"`.\n * ```\n *\n * @param value - The value to assert.\n * @param options - Options.\n */\nexport function assert(\n  value: unknown,\n  options: assert.Options = {},\n): asserts value is Hex {\n  const { strict = false } = options\n  if (!value) throw new InvalidHexTypeError(value)\n  if (typeof value !== 'string') throw new InvalidHexTypeError(value)\n  if (strict) {\n    if (!/^0x[0-9a-fA-F]*$/.test(value)) throw new InvalidHexValueError(value)\n  }\n  if (!value.startsWith('0x')) throw new InvalidHexValueError(value)\n}\n\nexport declare namespace assert {\n  type Options = {\n    /** Checks if the {@link ox#Hex.Hex} value contains invalid hexadecimal characters. @default false */\n    strict?: boolean | undefined\n  }\n\n  type ErrorType =\n    | InvalidHexTypeError\n    | InvalidHexValueError\n    | Errors.GlobalErrorType\n}\n\n/**\n * Concatenates two or more {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.concat('0x123', '0x456')\n * // @log: '0x123456'\n * ```\n *\n * @param values - The {@link ox#Hex.Hex} values to concatenate.\n * @returns The concatenated {@link ox#Hex.Hex} value.\n */\nexport function concat(...values: readonly Hex[]): Hex {\n  return `0x${(values as Hex[]).reduce((acc, x) => acc + x.replace('0x', ''), '')}`\n}\n\nexport declare namespace concat {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Instantiates a {@link ox#Hex.Hex} value from a hex string or {@link ox#Bytes.Bytes} value.\n *\n * :::tip\n *\n * To instantiate from a **Boolean**, **String**, or **Number**, use one of the following:\n *\n * - `Hex.fromBoolean`\n *\n * - `Hex.fromString`\n *\n * - `Hex.fromNumber`\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.from('0x48656c6c6f20576f726c6421')\n * // @log: '0x48656c6c6f20576f726c6421'\n *\n * Hex.from(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value to encode.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function from(value: Hex | Bytes.Bytes | readonly number[]): Hex {\n  if (value instanceof Uint8Array) return fromBytes(value)\n  if (Array.isArray(value)) return fromBytes(new Uint8Array(value))\n  return value as never\n}\n\nexport declare namespace from {\n  type Options = {\n    /** The size (in bytes) of the output hex value. */\n    size?: number | undefined\n  }\n\n  type ErrorType = fromBytes.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a boolean into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromBoolean(true)\n * // @log: '0x1'\n *\n * Hex.fromBoolean(false)\n * // @log: '0x0'\n *\n * Hex.fromBoolean(true, { size: 32 })\n * // @log: '0x0000000000000000000000000000000000000000000000000000000000000001'\n * ```\n *\n * @param value - The boolean value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function fromBoolean(\n  value: boolean,\n  options: fromBoolean.Options = {},\n): Hex {\n  const hex: Hex = `0x${Number(value)}`\n  if (typeof options.size === 'number') {\n    internal.assertSize(hex, options.size)\n    return padLeft(hex, options.size)\n  }\n  return hex\n}\n\nexport declare namespace fromBoolean {\n  type Options = {\n    /** The size (in bytes) of the output hex value. */\n    size?: number | undefined\n  }\n\n  type ErrorType =\n    | internal.assertSize.ErrorType\n    | padLeft.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.fromBytes(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function fromBytes(\n  value: Bytes.Bytes,\n  options: fromBytes.Options = {},\n): Hex {\n  let string = ''\n  for (let i = 0; i < value.length; i++) string += hexes[value[i]!]\n  const hex = `0x${string}` as const\n\n  if (typeof options.size === 'number') {\n    internal.assertSize(hex, options.size)\n    return padRight(hex, options.size)\n  }\n  return hex\n}\n\nexport declare namespace fromBytes {\n  type Options = {\n    /** The size (in bytes) of the output hex value. */\n    size?: number | undefined\n  }\n\n  type ErrorType =\n    | internal.assertSize.ErrorType\n    | padRight.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a number or bigint into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromNumber(420)\n * // @log: '0x1a4'\n *\n * Hex.fromNumber(420, { size: 32 })\n * // @log: '0x00000000000000000000000000000000000000000000000000000000000001a4'\n * ```\n *\n * @param value - The number or bigint value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function fromNumber(\n  value: number | bigint,\n  options: fromNumber.Options = {},\n): Hex {\n  const { signed, size } = options\n\n  const value_ = BigInt(value)\n\n  let maxValue: bigint | number | undefined\n  if (size) {\n    if (signed) maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n\n    else maxValue = 2n ** (BigInt(size) * 8n) - 1n\n  } else if (typeof value === 'number') {\n    maxValue = BigInt(Number.MAX_SAFE_INTEGER)\n  }\n\n  const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0\n\n  if ((maxValue && value_ > maxValue) || value_ < minValue) {\n    const suffix = typeof value === 'bigint' ? 'n' : ''\n    throw new IntegerOutOfRangeError({\n      max: maxValue ? `${maxValue}${suffix}` : undefined,\n      min: `${minValue}${suffix}`,\n      signed,\n      size,\n      value: `${value}${suffix}`,\n    })\n  }\n\n  const stringValue = (\n    signed && value_ < 0 ? BigInt.asUintN(size * 8, BigInt(value_)) : value_\n  ).toString(16)\n\n  const hex = `0x${stringValue}` as Hex\n  if (size) return padLeft(hex, size) as Hex\n  return hex\n}\n\nexport declare namespace fromNumber {\n  type Options =\n    | {\n        /** Whether or not the number of a signed representation. */\n        signed?: boolean | undefined\n        /** The size (in bytes) of the output hex value. */\n        size: number\n      }\n    | {\n        signed?: undefined\n        /** The size (in bytes) of the output hex value. */\n        size?: number | undefined\n      }\n\n  type ErrorType =\n    | IntegerOutOfRangeError\n    | padLeft.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a string into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n * Hex.fromString('Hello World!')\n * // '0x48656c6c6f20576f726c6421'\n *\n * Hex.fromString('Hello World!', { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n * ```\n *\n * @param value - The string value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function fromString(\n  value: string,\n  options: fromString.Options = {},\n): Hex {\n  return fromBytes(encoder.encode(value), options)\n}\n\nexport declare namespace fromString {\n  type Options = {\n    /** The size (in bytes) of the output hex value. */\n    size?: number | undefined\n  }\n\n  type ErrorType = fromBytes.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Checks if two {@link ox#Hex.Hex} values are equal.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.isEqual('0xdeadbeef', '0xdeadbeef')\n * // @log: true\n *\n * Hex.isEqual('0xda', '0xba')\n * // @log: false\n * ```\n *\n * @param hexA - The first {@link ox#Hex.Hex} value.\n * @param hexB - The second {@link ox#Hex.Hex} value.\n * @returns `true` if the two {@link ox#Hex.Hex} values are equal, `false` otherwise.\n */\nexport function isEqual(hexA: Hex, hexB: Hex) {\n  return equalBytes(Bytes.fromHex(hexA), Bytes.fromHex(hexB))\n}\n\nexport declare namespace isEqual {\n  type ErrorType = Bytes.fromHex.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Pads a {@link ox#Hex.Hex} value to the left with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.padLeft('0x1234', 4)\n * // @log: '0x00001234'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to pad.\n * @param size - The size (in bytes) of the output hex value.\n * @returns The padded {@link ox#Hex.Hex} value.\n */\nexport function padLeft(\n  value: Hex,\n  size?: number | undefined,\n): padLeft.ReturnType {\n  return internal.pad(value, { dir: 'left', size })\n}\n\nexport declare namespace padLeft {\n  type ReturnType = Hex\n  type ErrorType = internal.pad.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Pads a {@link ox#Hex.Hex} value to the right with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts\n * import { Hex } from 'ox'\n *\n * Hex.padRight('0x1234', 4)\n * // @log: '0x12340000'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to pad.\n * @param size - The size (in bytes) of the output hex value.\n * @returns The padded {@link ox#Hex.Hex} value.\n */\nexport function padRight(\n  value: Hex,\n  size?: number | undefined,\n): padRight.ReturnType {\n  return internal.pad(value, { dir: 'right', size })\n}\n\nexport declare namespace padRight {\n  type ReturnType = Hex\n  type ErrorType = internal.pad.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Generates a random {@link ox#Hex.Hex} value of the specified length.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const hex = Hex.random(32)\n * // @log: '0x...'\n * ```\n *\n * @returns Random {@link ox#Hex.Hex} value.\n */\nexport function random(length: number): Hex {\n  return fromBytes(Bytes.random(length))\n}\n\nexport declare namespace random {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Returns a section of a {@link ox#Bytes.Bytes} value given a start/end bytes offset.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.slice('0x0123456789', 1, 4)\n * // @log: '0x234567'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to slice.\n * @param start - The start offset (in bytes).\n * @param end - The end offset (in bytes).\n * @param options - Options.\n * @returns The sliced {@link ox#Hex.Hex} value.\n */\nexport function slice(\n  value: Hex,\n  start?: number | undefined,\n  end?: number | undefined,\n  options: slice.Options = {},\n): Hex {\n  const { strict } = options\n  internal.assertStartOffset(value, start)\n  const value_ = `0x${value\n    .replace('0x', '')\n    .slice((start ?? 0) * 2, (end ?? value.length) * 2)}` as const\n  if (strict) internal.assertEndOffset(value_, start, end)\n  return value_\n}\n\nexport declare namespace slice {\n  type Options = {\n    /** Asserts that the sliced value is the same size as the given start/end offsets. */\n    strict?: boolean | undefined\n  }\n\n  type ErrorType =\n    | internal.assertStartOffset.ErrorType\n    | internal.assertEndOffset.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Retrieves the size of a {@link ox#Hex.Hex} value (in bytes).\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.size('0xdeadbeef')\n * // @log: 4\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to get the size of.\n * @returns The size of the {@link ox#Hex.Hex} value (in bytes).\n */\nexport function size(value: Hex): number {\n  return Math.ceil((value.length - 2) / 2)\n}\n\nexport declare namespace size {\n  export type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Trims leading zeros from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.trimLeft('0x00000000deadbeef')\n * // @log: '0xdeadbeef'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to trim.\n * @returns The trimmed {@link ox#Hex.Hex} value.\n */\nexport function trimLeft(value: Hex): trimLeft.ReturnType {\n  return internal.trim(value, { dir: 'left' })\n}\n\nexport declare namespace trimLeft {\n  type ReturnType = Hex\n\n  type ErrorType = internal.trim.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Trims trailing zeros from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.trimRight('0xdeadbeef00000000')\n * // @log: '0xdeadbeef'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to trim.\n * @returns The trimmed {@link ox#Hex.Hex} value.\n */\nexport function trimRight(value: Hex): trimRight.ReturnType {\n  return internal.trim(value, { dir: 'right' })\n}\n\nexport declare namespace trimRight {\n  type ReturnType = Hex\n\n  type ErrorType = internal.trim.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a {@link ox#Hex.Hex} value into a BigInt.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBigInt('0x1a4')\n * // @log: 420n\n *\n * Hex.toBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // @log: 420n\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded BigInt.\n */\nexport function toBigInt(hex: Hex, options: toBigInt.Options = {}): bigint {\n  const { signed } = options\n\n  if (options.size) internal.assertSize(hex, options.size)\n\n  const value = BigInt(hex)\n  if (!signed) return value\n\n  const size = (hex.length - 2) / 2\n\n  const max_unsigned = (1n << (BigInt(size) * 8n)) - 1n\n  const max_signed = max_unsigned >> 1n\n\n  if (value <= max_signed) return value\n  return value - max_unsigned - 1n\n}\n\nexport declare namespace toBigInt {\n  type Options = {\n    /** Whether or not the number of a signed representation. */\n    signed?: boolean | undefined\n    /** Size (in bytes) of the hex value. */\n    size?: number | undefined\n  }\n\n  type ErrorType = internal.assertSize.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a {@link ox#Hex.Hex} value into a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBoolean('0x01')\n * // @log: true\n *\n * Hex.toBoolean('0x0000000000000000000000000000000000000000000000000000000000000001', { size: 32 })\n * // @log: true\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded boolean.\n */\nexport function toBoolean(hex: Hex, options: toBoolean.Options = {}): boolean {\n  if (options.size) internal.assertSize(hex, options.size)\n  const hex_ = trimLeft(hex)\n  if (hex_ === '0x') return false\n  if (hex_ === '0x1') return true\n  throw new InvalidHexBooleanError(hex)\n}\n\nexport declare namespace toBoolean {\n  type Options = {\n    /** Size (in bytes) of the hex value. */\n    size?: number | undefined\n  }\n\n  type ErrorType =\n    | internal.assertSize.ErrorType\n    | trimLeft.ErrorType\n    | InvalidHexBooleanError\n    | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a {@link ox#Hex.Hex} value into a {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const data = Hex.toBytes('0x48656c6c6f20776f726c6421')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded {@link ox#Bytes.Bytes}.\n */\nexport function toBytes(hex: Hex, options: toBytes.Options = {}): Bytes.Bytes {\n  return Bytes.fromHex(hex, options)\n}\n\nexport declare namespace toBytes {\n  type Options = {\n    /** Size (in bytes) of the hex value. */\n    size?: number | undefined\n  }\n\n  type ErrorType = Bytes.fromHex.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a {@link ox#Hex.Hex} value into a number.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toNumber('0x1a4')\n * // @log: 420\n *\n * Hex.toNumber('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // @log: 420\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded number.\n */\nexport function toNumber(hex: Hex, options: toNumber.Options = {}): number {\n  const { signed, size } = options\n  if (!signed && !size) return Number(hex)\n  return Number(toBigInt(hex, options))\n}\n\nexport declare namespace toNumber {\n  type Options = toBigInt.Options\n\n  type ErrorType = toBigInt.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a {@link ox#Hex.Hex} value into a string.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toString('0x48656c6c6f20576f726c6421')\n * // @log: 'Hello world!'\n *\n * Hex.toString('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *  size: 32,\n * })\n * // @log: 'Hello world'\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded string.\n */\nexport function toString(hex: Hex, options: toString.Options = {}): string {\n  const { size } = options\n\n  let bytes = Bytes.fromHex(hex)\n  if (size) {\n    internal_bytes.assertSize(bytes, size)\n    bytes = Bytes.trimRight(bytes)\n  }\n  return new TextDecoder().decode(bytes)\n}\n\nexport declare namespace toString {\n  type Options = {\n    /** Size (in bytes) of the hex value. */\n    size?: number | undefined\n  }\n\n  type ErrorType =\n    | internal_bytes.assertSize.ErrorType\n    | Bytes.fromHex.ErrorType\n    | Bytes.trimRight.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Checks if the given value is {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.validate('0xdeadbeef')\n * // @log: true\n *\n * Hex.validate(Bytes.from([1, 2, 3]))\n * // @log: false\n * ```\n *\n * @param value - The value to check.\n * @param options - Options.\n * @returns `true` if the value is a {@link ox#Hex.Hex}, `false` otherwise.\n */\nexport function validate(\n  value: unknown,\n  options: validate.Options = {},\n): value is Hex {\n  const { strict = false } = options\n  try {\n    assert(value, { strict })\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport declare namespace validate {\n  type Options = {\n    /** Checks if the {@link ox#Hex.Hex} value contains invalid hexadecimal characters. @default false */\n    strict?: boolean | undefined\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Thrown when the provided integer is out of range, and cannot be represented as a hex value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromNumber(420182738912731283712937129)\n * // @error: Hex.IntegerOutOfRangeError: Number \\`4.2018273891273126e+26\\` is not in safe unsigned integer range (`0` to `9007199254740991`)\n * ```\n */\nexport class IntegerOutOfRangeError extends Errors.BaseError {\n  override readonly name = 'Hex.IntegerOutOfRangeError'\n\n  constructor({\n    max,\n    min,\n    signed,\n    size,\n    value,\n  }: {\n    max?: string | undefined\n    min: string\n    signed?: boolean | undefined\n    size?: number | undefined\n    value: string\n  }) {\n    super(\n      `Number \\`${value}\\` is not in safe${\n        size ? ` ${size * 8}-bit` : ''\n      }${signed ? ' signed' : ' unsigned'} integer range ${max ? `(\\`${min}\\` to \\`${max}\\`)` : `(above \\`${min}\\`)`}`,\n    )\n  }\n}\n\n/**\n * Thrown when the provided hex value cannot be represented as a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBoolean('0xa')\n * // @error: Hex.InvalidHexBooleanError: Hex value `\"0xa\"` is not a valid boolean.\n * // @error: The hex value must be `\"0x0\"` (false) or `\"0x1\"` (true).\n * ```\n */\nexport class InvalidHexBooleanError extends Errors.BaseError {\n  override readonly name = 'Hex.InvalidHexBooleanError'\n\n  constructor(hex: Hex) {\n    super(`Hex value \\`\"${hex}\"\\` is not a valid boolean.`, {\n      metaMessages: [\n        'The hex value must be `\"0x0\"` (false) or `\"0x1\"` (true).',\n      ],\n    })\n  }\n}\n\n/**\n * Thrown when the provided value is not a valid hex type.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert(1)\n * // @error: Hex.InvalidHexTypeError: Value `1` of type `number` is an invalid hex type.\n * ```\n */\nexport class InvalidHexTypeError extends Errors.BaseError {\n  override readonly name = 'Hex.InvalidHexTypeError'\n\n  constructor(value: unknown) {\n    super(\n      `Value \\`${typeof value === 'object' ? Json.stringify(value) : value}\\` of type \\`${typeof value}\\` is an invalid hex type.`,\n      {\n        metaMessages: ['Hex types must be represented as `\"0x${string}\"`.'],\n      },\n    )\n  }\n}\n\n/**\n * Thrown when the provided hex value is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert('0x0123456789abcdefg')\n * // @error: Hex.InvalidHexValueError: Value `0x0123456789abcdefg` is an invalid hex value.\n * // @error: Hex values must start with `\"0x\"` and contain only hexadecimal characters (0-9, a-f, A-F).\n * ```\n */\nexport class InvalidHexValueError extends Errors.BaseError {\n  override readonly name = 'Hex.InvalidHexValueError'\n\n  constructor(value: unknown) {\n    super(`Value \\`${value}\\` is an invalid hex value.`, {\n      metaMessages: [\n        'Hex values must start with `\"0x\"` and contain only hexadecimal characters (0-9, a-f, A-F).',\n      ],\n    })\n  }\n}\n\n/**\n * Thrown when the provided hex value is an odd length.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.fromHex('0xabcde')\n * // @error: Hex.InvalidLengthError: Hex value `\"0xabcde\"` is an odd length (5 nibbles).\n * ```\n */\nexport class InvalidLengthError extends Errors.BaseError {\n  override readonly name = 'Hex.InvalidLengthError'\n\n  constructor(value: Hex) {\n    super(\n      `Hex value \\`\"${value}\"\\` is an odd length (${value.length - 2} nibbles).`,\n      {\n        metaMessages: ['It must be an even length.'],\n      },\n    )\n  }\n}\n\n/**\n * Thrown when the size of the value exceeds the expected max size.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromString('Hello World!', { size: 8 })\n * // @error: Hex.SizeOverflowError: Size cannot exceed `8` bytes. Given size: `12` bytes.\n * ```\n */\nexport class SizeOverflowError extends Errors.BaseError {\n  override readonly name = 'Hex.SizeOverflowError'\n\n  constructor({ givenSize, maxSize }: { givenSize: number; maxSize: number }) {\n    super(\n      `Size cannot exceed \\`${maxSize}\\` bytes. Given size: \\`${givenSize}\\` bytes.`,\n    )\n  }\n}\n\n/**\n * Thrown when the slice offset exceeds the bounds of the value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.slice('0x0123456789', 6)\n * // @error: Hex.SliceOffsetOutOfBoundsError: Slice starting at offset `6` is out-of-bounds (size: `5`).\n * ```\n */\nexport class SliceOffsetOutOfBoundsError extends Errors.BaseError {\n  override readonly name = 'Hex.SliceOffsetOutOfBoundsError'\n\n  constructor({\n    offset,\n    position,\n    size,\n  }: { offset: number; position: 'start' | 'end'; size: number }) {\n    super(\n      `Slice ${\n        position === 'start' ? 'starting' : 'ending'\n      } at offset \\`${offset}\\` is out-of-bounds (size: \\`${size}\\`).`,\n    )\n  }\n}\n\n/**\n * Thrown when the size of the value exceeds the pad size.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.padLeft('0x1a4e12a45a21323123aaa87a897a897a898a6567a578a867a98778a667a85a875a87a6a787a65a675a6a9', 32)\n * // @error: Hex.SizeExceedsPaddingSizeError: Hex size (`43`) exceeds padding size (`32`).\n * ```\n */\nexport class SizeExceedsPaddingSizeError extends Errors.BaseError {\n  override readonly name = 'Hex.SizeExceedsPaddingSizeError'\n\n  constructor({\n    size,\n    targetSize,\n    type,\n  }: {\n    size: number\n    targetSize: number\n    type: 'Hex' | 'Bytes'\n  }) {\n    super(\n      `${type.charAt(0).toUpperCase()}${type\n        .slice(1)\n        .toLowerCase()} size (\\`${size}\\`) exceeds padding size (\\`${targetSize}\\`).`,\n    )\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}