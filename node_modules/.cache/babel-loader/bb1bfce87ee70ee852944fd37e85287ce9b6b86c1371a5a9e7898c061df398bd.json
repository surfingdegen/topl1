{"ast":null,"code":"import { SignatureErc6492 } from 'ox/erc6492';\nimport { SignatureErc8010 } from 'ox/erc8010';\nimport { erc1271Abi, erc6492SignatureValidatorAbi, multicall3Abi } from '../../constants/abis.js';\nimport { erc6492SignatureValidatorByteCode, multicall3Bytecode } from '../../constants/contracts.js';\nimport { CallExecutionError, ContractFunctionExecutionError } from '../../errors/contract.js';\nimport { encodeDeployData } from '../../utils/abi/encodeDeployData.js';\nimport { encodeFunctionData } from '../../utils/abi/encodeFunctionData.js';\nimport { getAddress } from '../../utils/address/getAddress.js';\nimport { isAddressEqual } from '../../utils/address/isAddressEqual.js';\nimport { verifyAuthorization } from '../../utils/authorization/verifyAuthorization.js';\nimport { concatHex } from '../../utils/data/concat.js';\nimport { isHex } from '../../utils/data/isHex.js';\nimport { hexToBool } from '../../utils/encoding/fromHex.js';\nimport { bytesToHex, numberToHex } from '../../utils/encoding/toHex.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { recoverAddress } from '../../utils/signature/recoverAddress.js';\nimport { serializeSignature } from '../../utils/signature/serializeSignature.js';\nimport { call } from './call.js';\nimport { getCode } from './getCode.js';\nimport { readContract } from './readContract.js';\n/**\n * Verifies a message hash onchain using ERC-6492.\n *\n * @param client - Client to use.\n * @param parameters - {@link VerifyHashParameters}\n * @returns Whether or not the signature is valid. {@link VerifyHashReturnType}\n */\nexport async function verifyHash(client, parameters) {\n  const {\n    address,\n    chain = client.chain,\n    hash,\n    erc6492VerifierAddress: verifierAddress = parameters.universalSignatureVerifierAddress ?? chain?.contracts?.erc6492Verifier?.address,\n    multicallAddress = parameters.multicallAddress ?? chain?.contracts?.multicall3?.address\n  } = parameters;\n  if (chain?.verifyHash) return await chain.verifyHash(client, parameters);\n  const signature = (() => {\n    const signature = parameters.signature;\n    if (isHex(signature)) return signature;\n    if (typeof signature === 'object' && 'r' in signature && 's' in signature) return serializeSignature(signature);\n    return bytesToHex(signature);\n  })();\n  try {\n    if (SignatureErc8010.validate(signature)) return await verifyErc8010(client, {\n      ...parameters,\n      multicallAddress,\n      signature\n    });\n    return await verifyErc6492(client, {\n      ...parameters,\n      verifierAddress,\n      signature\n    });\n  } catch (error) {\n    // Fallback attempt to verify the signature via ECDSA recovery.\n    try {\n      const verified = isAddressEqual(getAddress(address), await recoverAddress({\n        hash,\n        signature\n      }));\n      if (verified) return true;\n    } catch {}\n    if (error instanceof VerificationError) {\n      // if the execution fails, the signature was not valid and an internal method inside of the validator reverted\n      // this can happen for many reasons, for example if signer can not be recovered from the signature\n      // or if the signature has no valid format\n      return false;\n    }\n    throw error;\n  }\n}\n/** @internal */\nexport async function verifyErc8010(client, parameters) {\n  const {\n    address,\n    blockNumber,\n    blockTag,\n    hash,\n    multicallAddress\n  } = parameters;\n  const {\n    authorization: authorization_ox,\n    data: initData,\n    signature,\n    to\n  } = SignatureErc8010.unwrap(parameters.signature);\n  // Check if already delegated\n  const code = await getCode(client, {\n    address,\n    blockNumber,\n    blockTag\n  });\n  // If already delegated, perform standard ERC-1271 verification.\n  if (code === concatHex(['0xef0100', authorization_ox.address])) return await verifyErc1271(client, {\n    address,\n    blockNumber,\n    blockTag,\n    hash,\n    signature\n  });\n  const authorization = {\n    address: authorization_ox.address,\n    chainId: Number(authorization_ox.chainId),\n    nonce: Number(authorization_ox.nonce),\n    r: numberToHex(authorization_ox.r, {\n      size: 32\n    }),\n    s: numberToHex(authorization_ox.s, {\n      size: 32\n    }),\n    yParity: authorization_ox.yParity\n  };\n  const valid = await verifyAuthorization({\n    address,\n    authorization\n  });\n  if (!valid) throw new VerificationError();\n  // Deployless verification.\n  const results = await getAction(client, readContract, 'readContract')({\n    ...(multicallAddress ? {\n      address: multicallAddress\n    } : {\n      code: multicall3Bytecode\n    }),\n    authorizationList: [authorization],\n    abi: multicall3Abi,\n    blockNumber,\n    blockTag: 'pending',\n    functionName: 'aggregate3',\n    args: [[...(initData ? [{\n      allowFailure: true,\n      target: to ?? address,\n      callData: initData\n    }] : []), {\n      allowFailure: true,\n      target: address,\n      callData: encodeFunctionData({\n        abi: erc1271Abi,\n        functionName: 'isValidSignature',\n        args: [hash, signature]\n      })\n    }]]\n  });\n  const data = results[results.length - 1]?.returnData;\n  if (data?.startsWith('0x1626ba7e')) return true;\n  throw new VerificationError();\n}\n/** @internal */\n// biome-ignore lint/correctness/noUnusedVariables: _\nasync function verifyErc6492(client, parameters) {\n  const {\n    address,\n    factory,\n    factoryData,\n    hash,\n    signature,\n    verifierAddress,\n    ...rest\n  } = parameters;\n  const wrappedSignature = await (async () => {\n    // If no `factory` or `factoryData` is provided, it is assumed that the\n    // address is not a Smart Account, or the Smart Account is already deployed.\n    if (!factory && !factoryData) return signature;\n    // If the signature is already wrapped, return the signature.\n    if (SignatureErc6492.validate(signature)) return signature;\n    // If the Smart Account is not deployed, wrap the signature with a 6492 wrapper\n    // to perform counterfactual validation.\n    return SignatureErc6492.wrap({\n      data: factoryData,\n      signature,\n      to: factory\n    });\n  })();\n  const args = verifierAddress ? {\n    to: verifierAddress,\n    data: encodeFunctionData({\n      abi: erc6492SignatureValidatorAbi,\n      functionName: 'isValidSig',\n      args: [address, hash, wrappedSignature]\n    }),\n    ...rest\n  } : {\n    data: encodeDeployData({\n      abi: erc6492SignatureValidatorAbi,\n      args: [address, hash, wrappedSignature],\n      bytecode: erc6492SignatureValidatorByteCode\n    }),\n    ...rest\n  };\n  const {\n    data\n  } = await getAction(client, call, 'call')(args).catch(error => {\n    if (error instanceof CallExecutionError) throw new VerificationError();\n    throw error;\n  });\n  if (hexToBool(data ?? '0x0')) return true;\n  throw new VerificationError();\n}\n/** @internal */\nexport async function verifyErc1271(client, parameters) {\n  const {\n    address,\n    blockNumber,\n    blockTag,\n    hash,\n    signature\n  } = parameters;\n  const result = await getAction(client, readContract, 'readContract')({\n    address,\n    abi: erc1271Abi,\n    args: [hash, signature],\n    blockNumber,\n    blockTag,\n    functionName: 'isValidSignature'\n  }).catch(error => {\n    if (error instanceof ContractFunctionExecutionError) throw new VerificationError();\n    throw error;\n  });\n  if (result.startsWith('0x1626ba7e')) return true;\n  throw new VerificationError();\n}\nclass VerificationError extends Error {}","map":{"version":3,"names":["SignatureErc6492","SignatureErc8010","erc1271Abi","erc6492SignatureValidatorAbi","multicall3Abi","erc6492SignatureValidatorByteCode","multicall3Bytecode","CallExecutionError","ContractFunctionExecutionError","encodeDeployData","encodeFunctionData","getAddress","isAddressEqual","verifyAuthorization","concatHex","isHex","hexToBool","bytesToHex","numberToHex","getAction","recoverAddress","serializeSignature","call","getCode","readContract","verifyHash","client","parameters","address","chain","hash","erc6492VerifierAddress","verifierAddress","universalSignatureVerifierAddress","contracts","erc6492Verifier","multicallAddress","multicall3","signature","validate","verifyErc8010","verifyErc6492","error","verified","VerificationError","blockNumber","blockTag","authorization","authorization_ox","data","initData","to","unwrap","code","verifyErc1271","chainId","Number","nonce","r","size","s","yParity","valid","results","authorizationList","abi","functionName","args","allowFailure","target","callData","length","returnData","startsWith","factory","factoryData","rest","wrappedSignature","wrap","bytecode","catch","result","Error"],"sources":["/Users/mac/Desktop/topl1/frontend/node_modules/viem/actions/public/verifyHash.ts"],"sourcesContent":["import type { Address } from 'abitype'\nimport { SignatureErc6492 } from 'ox/erc6492'\nimport { SignatureErc8010 } from 'ox/erc8010'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  erc1271Abi,\n  erc6492SignatureValidatorAbi,\n  multicall3Abi,\n} from '../../constants/abis.js'\nimport {\n  erc6492SignatureValidatorByteCode,\n  multicall3Bytecode,\n} from '../../constants/contracts.js'\nimport {\n  CallExecutionError,\n  ContractFunctionExecutionError,\n} from '../../errors/contract.js'\nimport type { InvalidHexBooleanError } from '../../errors/encoding.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { ByteArray, Hex, Signature } from '../../types/misc.js'\nimport type { OneOf } from '../../types/utils.js'\nimport {\n  type EncodeDeployDataErrorType,\n  encodeDeployData,\n} from '../../utils/abi/encodeDeployData.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  encodeFunctionData,\n} from '../../utils/abi/encodeFunctionData.js'\nimport {\n  type GetAddressErrorType,\n  getAddress,\n} from '../../utils/address/getAddress.js'\nimport {\n  type IsAddressEqualErrorType,\n  isAddressEqual,\n} from '../../utils/address/isAddressEqual.js'\nimport { verifyAuthorization } from '../../utils/authorization/verifyAuthorization.js'\nimport { type ConcatHexErrorType, concatHex } from '../../utils/data/concat.js'\nimport { type IsHexErrorType, isHex } from '../../utils/data/isHex.js'\nimport { hexToBool } from '../../utils/encoding/fromHex.js'\nimport {\n  type BytesToHexErrorType,\n  bytesToHex,\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\nimport { getAction } from '../../utils/getAction.js'\nimport {\n  type RecoverAddressErrorType,\n  recoverAddress,\n} from '../../utils/signature/recoverAddress.js'\nimport {\n  type SerializeSignatureErrorType,\n  serializeSignature,\n} from '../../utils/signature/serializeSignature.js'\nimport { type CallErrorType, type CallParameters, call } from './call.js'\nimport { type GetCodeErrorType, getCode } from './getCode.js'\nimport { type ReadContractErrorType, readContract } from './readContract.js'\n\nexport type VerifyHashParameters = Pick<\n  CallParameters,\n  'blockNumber' | 'blockTag'\n> & {\n  /** The address that signed the original message. */\n  address: Address\n  /** The chain to use. */\n  chain?: Chain | null | undefined\n  /** The address of the ERC-6492 signature verifier contract. */\n  erc6492VerifierAddress?: Address | undefined\n  /** The hash to be verified. */\n  hash: Hex\n  /** Multicall3 address for ERC-8010 verification. */\n  multicallAddress?: Address | undefined\n  /** The signature that was generated by signing the message with the address's private key. */\n  signature: Hex | ByteArray | Signature\n  /** @deprecated use `erc6492VerifierAddress` instead. */\n  universalSignatureVerifierAddress?: Address | undefined\n} & OneOf<{ factory: Address; factoryData: Hex } | {}>\n\nexport type VerifyHashReturnType = boolean\n\nexport type VerifyHashErrorType =\n  | BytesToHexErrorType\n  | CallErrorType\n  | ConcatHexErrorType\n  | EncodeDeployDataErrorType\n  | EncodeFunctionDataErrorType\n  | ErrorType\n  | GetAddressErrorType\n  | GetCodeErrorType\n  | InvalidHexBooleanError\n  | IsAddressEqualErrorType\n  | IsHexErrorType\n  | NumberToHexErrorType\n  | ReadContractErrorType\n  | RecoverAddressErrorType\n  | SerializeSignatureErrorType\n\n/**\n * Verifies a message hash onchain using ERC-6492.\n *\n * @param client - Client to use.\n * @param parameters - {@link VerifyHashParameters}\n * @returns Whether or not the signature is valid. {@link VerifyHashReturnType}\n */\nexport async function verifyHash<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: VerifyHashParameters,\n): Promise<VerifyHashReturnType> {\n  const {\n    address,\n    chain = client.chain,\n    hash,\n    erc6492VerifierAddress:\n      verifierAddress = parameters.universalSignatureVerifierAddress ??\n      chain?.contracts?.erc6492Verifier?.address,\n    multicallAddress = parameters.multicallAddress ??\n      chain?.contracts?.multicall3?.address,\n  } = parameters\n\n  if (chain?.verifyHash) return await chain.verifyHash(client, parameters)\n\n  const signature = (() => {\n    const signature = parameters.signature\n    if (isHex(signature)) return signature\n    if (typeof signature === 'object' && 'r' in signature && 's' in signature)\n      return serializeSignature(signature)\n    return bytesToHex(signature)\n  })()\n\n  try {\n    if (SignatureErc8010.validate(signature))\n      return await verifyErc8010(client, {\n        ...parameters,\n        multicallAddress,\n        signature,\n      })\n    return await verifyErc6492(client, {\n      ...parameters,\n      verifierAddress,\n      signature,\n    })\n  } catch (error) {\n    // Fallback attempt to verify the signature via ECDSA recovery.\n    try {\n      const verified = isAddressEqual(\n        getAddress(address),\n        await recoverAddress({ hash, signature }),\n      )\n      if (verified) return true\n    } catch {}\n\n    if (error instanceof VerificationError) {\n      // if the execution fails, the signature was not valid and an internal method inside of the validator reverted\n      // this can happen for many reasons, for example if signer can not be recovered from the signature\n      // or if the signature has no valid format\n      return false\n    }\n\n    throw error\n  }\n}\n\n/** @internal */\nexport async function verifyErc8010(\n  client: Client,\n  parameters: verifyErc8010.Parameters,\n) {\n  const { address, blockNumber, blockTag, hash, multicallAddress } = parameters\n\n  const {\n    authorization: authorization_ox,\n    data: initData,\n    signature,\n    to,\n  } = SignatureErc8010.unwrap(parameters.signature)\n\n  // Check if already delegated\n  const code = await getCode(client, {\n    address,\n    blockNumber,\n    blockTag,\n  } as never)\n\n  // If already delegated, perform standard ERC-1271 verification.\n  if (code === concatHex(['0xef0100', authorization_ox.address]))\n    return await verifyErc1271(client, {\n      address,\n      blockNumber,\n      blockTag,\n      hash,\n      signature,\n    })\n\n  const authorization = {\n    address: authorization_ox.address,\n    chainId: Number(authorization_ox.chainId),\n    nonce: Number(authorization_ox.nonce),\n    r: numberToHex(authorization_ox.r, { size: 32 }),\n    s: numberToHex(authorization_ox.s, { size: 32 }),\n    yParity: authorization_ox.yParity,\n  } as const\n\n  const valid = await verifyAuthorization({\n    address,\n    authorization,\n  })\n  if (!valid) throw new VerificationError()\n\n  // Deployless verification.\n  const results = await getAction(\n    client,\n    readContract,\n    'readContract',\n  )({\n    ...(multicallAddress\n      ? { address: multicallAddress }\n      : { code: multicall3Bytecode }),\n    authorizationList: [authorization],\n    abi: multicall3Abi,\n    blockNumber,\n    blockTag: 'pending',\n    functionName: 'aggregate3',\n    args: [\n      [\n        ...(initData\n          ? ([\n              {\n                allowFailure: true,\n                target: to ?? address,\n                callData: initData,\n              },\n            ] as const)\n          : []),\n        {\n          allowFailure: true,\n          target: address,\n          callData: encodeFunctionData({\n            abi: erc1271Abi,\n            functionName: 'isValidSignature',\n            args: [hash, signature],\n          }),\n        },\n      ],\n    ],\n  })\n\n  const data = results[results.length - 1]?.returnData\n\n  if (data?.startsWith('0x1626ba7e')) return true\n  throw new VerificationError()\n}\n\nexport namespace verifyErc8010 {\n  export type Parameters = Pick<CallParameters, 'blockNumber' | 'blockTag'> & {\n    /** The address that signed the original message. */\n    address: Address\n    /** The hash to be verified. */\n    hash: Hex\n    /** Multicall3 address for ERC-8010 verification. */\n    multicallAddress?: Address | undefined\n    /** The signature that was generated by signing the message with the address's private key. */\n    signature: Hex\n  }\n}\n\n/** @internal */\n// biome-ignore lint/correctness/noUnusedVariables: _\nasync function verifyErc6492(\n  client: Client,\n  parameters: verifyErc6492.Parameters,\n) {\n  const {\n    address,\n    factory,\n    factoryData,\n    hash,\n    signature,\n    verifierAddress,\n    ...rest\n  } = parameters\n\n  const wrappedSignature = await (async () => {\n    // If no `factory` or `factoryData` is provided, it is assumed that the\n    // address is not a Smart Account, or the Smart Account is already deployed.\n    if (!factory && !factoryData) return signature\n\n    // If the signature is already wrapped, return the signature.\n    if (SignatureErc6492.validate(signature)) return signature\n\n    // If the Smart Account is not deployed, wrap the signature with a 6492 wrapper\n    // to perform counterfactual validation.\n    return SignatureErc6492.wrap({\n      data: factoryData!,\n      signature,\n      to: factory!,\n    })\n  })()\n\n  const args = verifierAddress\n    ? ({\n        to: verifierAddress,\n        data: encodeFunctionData({\n          abi: erc6492SignatureValidatorAbi,\n          functionName: 'isValidSig',\n          args: [address, hash, wrappedSignature],\n        }),\n        ...rest,\n      } as unknown as CallParameters)\n    : ({\n        data: encodeDeployData({\n          abi: erc6492SignatureValidatorAbi,\n          args: [address, hash, wrappedSignature],\n          bytecode: erc6492SignatureValidatorByteCode,\n        }),\n        ...rest,\n      } as unknown as CallParameters)\n\n  const { data } = await getAction(\n    client,\n    call,\n    'call',\n  )(args).catch((error) => {\n    if (error instanceof CallExecutionError) throw new VerificationError()\n    throw error\n  })\n\n  if (hexToBool(data ?? '0x0')) return true\n  throw new VerificationError()\n}\n\nexport namespace verifyErc6492 {\n  export type Parameters = Pick<CallParameters, 'blockNumber' | 'blockTag'> & {\n    /** The address that signed the original message. */\n    address: Address\n    /** The hash to be verified. */\n    hash: Hex\n    /** The signature that was generated by signing the message with the address's private key. */\n    signature: Hex\n    /** The address of the ERC-6492 signature verifier contract. */\n    verifierAddress?: Address | undefined\n  } & OneOf<{ factory: Address; factoryData: Hex } | {}>\n}\n\n/** @internal */\nexport async function verifyErc1271(\n  client: Client,\n  parameters: verifyErc1271.Parameters,\n) {\n  const { address, blockNumber, blockTag, hash, signature } = parameters\n\n  const result = await getAction(\n    client,\n    readContract,\n    'readContract',\n  )({\n    address,\n    abi: erc1271Abi,\n    args: [hash, signature],\n    blockNumber,\n    blockTag,\n    functionName: 'isValidSignature',\n  }).catch((error) => {\n    if (error instanceof ContractFunctionExecutionError)\n      throw new VerificationError()\n    throw error\n  })\n\n  if (result.startsWith('0x1626ba7e')) return true\n  throw new VerificationError()\n}\n\nexport namespace verifyErc1271 {\n  export type Parameters = Pick<CallParameters, 'blockNumber' | 'blockTag'> & {\n    /** The address that signed the original message. */\n    address: Address\n    /** The hash to be verified. */\n    hash: Hex\n    /** The signature that was generated by signing the message with the address's private key. */\n    signature: Hex\n  }\n}\n\nclass VerificationError extends Error {}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}