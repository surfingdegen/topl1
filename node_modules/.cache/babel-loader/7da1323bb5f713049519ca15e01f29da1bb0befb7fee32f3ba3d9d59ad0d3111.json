{"ast":null,"code":"import _objectSpread from \"/Users/mac/Desktop/topl1/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _wrapRegExp from \"/Users/mac/Desktop/topl1/frontend/node_modules/@babel/runtime/helpers/esm/wrapRegExp.js\";\nimport { execTyped, isTupleRegex } from '../../regex.js';\nimport { UnknownTypeError } from '../errors/abiItem.js';\nimport { InvalidAbiTypeParameterError } from '../errors/abiParameter.js';\nimport { InvalidSignatureError, InvalidStructSignatureError } from '../errors/signature.js';\nimport { CircularReferenceError } from '../errors/struct.js';\nimport { execStructSignature, isStructSignature } from './signatures.js';\nimport { isSolidityType, parseAbiParameter } from './utils.js';\nexport function parseStructs(signatures) {\n  // Create \"shallow\" version of each struct (and filter out non-structs or invalid structs)\n  const shallowStructs = {};\n  const signaturesLength = signatures.length;\n  for (let i = 0; i < signaturesLength; i++) {\n    const signature = signatures[i];\n    if (!isStructSignature(signature)) continue;\n    const match = execStructSignature(signature);\n    if (!match) throw new InvalidSignatureError({\n      signature,\n      type: 'struct'\n    });\n    const properties = match.properties.split(';');\n    const components = [];\n    const propertiesLength = properties.length;\n    for (let k = 0; k < propertiesLength; k++) {\n      const property = properties[k];\n      const trimmed = property.trim();\n      if (!trimmed) continue;\n      const abiParameter = parseAbiParameter(trimmed, {\n        type: 'struct'\n      });\n      components.push(abiParameter);\n    }\n    if (!components.length) throw new InvalidStructSignatureError({\n      signature\n    });\n    shallowStructs[match.name] = components;\n  }\n  // Resolve nested structs inside each parameter\n  const resolvedStructs = {};\n  const entries = Object.entries(shallowStructs);\n  const entriesLength = entries.length;\n  for (let i = 0; i < entriesLength; i++) {\n    const [name, parameters] = entries[i];\n    resolvedStructs[name] = resolveStructs(parameters, shallowStructs);\n  }\n  return resolvedStructs;\n}\nconst typeWithoutTupleRegex = /*#__PURE__*/_wrapRegExp(/^([a-zA-Z$_][a-zA-Z0-9$_]*)((?:\\[\\d*?\\])+?)?$/, {\n  type: 1,\n  array: 2\n});\nfunction resolveStructs() {\n  let abiParameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let structs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let ancestors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();\n  const components = [];\n  const length = abiParameters.length;\n  for (let i = 0; i < length; i++) {\n    const abiParameter = abiParameters[i];\n    const isTuple = isTupleRegex.test(abiParameter.type);\n    if (isTuple) components.push(abiParameter);else {\n      const match = execTyped(typeWithoutTupleRegex, abiParameter.type);\n      if (!(match !== null && match !== void 0 && match.type)) throw new InvalidAbiTypeParameterError({\n        abiParameter\n      });\n      const {\n        array,\n        type\n      } = match;\n      if (type in structs) {\n        if (ancestors.has(type)) throw new CircularReferenceError({\n          type\n        });\n        components.push(_objectSpread(_objectSpread({}, abiParameter), {}, {\n          type: \"tuple\".concat(array !== null && array !== void 0 ? array : ''),\n          components: resolveStructs(structs[type], structs, new Set([...ancestors, type]))\n        }));\n      } else {\n        if (isSolidityType(type)) components.push(abiParameter);else throw new UnknownTypeError({\n          type\n        });\n      }\n    }\n  }\n  return components;\n}","map":{"version":3,"names":["execTyped","isTupleRegex","UnknownTypeError","InvalidAbiTypeParameterError","InvalidSignatureError","InvalidStructSignatureError","CircularReferenceError","execStructSignature","isStructSignature","isSolidityType","parseAbiParameter","parseStructs","signatures","shallowStructs","signaturesLength","length","i","signature","match","type","properties","split","components","propertiesLength","k","property","trimmed","trim","abiParameter","push","name","resolvedStructs","entries","Object","entriesLength","parameters","resolveStructs","typeWithoutTupleRegex","_wrapRegExp","array","abiParameters","arguments","undefined","structs","ancestors","Set","isTuple","test","has","_objectSpread","concat"],"sources":["/Users/mac/Desktop/topl1/frontend/node_modules/abitype/src/human-readable/runtime/structs.ts"],"sourcesContent":["import type { AbiParameter } from '../../abi.js'\nimport { execTyped, isTupleRegex } from '../../regex.js'\nimport { UnknownTypeError } from '../errors/abiItem.js'\nimport { InvalidAbiTypeParameterError } from '../errors/abiParameter.js'\nimport {\n  InvalidSignatureError,\n  InvalidStructSignatureError,\n} from '../errors/signature.js'\nimport { CircularReferenceError } from '../errors/struct.js'\nimport type { StructLookup } from '../types/structs.js'\nimport { execStructSignature, isStructSignature } from './signatures.js'\nimport { isSolidityType, parseAbiParameter } from './utils.js'\n\nexport function parseStructs(signatures: readonly string[]) {\n  // Create \"shallow\" version of each struct (and filter out non-structs or invalid structs)\n  const shallowStructs: StructLookup = {}\n  const signaturesLength = signatures.length\n  for (let i = 0; i < signaturesLength; i++) {\n    const signature = signatures[i]!\n    if (!isStructSignature(signature)) continue\n\n    const match = execStructSignature(signature)\n    if (!match) throw new InvalidSignatureError({ signature, type: 'struct' })\n\n    const properties = match.properties.split(';')\n\n    const components: AbiParameter[] = []\n    const propertiesLength = properties.length\n    for (let k = 0; k < propertiesLength; k++) {\n      const property = properties[k]!\n      const trimmed = property.trim()\n      if (!trimmed) continue\n      const abiParameter = parseAbiParameter(trimmed, {\n        type: 'struct',\n      })\n      components.push(abiParameter)\n    }\n\n    if (!components.length) throw new InvalidStructSignatureError({ signature })\n    shallowStructs[match.name] = components\n  }\n\n  // Resolve nested structs inside each parameter\n  const resolvedStructs: StructLookup = {}\n  const entries = Object.entries(shallowStructs)\n  const entriesLength = entries.length\n  for (let i = 0; i < entriesLength; i++) {\n    const [name, parameters] = entries[i]!\n    resolvedStructs[name] = resolveStructs(parameters, shallowStructs)\n  }\n\n  return resolvedStructs\n}\n\nconst typeWithoutTupleRegex =\n  /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\\[\\d*?\\])+?)?$/\n\nfunction resolveStructs(\n  abiParameters: readonly (AbiParameter & { indexed?: true })[] = [],\n  structs: StructLookup = {},\n  ancestors = new Set<string>(),\n) {\n  const components: AbiParameter[] = []\n  const length = abiParameters.length\n  for (let i = 0; i < length; i++) {\n    const abiParameter = abiParameters[i]!\n    const isTuple = isTupleRegex.test(abiParameter.type)\n    if (isTuple) components.push(abiParameter)\n    else {\n      const match = execTyped<{ array?: string; type: string }>(\n        typeWithoutTupleRegex,\n        abiParameter.type,\n      )\n      if (!match?.type) throw new InvalidAbiTypeParameterError({ abiParameter })\n\n      const { array, type } = match\n      if (type in structs) {\n        if (ancestors.has(type)) throw new CircularReferenceError({ type })\n\n        components.push({\n          ...abiParameter,\n          type: `tuple${array ?? ''}`,\n          components: resolveStructs(\n            structs[type],\n            structs,\n            new Set([...ancestors, type]),\n          ),\n        })\n      } else {\n        if (isSolidityType(type)) components.push(abiParameter)\n        else throw new UnknownTypeError({ type })\n      }\n    }\n  }\n\n  return components\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}