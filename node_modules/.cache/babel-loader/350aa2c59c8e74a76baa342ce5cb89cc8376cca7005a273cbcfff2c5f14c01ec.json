{"ast":null,"code":"import { AbiDecodingDataSizeTooSmallError, AbiEventSignatureEmptyTopicsError, AbiEventSignatureNotFoundError, DecodeLogDataMismatch, DecodeLogTopicsMismatch } from '../../errors/abi.js';\nimport { PositionOutOfBoundsError } from '../../errors/cursor.js';\nimport { size } from '../data/size.js';\nimport { toEventSelector } from '../hash/toEventSelector.js';\nimport { decodeAbiParameters } from './decodeAbiParameters.js';\nimport { formatAbiItem } from './formatAbiItem.js';\nconst docsPath = '/docs/contract/decodeEventLog';\nexport function decodeEventLog(parameters) {\n  const {\n    abi,\n    data,\n    strict: strict_,\n    topics\n  } = parameters;\n  const strict = strict_ ?? true;\n  const [signature, ...argTopics] = topics;\n  if (!signature) throw new AbiEventSignatureEmptyTopicsError({\n    docsPath\n  });\n  const abiItem = abi.find(x => x.type === 'event' && signature === toEventSelector(formatAbiItem(x)));\n  if (!(abiItem && 'name' in abiItem) || abiItem.type !== 'event') throw new AbiEventSignatureNotFoundError(signature, {\n    docsPath\n  });\n  const {\n    name,\n    inputs\n  } = abiItem;\n  const isUnnamed = inputs?.some(x => !('name' in x && x.name));\n  const args = isUnnamed ? [] : {};\n  // Decode topics (indexed args).\n  const indexedInputs = inputs.map((x, i) => [x, i]).filter(([x]) => 'indexed' in x && x.indexed);\n  const missingIndexedInputs = [];\n  for (let i = 0; i < indexedInputs.length; i++) {\n    const [param, argIndex] = indexedInputs[i];\n    const topic = argTopics[i];\n    if (!topic) {\n      if (strict) throw new DecodeLogTopicsMismatch({\n        abiItem,\n        param: param\n      });\n      // Track missing indexed inputs to decode from data when strict is false\n      missingIndexedInputs.push([param, argIndex]);\n      continue;\n    }\n    args[isUnnamed ? argIndex : param.name || argIndex] = decodeTopic({\n      param,\n      value: topic\n    });\n  }\n  // Decode data (non-indexed args + missing indexed args when strict is false).\n  const nonIndexedInputs = inputs.filter(x => !('indexed' in x && x.indexed));\n  // When strict is false, missing indexed inputs should be decoded from data\n  const inputsToDecode = strict ? nonIndexedInputs : [...missingIndexedInputs.map(([param]) => param), ...nonIndexedInputs];\n  if (inputsToDecode.length > 0) {\n    if (data && data !== '0x') {\n      try {\n        const decodedData = decodeAbiParameters(inputsToDecode, data);\n        if (decodedData) {\n          let dataIndex = 0;\n          // First, assign missing indexed parameters (when strict is false)\n          if (!strict) {\n            for (const [param, argIndex] of missingIndexedInputs) {\n              args[isUnnamed ? argIndex : param.name || argIndex] = decodedData[dataIndex++];\n            }\n          }\n          // Then, assign non-indexed parameters\n          if (isUnnamed) {\n            for (let i = 0; i < inputs.length; i++) if (args[i] === undefined && dataIndex < decodedData.length) args[i] = decodedData[dataIndex++];\n          } else for (let i = 0; i < nonIndexedInputs.length; i++) args[nonIndexedInputs[i].name] = decodedData[dataIndex++];\n        }\n      } catch (err) {\n        if (strict) {\n          if (err instanceof AbiDecodingDataSizeTooSmallError || err instanceof PositionOutOfBoundsError) throw new DecodeLogDataMismatch({\n            abiItem,\n            data: data,\n            params: inputsToDecode,\n            size: size(data)\n          });\n          throw err;\n        }\n      }\n    } else if (strict) {\n      throw new DecodeLogDataMismatch({\n        abiItem,\n        data: '0x',\n        params: inputsToDecode,\n        size: 0\n      });\n    }\n  }\n  return {\n    eventName: name,\n    args: Object.values(args).length > 0 ? args : undefined\n  };\n}\nfunction decodeTopic({\n  param,\n  value\n}) {\n  if (param.type === 'string' || param.type === 'bytes' || param.type === 'tuple' || param.type.match(/^(.*)\\[(\\d+)?\\]$/)) return value;\n  const decodedArg = decodeAbiParameters([param], value) || [];\n  return decodedArg[0];\n}","map":{"version":3,"names":["AbiDecodingDataSizeTooSmallError","AbiEventSignatureEmptyTopicsError","AbiEventSignatureNotFoundError","DecodeLogDataMismatch","DecodeLogTopicsMismatch","PositionOutOfBoundsError","size","toEventSelector","decodeAbiParameters","formatAbiItem","docsPath","decodeEventLog","parameters","abi","data","strict","strict_","topics","signature","argTopics","abiItem","find","x","type","name","inputs","isUnnamed","some","args","indexedInputs","map","i","filter","indexed","missingIndexedInputs","length","param","argIndex","topic","push","decodeTopic","value","nonIndexedInputs","inputsToDecode","decodedData","dataIndex","undefined","err","params","eventName","Object","values","match","decodedArg"],"sources":["/Users/mac/Desktop/topl1/frontend/node_modules/viem/utils/abi/decodeEventLog.ts"],"sourcesContent":["import type { Abi, AbiParameter } from 'abitype'\n\nimport {\n  AbiDecodingDataSizeTooSmallError,\n  type AbiDecodingDataSizeTooSmallErrorType,\n  AbiEventSignatureEmptyTopicsError,\n  type AbiEventSignatureEmptyTopicsErrorType,\n  AbiEventSignatureNotFoundError,\n  type AbiEventSignatureNotFoundErrorType,\n  DecodeLogDataMismatch,\n  type DecodeLogDataMismatchErrorType,\n  DecodeLogTopicsMismatch,\n  type DecodeLogTopicsMismatchErrorType,\n} from '../../errors/abi.js'\nimport { PositionOutOfBoundsError } from '../../errors/cursor.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  ContractEventArgsFromTopics,\n  ContractEventName,\n  EventDefinition,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type {\n  IsNarrowable,\n  Prettify,\n  UnionEvaluate,\n} from '../../types/utils.js'\nimport { size } from '../data/size.js'\nimport {\n  type ToEventSelectorErrorType,\n  toEventSelector,\n} from '../hash/toEventSelector.js'\nimport {\n  type DecodeAbiParametersErrorType,\n  decodeAbiParameters,\n} from './decodeAbiParameters.js'\nimport { type FormatAbiItemErrorType, formatAbiItem } from './formatAbiItem.js'\n\nexport type DecodeEventLogParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends ContractEventName<abi> | undefined = ContractEventName<abi>,\n  topics extends Hex[] = Hex[],\n  data extends Hex | undefined = undefined,\n  strict extends boolean = true,\n> = {\n  abi: abi\n  data?: data | undefined\n  eventName?: eventName | ContractEventName<abi> | undefined\n  strict?: strict | boolean | undefined\n  topics: [signature: Hex, ...args: topics] | []\n}\n\nexport type DecodeEventLogReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends ContractEventName<abi> | undefined = ContractEventName<abi>,\n  topics extends Hex[] = Hex[],\n  data extends Hex | undefined = undefined,\n  strict extends boolean = true,\n  ///\n  allEventNames extends\n    ContractEventName<abi> = eventName extends ContractEventName<abi>\n    ? eventName\n    : ContractEventName<abi>,\n> = IsNarrowable<abi, Abi> extends true\n  ? {\n      [name in allEventNames]: Prettify<\n        {\n          eventName: name\n        } & UnionEvaluate<\n          ContractEventArgsFromTopics<abi, name, strict> extends infer allArgs\n            ? topics extends readonly []\n              ? data extends undefined\n                ? { args?: undefined }\n                : { args?: allArgs | undefined }\n              : { args: allArgs }\n            : never\n        >\n      >\n    }[allEventNames]\n  : {\n      eventName: eventName\n      args: readonly unknown[] | undefined\n    }\n\nexport type DecodeEventLogErrorType =\n  | AbiDecodingDataSizeTooSmallErrorType\n  | AbiEventSignatureEmptyTopicsErrorType\n  | AbiEventSignatureNotFoundErrorType\n  | DecodeAbiParametersErrorType\n  | DecodeLogTopicsMismatchErrorType\n  | DecodeLogDataMismatchErrorType\n  | FormatAbiItemErrorType\n  | ToEventSelectorErrorType\n  | ErrorType\n\nconst docsPath = '/docs/contract/decodeEventLog'\n\nexport function decodeEventLog<\n  const abi extends Abi | readonly unknown[],\n  eventName extends ContractEventName<abi> | undefined = undefined,\n  topics extends Hex[] = Hex[],\n  data extends Hex | undefined = undefined,\n  strict extends boolean = true,\n>(\n  parameters: DecodeEventLogParameters<abi, eventName, topics, data, strict>,\n): DecodeEventLogReturnType<abi, eventName, topics, data, strict> {\n  const {\n    abi,\n    data,\n    strict: strict_,\n    topics,\n  } = parameters as DecodeEventLogParameters\n\n  const strict = strict_ ?? true\n  const [signature, ...argTopics] = topics\n  if (!signature) throw new AbiEventSignatureEmptyTopicsError({ docsPath })\n\n  const abiItem = abi.find(\n    (x) =>\n      x.type === 'event' &&\n      signature === toEventSelector(formatAbiItem(x) as EventDefinition),\n  )\n\n  if (!(abiItem && 'name' in abiItem) || abiItem.type !== 'event')\n    throw new AbiEventSignatureNotFoundError(signature, { docsPath })\n\n  const { name, inputs } = abiItem\n  const isUnnamed = inputs?.some((x) => !('name' in x && x.name))\n\n  const args: any = isUnnamed ? [] : {}\n\n  // Decode topics (indexed args).\n  const indexedInputs = inputs\n    .map((x, i) => [x, i] as const)\n    .filter(([x]) => 'indexed' in x && x.indexed)\n\n  const missingIndexedInputs: [AbiParameter, number][] = []\n\n  for (let i = 0; i < indexedInputs.length; i++) {\n    const [param, argIndex] = indexedInputs[i]\n    const topic = argTopics[i]\n    if (!topic) {\n      if (strict)\n        throw new DecodeLogTopicsMismatch({\n          abiItem,\n          param: param as AbiParameter & { indexed: boolean },\n        })\n      // Track missing indexed inputs to decode from data when strict is false\n      missingIndexedInputs.push([param, argIndex])\n      continue\n    }\n    args[isUnnamed ? argIndex : param.name || argIndex] = decodeTopic({\n      param,\n      value: topic,\n    })\n  }\n\n  // Decode data (non-indexed args + missing indexed args when strict is false).\n  const nonIndexedInputs = inputs.filter((x) => !('indexed' in x && x.indexed))\n\n  // When strict is false, missing indexed inputs should be decoded from data\n  const inputsToDecode = strict\n    ? nonIndexedInputs\n    : [...missingIndexedInputs.map(([param]) => param), ...nonIndexedInputs]\n\n  if (inputsToDecode.length > 0) {\n    if (data && data !== '0x') {\n      try {\n        const decodedData = decodeAbiParameters(\n          inputsToDecode,\n          data,\n        ) as unknown[]\n        if (decodedData) {\n          let dataIndex = 0\n          // First, assign missing indexed parameters (when strict is false)\n          if (!strict) {\n            for (const [param, argIndex] of missingIndexedInputs) {\n              args[isUnnamed ? argIndex : param.name || argIndex] =\n                decodedData[dataIndex++]\n            }\n          }\n          // Then, assign non-indexed parameters\n          if (isUnnamed) {\n            for (let i = 0; i < inputs.length; i++)\n              if (args[i] === undefined && dataIndex < decodedData.length)\n                args[i] = decodedData[dataIndex++]\n          } else\n            for (let i = 0; i < nonIndexedInputs.length; i++)\n              args[nonIndexedInputs[i].name!] = decodedData[dataIndex++]\n        }\n      } catch (err) {\n        if (strict) {\n          if (\n            err instanceof AbiDecodingDataSizeTooSmallError ||\n            err instanceof PositionOutOfBoundsError\n          )\n            throw new DecodeLogDataMismatch({\n              abiItem,\n              data: data,\n              params: inputsToDecode,\n              size: size(data),\n            })\n          throw err\n        }\n      }\n    } else if (strict) {\n      throw new DecodeLogDataMismatch({\n        abiItem,\n        data: '0x',\n        params: inputsToDecode,\n        size: 0,\n      })\n    }\n  }\n\n  return {\n    eventName: name,\n    args: Object.values(args).length > 0 ? args : undefined,\n  } as unknown as DecodeEventLogReturnType<abi, eventName, topics, data, strict>\n}\n\nfunction decodeTopic({ param, value }: { param: AbiParameter; value: Hex }) {\n  if (\n    param.type === 'string' ||\n    param.type === 'bytes' ||\n    param.type === 'tuple' ||\n    param.type.match(/^(.*)\\[(\\d+)?\\]$/)\n  )\n    return value\n  const decodedArg = decodeAbiParameters([param], value) || []\n  return decodedArg[0]\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}