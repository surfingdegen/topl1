{"ast":null,"code":"import { multicall3Abi } from '../../constants/abis.js';\nimport { multicall3Bytecode } from '../../constants/contracts.js';\nimport { AbiDecodingZeroDataError } from '../../errors/abi.js';\nimport { BaseError } from '../../errors/base.js';\nimport { RawContractError } from '../../errors/contract.js';\nimport { decodeFunctionResult } from '../../utils/abi/decodeFunctionResult.js';\nimport { encodeFunctionData } from '../../utils/abi/encodeFunctionData.js';\nimport { getChainContractAddress } from '../../utils/chain/getChainContractAddress.js';\nimport { getContractError } from '../../utils/errors/getContractError.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { readContract } from './readContract.js';\n/**\n * Similar to [`readContract`](https://viem.sh/docs/contract/readContract), but batches up multiple functions on a contract in a single RPC call via the [`multicall3` contract](https://github.com/mds1/multicall).\n *\n * - Docs: https://viem.sh/docs/contract/multicall\n *\n * @param client - Client to use\n * @param parameters - {@link MulticallParameters}\n * @returns An array of results with accompanying status. {@link MulticallReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { multicall } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const abi = parseAbi([\n *   'function balanceOf(address) view returns (uint256)',\n *   'function totalSupply() view returns (uint256)',\n * ])\n * const results = await multicall(client, {\n *   contracts: [\n *     {\n *       address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *       abi,\n *       functionName: 'balanceOf',\n *       args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n *     },\n *     {\n *       address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *       abi,\n *       functionName: 'totalSupply',\n *     },\n *   ],\n * })\n * // [{ result: 424122n, status: 'success' }, { result: 1000000n, status: 'success' }]\n */\nexport async function multicall(client, parameters) {\n  const {\n    account,\n    authorizationList,\n    allowFailure = true,\n    blockNumber,\n    blockOverrides,\n    blockTag,\n    stateOverride\n  } = parameters;\n  const contracts = parameters.contracts;\n  const {\n    batchSize = parameters.batchSize ?? 1024,\n    deployless = parameters.deployless ?? false\n  } = typeof client.batch?.multicall === 'object' ? client.batch.multicall : {};\n  const multicallAddress = (() => {\n    if (parameters.multicallAddress) return parameters.multicallAddress;\n    if (deployless) return null;\n    if (client.chain) {\n      return getChainContractAddress({\n        blockNumber,\n        chain: client.chain,\n        contract: 'multicall3'\n      });\n    }\n    throw new Error('client chain not configured. multicallAddress is required.');\n  })();\n  const chunkedCalls = [[]];\n  let currentChunk = 0;\n  let currentChunkSize = 0;\n  for (let i = 0; i < contracts.length; i++) {\n    const {\n      abi,\n      address,\n      args,\n      functionName\n    } = contracts[i];\n    try {\n      const callData = encodeFunctionData({\n        abi,\n        args,\n        functionName\n      });\n      currentChunkSize += (callData.length - 2) / 2;\n      // Check to see if we need to create a new chunk.\n      if (\n      // Check if batching is enabled.\n      batchSize > 0 &&\n      // Check if the current size of the batch exceeds the size limit.\n      currentChunkSize > batchSize &&\n      // Check if the current chunk is not already empty.\n      chunkedCalls[currentChunk].length > 0) {\n        currentChunk++;\n        currentChunkSize = (callData.length - 2) / 2;\n        chunkedCalls[currentChunk] = [];\n      }\n      chunkedCalls[currentChunk] = [...chunkedCalls[currentChunk], {\n        allowFailure: true,\n        callData,\n        target: address\n      }];\n    } catch (err) {\n      const error = getContractError(err, {\n        abi,\n        address,\n        args,\n        docsPath: '/docs/contract/multicall',\n        functionName,\n        sender: account\n      });\n      if (!allowFailure) throw error;\n      chunkedCalls[currentChunk] = [...chunkedCalls[currentChunk], {\n        allowFailure: true,\n        callData: '0x',\n        target: address\n      }];\n    }\n  }\n  const aggregate3Results = await Promise.allSettled(chunkedCalls.map(calls => getAction(client, readContract, 'readContract')({\n    ...(multicallAddress === null ? {\n      code: multicall3Bytecode\n    } : {\n      address: multicallAddress\n    }),\n    abi: multicall3Abi,\n    account,\n    args: [calls],\n    authorizationList,\n    blockNumber,\n    blockOverrides,\n    blockTag,\n    functionName: 'aggregate3',\n    stateOverride\n  })));\n  const results = [];\n  for (let i = 0; i < aggregate3Results.length; i++) {\n    const result = aggregate3Results[i];\n    // If an error occurred in a `readContract` invocation (ie. network error),\n    // then append the failure reason to each contract result.\n    if (result.status === 'rejected') {\n      if (!allowFailure) throw result.reason;\n      for (let j = 0; j < chunkedCalls[i].length; j++) {\n        results.push({\n          status: 'failure',\n          error: result.reason,\n          result: undefined\n        });\n      }\n      continue;\n    }\n    // If the `readContract` call was successful, then decode the results.\n    const aggregate3Result = result.value;\n    for (let j = 0; j < aggregate3Result.length; j++) {\n      // Extract the response from `readContract`\n      const {\n        returnData,\n        success\n      } = aggregate3Result[j];\n      // Extract the request call data from the original call.\n      const {\n        callData\n      } = chunkedCalls[i][j];\n      // Extract the contract config for this call from the `contracts` argument\n      // for decoding.\n      const {\n        abi,\n        address,\n        functionName,\n        args\n      } = contracts[results.length];\n      try {\n        if (callData === '0x') throw new AbiDecodingZeroDataError();\n        if (!success) throw new RawContractError({\n          data: returnData\n        });\n        const result = decodeFunctionResult({\n          abi,\n          args,\n          data: returnData,\n          functionName\n        });\n        results.push(allowFailure ? {\n          result,\n          status: 'success'\n        } : result);\n      } catch (err) {\n        const error = getContractError(err, {\n          abi,\n          address,\n          args,\n          docsPath: '/docs/contract/multicall',\n          functionName\n        });\n        if (!allowFailure) throw error;\n        results.push({\n          error,\n          result: undefined,\n          status: 'failure'\n        });\n      }\n    }\n  }\n  if (results.length !== contracts.length) throw new BaseError('multicall results mismatch');\n  return results;\n}","map":{"version":3,"names":["multicall3Abi","multicall3Bytecode","AbiDecodingZeroDataError","BaseError","RawContractError","decodeFunctionResult","encodeFunctionData","getChainContractAddress","getContractError","getAction","readContract","multicall","client","parameters","account","authorizationList","allowFailure","blockNumber","blockOverrides","blockTag","stateOverride","contracts","batchSize","deployless","batch","multicallAddress","chain","contract","Error","chunkedCalls","currentChunk","currentChunkSize","i","length","abi","address","args","functionName","callData","target","err","error","docsPath","sender","aggregate3Results","Promise","allSettled","map","calls","code","results","result","status","reason","j","push","undefined","aggregate3Result","value","returnData","success","data"],"sources":["/Users/mac/Desktop/topl1/frontend/node_modules/viem/actions/public/multicall.ts"],"sourcesContent":["import type { AbiStateMutability, Address, Narrow } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { multicall3Abi } from '../../constants/abis.js'\nimport { multicall3Bytecode } from '../../constants/contracts.js'\nimport { AbiDecodingZeroDataError } from '../../errors/abi.js'\nimport { BaseError } from '../../errors/base.js'\nimport { RawContractError } from '../../errors/contract.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { ContractFunctionParameters } from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type {\n  MulticallContracts,\n  MulticallResults,\n} from '../../types/multicall.js'\nimport {\n  type DecodeFunctionResultErrorType,\n  decodeFunctionResult,\n} from '../../utils/abi/decodeFunctionResult.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  encodeFunctionData,\n} from '../../utils/abi/encodeFunctionData.js'\nimport {\n  type GetChainContractAddressErrorType,\n  getChainContractAddress,\n} from '../../utils/chain/getChainContractAddress.js'\nimport {\n  type GetContractErrorReturnType,\n  getContractError,\n} from '../../utils/errors/getContractError.js'\nimport { getAction } from '../../utils/getAction.js'\nimport type { CallParameters } from './call.js'\nimport { type ReadContractErrorType, readContract } from './readContract.js'\n\nexport type MulticallParameters<\n  contracts extends readonly unknown[] = readonly ContractFunctionParameters[],\n  allowFailure extends boolean = true,\n  options extends {\n    optional?: boolean\n    properties?: Record<string, any>\n  } = {},\n> = Pick<\n  CallParameters,\n  | 'authorizationList'\n  | 'blockNumber'\n  | 'blockOverrides'\n  | 'blockTag'\n  | 'stateOverride'\n> & {\n  /** The account to use for the multicall. */\n  account?: Address | undefined\n  /** Whether to allow failures. */\n  allowFailure?: allowFailure | boolean | undefined\n  /** The size of each batch of calls. */\n  batchSize?: number | undefined\n  /** Enable deployless multicall. */\n  deployless?: boolean | undefined\n  /** The contracts to call. */\n  contracts: MulticallContracts<\n    Narrow<contracts>,\n    { mutability: AbiStateMutability } & options\n  >\n  /** The address of the multicall3 contract to use. */\n  multicallAddress?: Address | undefined\n}\n\nexport type MulticallReturnType<\n  contracts extends readonly unknown[] = readonly ContractFunctionParameters[],\n  allowFailure extends boolean = true,\n  options extends {\n    error?: Error\n  } = { error: Error },\n> = MulticallResults<\n  Narrow<contracts>,\n  allowFailure,\n  { mutability: AbiStateMutability } & options\n>\n\nexport type MulticallErrorType =\n  | GetChainContractAddressErrorType\n  | ReadContractErrorType\n  | GetContractErrorReturnType<\n      EncodeFunctionDataErrorType | DecodeFunctionResultErrorType\n    >\n  | ErrorType\n\n/**\n * Similar to [`readContract`](https://viem.sh/docs/contract/readContract), but batches up multiple functions on a contract in a single RPC call via the [`multicall3` contract](https://github.com/mds1/multicall).\n *\n * - Docs: https://viem.sh/docs/contract/multicall\n *\n * @param client - Client to use\n * @param parameters - {@link MulticallParameters}\n * @returns An array of results with accompanying status. {@link MulticallReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { multicall } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const abi = parseAbi([\n *   'function balanceOf(address) view returns (uint256)',\n *   'function totalSupply() view returns (uint256)',\n * ])\n * const results = await multicall(client, {\n *   contracts: [\n *     {\n *       address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *       abi,\n *       functionName: 'balanceOf',\n *       args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n *     },\n *     {\n *       address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *       abi,\n *       functionName: 'totalSupply',\n *     },\n *   ],\n * })\n * // [{ result: 424122n, status: 'success' }, { result: 1000000n, status: 'success' }]\n */\nexport async function multicall<\n  const contracts extends readonly unknown[],\n  chain extends Chain | undefined,\n  allowFailure extends boolean = true,\n>(\n  client: Client<Transport, chain>,\n  parameters: MulticallParameters<contracts, allowFailure>,\n): Promise<MulticallReturnType<contracts, allowFailure>> {\n  const {\n    account,\n    authorizationList,\n    allowFailure = true,\n    blockNumber,\n    blockOverrides,\n    blockTag,\n    stateOverride,\n  } = parameters\n  const contracts = parameters.contracts as ContractFunctionParameters[]\n\n  const {\n    batchSize = parameters.batchSize ?? 1024,\n    deployless = parameters.deployless ?? false,\n  } = typeof client.batch?.multicall === 'object' ? client.batch.multicall : {}\n\n  const multicallAddress = (() => {\n    if (parameters.multicallAddress) return parameters.multicallAddress\n    if (deployless) return null\n    if (client.chain) {\n      return getChainContractAddress({\n        blockNumber,\n        chain: client.chain,\n        contract: 'multicall3',\n      })\n    }\n    throw new Error(\n      'client chain not configured. multicallAddress is required.',\n    )\n  })()\n\n  type Aggregate3Calls = {\n    allowFailure: boolean\n    callData: Hex\n    target: Address\n  }[]\n\n  const chunkedCalls: Aggregate3Calls[] = [[]]\n  let currentChunk = 0\n  let currentChunkSize = 0\n  for (let i = 0; i < contracts.length; i++) {\n    const { abi, address, args, functionName } = contracts[i]\n    try {\n      const callData = encodeFunctionData({ abi, args, functionName })\n\n      currentChunkSize += (callData.length - 2) / 2\n      // Check to see if we need to create a new chunk.\n      if (\n        // Check if batching is enabled.\n        batchSize > 0 &&\n        // Check if the current size of the batch exceeds the size limit.\n        currentChunkSize > batchSize &&\n        // Check if the current chunk is not already empty.\n        chunkedCalls[currentChunk].length > 0\n      ) {\n        currentChunk++\n        currentChunkSize = (callData.length - 2) / 2\n        chunkedCalls[currentChunk] = []\n      }\n\n      chunkedCalls[currentChunk] = [\n        ...chunkedCalls[currentChunk],\n        {\n          allowFailure: true,\n          callData,\n          target: address,\n        },\n      ]\n    } catch (err) {\n      const error = getContractError(err as BaseError, {\n        abi,\n        address,\n        args,\n        docsPath: '/docs/contract/multicall',\n        functionName,\n        sender: account,\n      })\n      if (!allowFailure) throw error\n      chunkedCalls[currentChunk] = [\n        ...chunkedCalls[currentChunk],\n        {\n          allowFailure: true,\n          callData: '0x' as Hex,\n          target: address,\n        },\n      ]\n    }\n  }\n\n  const aggregate3Results = await Promise.allSettled(\n    chunkedCalls.map((calls) =>\n      getAction(\n        client,\n        readContract,\n        'readContract',\n      )({\n        ...(multicallAddress === null\n          ? { code: multicall3Bytecode }\n          : { address: multicallAddress }),\n        abi: multicall3Abi,\n        account,\n        args: [calls],\n        authorizationList,\n        blockNumber,\n        blockOverrides,\n        blockTag,\n        functionName: 'aggregate3',\n        stateOverride,\n      }),\n    ),\n  )\n\n  const results = []\n  for (let i = 0; i < aggregate3Results.length; i++) {\n    const result = aggregate3Results[i]\n\n    // If an error occurred in a `readContract` invocation (ie. network error),\n    // then append the failure reason to each contract result.\n    if (result.status === 'rejected') {\n      if (!allowFailure) throw result.reason\n      for (let j = 0; j < chunkedCalls[i].length; j++) {\n        results.push({\n          status: 'failure',\n          error: result.reason,\n          result: undefined,\n        })\n      }\n      continue\n    }\n\n    // If the `readContract` call was successful, then decode the results.\n    const aggregate3Result = result.value\n    for (let j = 0; j < aggregate3Result.length; j++) {\n      // Extract the response from `readContract`\n      const { returnData, success } = aggregate3Result[j]\n\n      // Extract the request call data from the original call.\n      const { callData } = chunkedCalls[i][j]\n\n      // Extract the contract config for this call from the `contracts` argument\n      // for decoding.\n      const { abi, address, functionName, args } = contracts[\n        results.length\n      ] as ContractFunctionParameters\n\n      try {\n        if (callData === '0x') throw new AbiDecodingZeroDataError()\n        if (!success) throw new RawContractError({ data: returnData })\n        const result = decodeFunctionResult({\n          abi,\n          args,\n          data: returnData,\n          functionName,\n        })\n        results.push(allowFailure ? { result, status: 'success' } : result)\n      } catch (err) {\n        const error = getContractError(err as BaseError, {\n          abi,\n          address,\n          args,\n          docsPath: '/docs/contract/multicall',\n          functionName,\n        })\n        if (!allowFailure) throw error\n        results.push({ error, result: undefined, status: 'failure' })\n      }\n    }\n  }\n\n  if (results.length !== contracts.length)\n    throw new BaseError('multicall results mismatch')\n  return results as MulticallReturnType<contracts, allowFailure>\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}