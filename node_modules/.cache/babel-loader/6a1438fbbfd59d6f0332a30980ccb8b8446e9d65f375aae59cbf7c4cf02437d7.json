{"ast":null,"code":"import _objectSpread from \"/Users/mac/Desktop/topl1/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport * as AbiParameters from '../AbiParameters.js';\nimport * as Address from '../Address.js';\nimport * as Bytes from '../Bytes.js';\nimport * as Errors from '../Errors.js';\nimport * as Hex from '../Hex.js';\nimport { integerRegex } from '../Solidity.js';\n/** @internal */\nexport function decodeParameter(cursor, param, options) {\n  const {\n    checksumAddress,\n    staticPosition\n  } = options;\n  const arrayComponents = getArrayComponents(param.type);\n  if (arrayComponents) {\n    const [length, type] = arrayComponents;\n    return decodeArray(cursor, _objectSpread(_objectSpread({}, param), {}, {\n      type\n    }), {\n      checksumAddress,\n      length,\n      staticPosition\n    });\n  }\n  if (param.type === 'tuple') return decodeTuple(cursor, param, {\n    checksumAddress,\n    staticPosition\n  });\n  if (param.type === 'address') return decodeAddress(cursor, {\n    checksum: checksumAddress\n  });\n  if (param.type === 'bool') return decodeBool(cursor);\n  if (param.type.startsWith('bytes')) return decodeBytes(cursor, param, {\n    staticPosition\n  });\n  if (param.type.startsWith('uint') || param.type.startsWith('int')) return decodeNumber(cursor, param);\n  if (param.type === 'string') return decodeString(cursor, {\n    staticPosition\n  });\n  throw new AbiParameters.InvalidTypeError(param.type);\n}\nconst sizeOfLength = 32;\nconst sizeOfOffset = 32;\n/** @internal */\nexport function decodeAddress(cursor) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    checksum = false\n  } = options;\n  const value = cursor.readBytes(32);\n  const wrap = address => checksum ? Address.checksum(address) : address;\n  return [wrap(Hex.fromBytes(Bytes.slice(value, -20))), 32];\n}\n/** @internal */\nexport function decodeArray(cursor, param, options) {\n  const {\n    checksumAddress,\n    length,\n    staticPosition\n  } = options;\n  // If the length of the array is not known in advance (dynamic array),\n  // this means we will need to wonder off to the pointer and decode.\n  if (!length) {\n    // Dealing with a dynamic type, so get the offset of the array data.\n    const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset));\n    // Start is the static position of current slot + offset.\n    const start = staticPosition + offset;\n    const startOfData = start + sizeOfLength;\n    // Get the length of the array from the offset.\n    cursor.setPosition(start);\n    const length = Bytes.toNumber(cursor.readBytes(sizeOfLength));\n    // Check if the array has any dynamic children.\n    const dynamicChild = hasDynamicChild(param);\n    let consumed = 0;\n    const value = [];\n    for (let i = 0; i < length; ++i) {\n      // If any of the children is dynamic, then all elements will be offset pointer, thus size of one slot (32 bytes).\n      // Otherwise, elements will be the size of their encoding (consumed bytes).\n      cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed));\n      const [data, consumed_] = decodeParameter(cursor, param, {\n        checksumAddress,\n        staticPosition: startOfData\n      });\n      consumed += consumed_;\n      value.push(data);\n    }\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32);\n    return [value, 32];\n  }\n  // If the length of the array is known in advance,\n  // and the length of an element deeply nested in the array is not known,\n  // we need to decode the offset of the array data.\n  if (hasDynamicChild(param)) {\n    // Dealing with dynamic types, so get the offset of the array data.\n    const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset));\n    // Start is the static position of current slot + offset.\n    const start = staticPosition + offset;\n    const value = [];\n    for (let i = 0; i < length; ++i) {\n      // Move cursor along to the next slot (next offset pointer).\n      cursor.setPosition(start + i * 32);\n      const [data] = decodeParameter(cursor, param, {\n        checksumAddress,\n        staticPosition: start\n      });\n      value.push(data);\n    }\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32);\n    return [value, 32];\n  }\n  // If the length of the array is known in advance and the array is deeply static,\n  // then we can just decode each element in sequence.\n  let consumed = 0;\n  const value = [];\n  for (let i = 0; i < length; ++i) {\n    const [data, consumed_] = decodeParameter(cursor, param, {\n      checksumAddress,\n      staticPosition: staticPosition + consumed\n    });\n    consumed += consumed_;\n    value.push(data);\n  }\n  return [value, consumed];\n}\n/** @internal */\nexport function decodeBool(cursor) {\n  return [Bytes.toBoolean(cursor.readBytes(32), {\n    size: 32\n  }), 32];\n}\n/** @internal */\nexport function decodeBytes(cursor, param, _ref) {\n  let {\n    staticPosition\n  } = _ref;\n  const [_, size] = param.type.split('bytes');\n  if (!size) {\n    // Dealing with dynamic types, so get the offset of the bytes data.\n    const offset = Bytes.toNumber(cursor.readBytes(32));\n    // Set position of the cursor to start of bytes data.\n    cursor.setPosition(staticPosition + offset);\n    const length = Bytes.toNumber(cursor.readBytes(32));\n    // If there is no length, we have zero data.\n    if (length === 0) {\n      // As we have gone wondering, restore to the original position + next slot.\n      cursor.setPosition(staticPosition + 32);\n      return ['0x', 32];\n    }\n    const data = cursor.readBytes(length);\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32);\n    return [Hex.fromBytes(data), 32];\n  }\n  const value = Hex.fromBytes(cursor.readBytes(Number.parseInt(size, 10), 32));\n  return [value, 32];\n}\n/** @internal */\nexport function decodeNumber(cursor, param) {\n  const signed = param.type.startsWith('int');\n  const size = Number.parseInt(param.type.split('int')[1] || '256', 10);\n  const value = cursor.readBytes(32);\n  return [size > 48 ? Bytes.toBigInt(value, {\n    signed\n  }) : Bytes.toNumber(value, {\n    signed\n  }), 32];\n}\n/** @internal */\nexport function decodeTuple(cursor, param, options) {\n  const {\n    checksumAddress,\n    staticPosition\n  } = options;\n  // Tuples can have unnamed components (i.e. they are arrays), so we must\n  // determine whether the tuple is named or unnamed. In the case of a named\n  // tuple, the value will be an object where each property is the name of the\n  // component. In the case of an unnamed tuple, the value will be an array.\n  const hasUnnamedChild = param.components.length === 0 || param.components.some(_ref2 => {\n    let {\n      name\n    } = _ref2;\n    return !name;\n  });\n  // Initialize the value to an object or an array, depending on whether the\n  // tuple is named or unnamed.\n  const value = hasUnnamedChild ? [] : {};\n  let consumed = 0;\n  // If the tuple has a dynamic child, we must first decode the offset to the\n  // tuple data.\n  if (hasDynamicChild(param)) {\n    // Dealing with dynamic types, so get the offset of the tuple data.\n    const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset));\n    // Start is the static position of referencing slot + offset.\n    const start = staticPosition + offset;\n    for (let i = 0; i < param.components.length; ++i) {\n      const component = param.components[i];\n      cursor.setPosition(start + consumed);\n      const [data, consumed_] = decodeParameter(cursor, component, {\n        checksumAddress,\n        staticPosition: start\n      });\n      consumed += consumed_;\n      value[hasUnnamedChild ? i : component === null || component === void 0 ? void 0 : component.name] = data;\n    }\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32);\n    return [value, 32];\n  }\n  // If the tuple has static children, we can just decode each component\n  // in sequence.\n  for (let i = 0; i < param.components.length; ++i) {\n    const component = param.components[i];\n    const [data, consumed_] = decodeParameter(cursor, component, {\n      checksumAddress,\n      staticPosition\n    });\n    value[hasUnnamedChild ? i : component === null || component === void 0 ? void 0 : component.name] = data;\n    consumed += consumed_;\n  }\n  return [value, consumed];\n}\n/** @internal */\nexport function decodeString(cursor, _ref3) {\n  let {\n    staticPosition\n  } = _ref3;\n  // Get offset to start of string data.\n  const offset = Bytes.toNumber(cursor.readBytes(32));\n  // Start is the static position of current slot + offset.\n  const start = staticPosition + offset;\n  cursor.setPosition(start);\n  const length = Bytes.toNumber(cursor.readBytes(32));\n  // If there is no length, we have zero data (empty string).\n  if (length === 0) {\n    cursor.setPosition(staticPosition + 32);\n    return ['', 32];\n  }\n  const data = cursor.readBytes(length, 32);\n  const value = Bytes.toString(Bytes.trimLeft(data));\n  // As we have gone wondering, restore to the original position + next slot.\n  cursor.setPosition(staticPosition + 32);\n  return [value, 32];\n}\n/** @internal */\nexport function prepareParameters(_ref4) {\n  let {\n    checksumAddress,\n    parameters,\n    values\n  } = _ref4;\n  const preparedParameters = [];\n  for (let i = 0; i < parameters.length; i++) {\n    preparedParameters.push(prepareParameter({\n      checksumAddress,\n      parameter: parameters[i],\n      value: values[i]\n    }));\n  }\n  return preparedParameters;\n}\n/** @internal */\nexport function prepareParameter(_ref5) {\n  let {\n    checksumAddress = false,\n    parameter: parameter_,\n    value\n  } = _ref5;\n  const parameter = parameter_;\n  const arrayComponents = getArrayComponents(parameter.type);\n  if (arrayComponents) {\n    const [length, type] = arrayComponents;\n    return encodeArray(value, {\n      checksumAddress,\n      length,\n      parameter: _objectSpread(_objectSpread({}, parameter), {}, {\n        type\n      })\n    });\n  }\n  if (parameter.type === 'tuple') {\n    return encodeTuple(value, {\n      checksumAddress,\n      parameter: parameter\n    });\n  }\n  if (parameter.type === 'address') {\n    return encodeAddress(value, {\n      checksum: checksumAddress\n    });\n  }\n  if (parameter.type === 'bool') {\n    return encodeBoolean(value);\n  }\n  if (parameter.type.startsWith('uint') || parameter.type.startsWith('int')) {\n    var _integerRegex$exec;\n    const signed = parameter.type.startsWith('int');\n    const [,, size = '256'] = (_integerRegex$exec = integerRegex.exec(parameter.type)) !== null && _integerRegex$exec !== void 0 ? _integerRegex$exec : [];\n    return encodeNumber(value, {\n      signed,\n      size: Number(size)\n    });\n  }\n  if (parameter.type.startsWith('bytes')) {\n    return encodeBytes(value, {\n      type: parameter.type\n    });\n  }\n  if (parameter.type === 'string') {\n    return encodeString(value);\n  }\n  throw new AbiParameters.InvalidTypeError(parameter.type);\n}\n/** @internal */\nexport function encode(preparedParameters) {\n  // 1. Compute the size of the static part of the parameters.\n  let staticSize = 0;\n  for (let i = 0; i < preparedParameters.length; i++) {\n    const {\n      dynamic,\n      encoded\n    } = preparedParameters[i];\n    if (dynamic) staticSize += 32;else staticSize += Hex.size(encoded);\n  }\n  // 2. Split the parameters into static and dynamic parts.\n  const staticParameters = [];\n  const dynamicParameters = [];\n  let dynamicSize = 0;\n  for (let i = 0; i < preparedParameters.length; i++) {\n    const {\n      dynamic,\n      encoded\n    } = preparedParameters[i];\n    if (dynamic) {\n      staticParameters.push(Hex.fromNumber(staticSize + dynamicSize, {\n        size: 32\n      }));\n      dynamicParameters.push(encoded);\n      dynamicSize += Hex.size(encoded);\n    } else {\n      staticParameters.push(encoded);\n    }\n  }\n  // 3. Concatenate static and dynamic parts.\n  return Hex.concat(...staticParameters, ...dynamicParameters);\n}\n/** @internal */\nexport function encodeAddress(value, options) {\n  const {\n    checksum = false\n  } = options;\n  Address.assert(value, {\n    strict: checksum\n  });\n  return {\n    dynamic: false,\n    encoded: Hex.padLeft(value.toLowerCase())\n  };\n}\n/** @internal */\nexport function encodeArray(value, options) {\n  const {\n    checksumAddress,\n    length,\n    parameter\n  } = options;\n  const dynamic = length === null;\n  if (!Array.isArray(value)) throw new AbiParameters.InvalidArrayError(value);\n  if (!dynamic && value.length !== length) throw new AbiParameters.ArrayLengthMismatchError({\n    expectedLength: length,\n    givenLength: value.length,\n    type: \"\".concat(parameter.type, \"[\").concat(length, \"]\")\n  });\n  let dynamicChild = false;\n  const preparedParameters = [];\n  for (let i = 0; i < value.length; i++) {\n    const preparedParam = prepareParameter({\n      checksumAddress,\n      parameter,\n      value: value[i]\n    });\n    if (preparedParam.dynamic) dynamicChild = true;\n    preparedParameters.push(preparedParam);\n  }\n  if (dynamic || dynamicChild) {\n    const data = encode(preparedParameters);\n    if (dynamic) {\n      const length = Hex.fromNumber(preparedParameters.length, {\n        size: 32\n      });\n      return {\n        dynamic: true,\n        encoded: preparedParameters.length > 0 ? Hex.concat(length, data) : length\n      };\n    }\n    if (dynamicChild) return {\n      dynamic: true,\n      encoded: data\n    };\n  }\n  return {\n    dynamic: false,\n    encoded: Hex.concat(...preparedParameters.map(_ref6 => {\n      let {\n        encoded\n      } = _ref6;\n      return encoded;\n    }))\n  };\n}\n/** @internal */\nexport function encodeBytes(value, _ref7) {\n  let {\n    type\n  } = _ref7;\n  const [, parametersize] = type.split('bytes');\n  const bytesSize = Hex.size(value);\n  if (!parametersize) {\n    let value_ = value;\n    // If the size is not divisible by 32 bytes, pad the end\n    // with empty bytes to the ceiling 32 bytes.\n    if (bytesSize % 32 !== 0) value_ = Hex.padRight(value_, Math.ceil((value.length - 2) / 2 / 32) * 32);\n    return {\n      dynamic: true,\n      encoded: Hex.concat(Hex.padLeft(Hex.fromNumber(bytesSize, {\n        size: 32\n      })), value_)\n    };\n  }\n  if (bytesSize !== Number.parseInt(parametersize, 10)) throw new AbiParameters.BytesSizeMismatchError({\n    expectedSize: Number.parseInt(parametersize, 10),\n    value\n  });\n  return {\n    dynamic: false,\n    encoded: Hex.padRight(value)\n  };\n}\n/** @internal */\nexport function encodeBoolean(value) {\n  if (typeof value !== 'boolean') throw new Errors.BaseError(\"Invalid boolean value: \\\"\".concat(value, \"\\\" (type: \").concat(typeof value, \"). Expected: `true` or `false`.\"));\n  return {\n    dynamic: false,\n    encoded: Hex.padLeft(Hex.fromBoolean(value))\n  };\n}\n/** @internal */\nexport function encodeNumber(value, _ref8) {\n  let {\n    signed,\n    size\n  } = _ref8;\n  if (typeof size === 'number') {\n    const max = 2n ** (BigInt(size) - (signed ? 1n : 0n)) - 1n;\n    const min = signed ? -max - 1n : 0n;\n    if (value > max || value < min) throw new Hex.IntegerOutOfRangeError({\n      max: max.toString(),\n      min: min.toString(),\n      signed,\n      size: size / 8,\n      value: value.toString()\n    });\n  }\n  return {\n    dynamic: false,\n    encoded: Hex.fromNumber(value, {\n      size: 32,\n      signed\n    })\n  };\n}\n/** @internal */\nexport function encodeString(value) {\n  const hexValue = Hex.fromString(value);\n  const partsLength = Math.ceil(Hex.size(hexValue) / 32);\n  const parts = [];\n  for (let i = 0; i < partsLength; i++) {\n    parts.push(Hex.padRight(Hex.slice(hexValue, i * 32, (i + 1) * 32)));\n  }\n  return {\n    dynamic: true,\n    encoded: Hex.concat(Hex.padRight(Hex.fromNumber(Hex.size(hexValue), {\n      size: 32\n    })), ...parts)\n  };\n}\n/** @internal */\nexport function encodeTuple(value, options) {\n  const {\n    checksumAddress,\n    parameter\n  } = options;\n  let dynamic = false;\n  const preparedParameters = [];\n  for (let i = 0; i < parameter.components.length; i++) {\n    const param_ = parameter.components[i];\n    const index = Array.isArray(value) ? i : param_.name;\n    const preparedParam = prepareParameter({\n      checksumAddress,\n      parameter: param_,\n      value: value[index]\n    });\n    preparedParameters.push(preparedParam);\n    if (preparedParam.dynamic) dynamic = true;\n  }\n  return {\n    dynamic,\n    encoded: dynamic ? encode(preparedParameters) : Hex.concat(...preparedParameters.map(_ref9 => {\n      let {\n        encoded\n      } = _ref9;\n      return encoded;\n    }))\n  };\n}\n/** @internal */\nexport function getArrayComponents(type) {\n  const matches = type.match(/^(.*)\\[(\\d+)?\\]$/);\n  return matches ?\n  // Return `null` if the array is dynamic.\n  [matches[2] ? Number(matches[2]) : null, matches[1]] : undefined;\n}\n/** @internal */\nexport function hasDynamicChild(param) {\n  var _param$components;\n  const {\n    type\n  } = param;\n  if (type === 'string') return true;\n  if (type === 'bytes') return true;\n  if (type.endsWith('[]')) return true;\n  if (type === 'tuple') return (_param$components = param.components) === null || _param$components === void 0 ? void 0 : _param$components.some(hasDynamicChild);\n  const arrayComponents = getArrayComponents(param.type);\n  if (arrayComponents && hasDynamicChild(_objectSpread(_objectSpread({}, param), {}, {\n    type: arrayComponents[1]\n  }))) return true;\n  return false;\n}","map":{"version":3,"names":["AbiParameters","Address","Bytes","Errors","Hex","integerRegex","decodeParameter","cursor","param","options","checksumAddress","staticPosition","arrayComponents","getArrayComponents","type","length","decodeArray","_objectSpread","decodeTuple","decodeAddress","checksum","decodeBool","startsWith","decodeBytes","decodeNumber","decodeString","InvalidTypeError","sizeOfLength","sizeOfOffset","arguments","undefined","value","readBytes","wrap","address","fromBytes","slice","offset","toNumber","start","startOfData","setPosition","dynamicChild","hasDynamicChild","consumed","i","data","consumed_","push","toBoolean","size","_ref","_","split","Number","parseInt","signed","toBigInt","hasUnnamedChild","components","some","_ref2","name","component","_ref3","toString","trimLeft","prepareParameters","_ref4","parameters","values","preparedParameters","prepareParameter","parameter","_ref5","parameter_","encodeArray","encodeTuple","encodeAddress","encodeBoolean","_integerRegex$exec","exec","encodeNumber","encodeBytes","encodeString","encode","staticSize","dynamic","encoded","staticParameters","dynamicParameters","dynamicSize","fromNumber","concat","assert","strict","padLeft","toLowerCase","Array","isArray","InvalidArrayError","ArrayLengthMismatchError","expectedLength","givenLength","preparedParam","map","_ref6","_ref7","parametersize","bytesSize","value_","padRight","Math","ceil","BytesSizeMismatchError","expectedSize","BaseError","fromBoolean","_ref8","max","BigInt","min","IntegerOutOfRangeError","hexValue","fromString","partsLength","parts","param_","index","_ref9","matches","match","_param$components","endsWith"],"sources":["/Users/mac/Desktop/topl1/frontend/node_modules/ox/core/internal/abiParameters.ts"],"sourcesContent":["import type {\n  AbiParameter,\n  AbiParameterKind,\n  AbiParametersToPrimitiveTypes,\n  AbiParameterToPrimitiveType,\n} from 'abitype'\nimport * as AbiParameters from '../AbiParameters.js'\nimport * as Address from '../Address.js'\nimport * as Bytes from '../Bytes.js'\nimport * as Errors from '../Errors.js'\nimport * as Hex from '../Hex.js'\nimport { integerRegex } from '../Solidity.js'\nimport type * as Cursor from './cursor.js'\nimport type { Compute, IsNarrowable, UnionToIntersection } from './types.js'\n\n/** @internal */\nexport type ParameterToPrimitiveType<\n  abiParameter extends AbiParameter | { name: string; type: unknown },\n  abiParameterKind extends AbiParameterKind = AbiParameterKind,\n> = AbiParameterToPrimitiveType<abiParameter, abiParameterKind>\n\n/** @internal */\nexport type PreparedParameter = { dynamic: boolean; encoded: Hex.Hex }\n\n/** @internal */\nexport type ToObject<\n  parameters extends readonly AbiParameter[],\n  kind extends AbiParameterKind = AbiParameterKind,\n> = IsNarrowable<parameters, AbiParameters.AbiParameters> extends true\n  ? Compute<\n      UnionToIntersection<\n        {\n          [index in keyof parameters]: parameters[index] extends {\n            name: infer name extends string\n          }\n            ? {\n                [key in name]: AbiParameterToPrimitiveType<\n                  parameters[index],\n                  kind\n                >\n              }\n            : {\n                [key in index]: AbiParameterToPrimitiveType<\n                  parameters[index],\n                  kind\n                >\n              }\n        }[number]\n      >\n    >\n  : unknown\n\n/** @internal */\nexport type ToPrimitiveTypes<\n  abiParameters extends readonly AbiParameter[],\n  abiParameterKind extends AbiParameterKind = AbiParameterKind,\n> = AbiParametersToPrimitiveTypes<abiParameters, abiParameterKind>\n\n/** @internal */\nexport type Tuple = ParameterToPrimitiveType<TupleAbiParameter>\n\n/** @internal */\nexport function decodeParameter(\n  cursor: Cursor.Cursor,\n  param: AbiParameters.Parameter,\n  options: { checksumAddress?: boolean | undefined; staticPosition: number },\n) {\n  const { checksumAddress, staticPosition } = options\n  const arrayComponents = getArrayComponents(param.type)\n  if (arrayComponents) {\n    const [length, type] = arrayComponents\n    return decodeArray(\n      cursor,\n      { ...param, type },\n      { checksumAddress, length, staticPosition },\n    )\n  }\n  if (param.type === 'tuple')\n    return decodeTuple(cursor, param as TupleAbiParameter, {\n      checksumAddress,\n      staticPosition,\n    })\n  if (param.type === 'address')\n    return decodeAddress(cursor, { checksum: checksumAddress })\n  if (param.type === 'bool') return decodeBool(cursor)\n  if (param.type.startsWith('bytes'))\n    return decodeBytes(cursor, param, { staticPosition })\n  if (param.type.startsWith('uint') || param.type.startsWith('int'))\n    return decodeNumber(cursor, param)\n  if (param.type === 'string') return decodeString(cursor, { staticPosition })\n  throw new AbiParameters.InvalidTypeError(param.type)\n}\n\nexport declare namespace decodeParameter {\n  type ErrorType =\n    | decodeArray.ErrorType\n    | decodeTuple.ErrorType\n    | decodeAddress.ErrorType\n    | decodeBool.ErrorType\n    | decodeBytes.ErrorType\n    | decodeNumber.ErrorType\n    | decodeString.ErrorType\n    | AbiParameters.InvalidTypeError\n    | Errors.GlobalErrorType\n}\n\nconst sizeOfLength = 32\nconst sizeOfOffset = 32\n\n/** @internal */\nexport function decodeAddress(\n  cursor: Cursor.Cursor,\n  options: { checksum?: boolean | undefined } = {},\n) {\n  const { checksum = false } = options\n  const value = cursor.readBytes(32)\n  const wrap = (address: Hex.Hex) =>\n    checksum ? Address.checksum(address) : address\n  return [wrap(Hex.fromBytes(Bytes.slice(value, -20))), 32]\n}\n\nexport declare namespace decodeAddress {\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | Bytes.slice.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function decodeArray(\n  cursor: Cursor.Cursor,\n  param: AbiParameters.Parameter,\n  options: {\n    checksumAddress?: boolean | undefined\n    length: number | null\n    staticPosition: number\n  },\n) {\n  const { checksumAddress, length, staticPosition } = options\n\n  // If the length of the array is not known in advance (dynamic array),\n  // this means we will need to wonder off to the pointer and decode.\n  if (!length) {\n    // Dealing with a dynamic type, so get the offset of the array data.\n    const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset))\n\n    // Start is the static position of current slot + offset.\n    const start = staticPosition + offset\n    const startOfData = start + sizeOfLength\n\n    // Get the length of the array from the offset.\n    cursor.setPosition(start)\n    const length = Bytes.toNumber(cursor.readBytes(sizeOfLength))\n\n    // Check if the array has any dynamic children.\n    const dynamicChild = hasDynamicChild(param)\n\n    let consumed = 0\n    const value: unknown[] = []\n    for (let i = 0; i < length; ++i) {\n      // If any of the children is dynamic, then all elements will be offset pointer, thus size of one slot (32 bytes).\n      // Otherwise, elements will be the size of their encoding (consumed bytes).\n      cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed))\n      const [data, consumed_] = decodeParameter(cursor, param, {\n        checksumAddress,\n        staticPosition: startOfData,\n      })\n      consumed += consumed_\n      value.push(data)\n    }\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [value, 32]\n  }\n\n  // If the length of the array is known in advance,\n  // and the length of an element deeply nested in the array is not known,\n  // we need to decode the offset of the array data.\n  if (hasDynamicChild(param)) {\n    // Dealing with dynamic types, so get the offset of the array data.\n    const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset))\n\n    // Start is the static position of current slot + offset.\n    const start = staticPosition + offset\n\n    const value: unknown[] = []\n    for (let i = 0; i < length; ++i) {\n      // Move cursor along to the next slot (next offset pointer).\n      cursor.setPosition(start + i * 32)\n      const [data] = decodeParameter(cursor, param, {\n        checksumAddress,\n        staticPosition: start,\n      })\n      value.push(data)\n    }\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [value, 32]\n  }\n\n  // If the length of the array is known in advance and the array is deeply static,\n  // then we can just decode each element in sequence.\n  let consumed = 0\n  const value: unknown[] = []\n  for (let i = 0; i < length; ++i) {\n    const [data, consumed_] = decodeParameter(cursor, param, {\n      checksumAddress,\n      staticPosition: staticPosition + consumed,\n    })\n    consumed += consumed_\n    value.push(data)\n  }\n  return [value, consumed]\n}\n\nexport declare namespace decodeArray {\n  type ErrorType = Bytes.toNumber.ErrorType | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function decodeBool(cursor: Cursor.Cursor) {\n  return [Bytes.toBoolean(cursor.readBytes(32), { size: 32 }), 32]\n}\n\nexport declare namespace decodeBool {\n  type ErrorType = Bytes.toBoolean.ErrorType | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function decodeBytes(\n  cursor: Cursor.Cursor,\n  param: AbiParameters.Parameter,\n  { staticPosition }: { staticPosition: number },\n) {\n  const [_, size] = param.type.split('bytes')\n  if (!size) {\n    // Dealing with dynamic types, so get the offset of the bytes data.\n    const offset = Bytes.toNumber(cursor.readBytes(32))\n\n    // Set position of the cursor to start of bytes data.\n    cursor.setPosition(staticPosition + offset)\n\n    const length = Bytes.toNumber(cursor.readBytes(32))\n\n    // If there is no length, we have zero data.\n    if (length === 0) {\n      // As we have gone wondering, restore to the original position + next slot.\n      cursor.setPosition(staticPosition + 32)\n      return ['0x', 32]\n    }\n\n    const data = cursor.readBytes(length)\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [Hex.fromBytes(data), 32]\n  }\n\n  const value = Hex.fromBytes(cursor.readBytes(Number.parseInt(size, 10), 32))\n  return [value, 32]\n}\n\nexport declare namespace decodeBytes {\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | Bytes.toNumber.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function decodeNumber(\n  cursor: Cursor.Cursor,\n  param: AbiParameters.Parameter,\n) {\n  const signed = param.type.startsWith('int')\n  const size = Number.parseInt(param.type.split('int')[1] || '256', 10)\n  const value = cursor.readBytes(32)\n  return [\n    size > 48\n      ? Bytes.toBigInt(value, { signed })\n      : Bytes.toNumber(value, { signed }),\n    32,\n  ]\n}\n\nexport declare namespace decodeNumber {\n  type ErrorType =\n    | Bytes.toNumber.ErrorType\n    | Bytes.toBigInt.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport type TupleAbiParameter = AbiParameters.Parameter & {\n  components: readonly AbiParameters.Parameter[]\n}\n\n/** @internal */\nexport function decodeTuple(\n  cursor: Cursor.Cursor,\n  param: TupleAbiParameter,\n  options: { checksumAddress?: boolean | undefined; staticPosition: number },\n) {\n  const { checksumAddress, staticPosition } = options\n\n  // Tuples can have unnamed components (i.e. they are arrays), so we must\n  // determine whether the tuple is named or unnamed. In the case of a named\n  // tuple, the value will be an object where each property is the name of the\n  // component. In the case of an unnamed tuple, the value will be an array.\n  const hasUnnamedChild =\n    param.components.length === 0 || param.components.some(({ name }) => !name)\n\n  // Initialize the value to an object or an array, depending on whether the\n  // tuple is named or unnamed.\n  const value: any = hasUnnamedChild ? [] : {}\n  let consumed = 0\n\n  // If the tuple has a dynamic child, we must first decode the offset to the\n  // tuple data.\n  if (hasDynamicChild(param)) {\n    // Dealing with dynamic types, so get the offset of the tuple data.\n    const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset))\n\n    // Start is the static position of referencing slot + offset.\n    const start = staticPosition + offset\n\n    for (let i = 0; i < param.components.length; ++i) {\n      const component = param.components[i]!\n      cursor.setPosition(start + consumed)\n      const [data, consumed_] = decodeParameter(cursor, component, {\n        checksumAddress,\n        staticPosition: start,\n      })\n      consumed += consumed_\n      value[hasUnnamedChild ? i : component?.name!] = data\n    }\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [value, 32]\n  }\n\n  // If the tuple has static children, we can just decode each component\n  // in sequence.\n  for (let i = 0; i < param.components.length; ++i) {\n    const component = param.components[i]!\n    const [data, consumed_] = decodeParameter(cursor, component, {\n      checksumAddress,\n      staticPosition,\n    })\n    value[hasUnnamedChild ? i : component?.name!] = data\n    consumed += consumed_\n  }\n  return [value, consumed]\n}\n\nexport declare namespace decodeTuple {\n  type ErrorType = Bytes.toNumber.ErrorType | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function decodeString(\n  cursor: Cursor.Cursor,\n  { staticPosition }: { staticPosition: number },\n) {\n  // Get offset to start of string data.\n  const offset = Bytes.toNumber(cursor.readBytes(32))\n\n  // Start is the static position of current slot + offset.\n  const start = staticPosition + offset\n  cursor.setPosition(start)\n\n  const length = Bytes.toNumber(cursor.readBytes(32))\n\n  // If there is no length, we have zero data (empty string).\n  if (length === 0) {\n    cursor.setPosition(staticPosition + 32)\n    return ['', 32]\n  }\n\n  const data = cursor.readBytes(length, 32)\n  const value = Bytes.toString(Bytes.trimLeft(data))\n\n  // As we have gone wondering, restore to the original position + next slot.\n  cursor.setPosition(staticPosition + 32)\n\n  return [value, 32]\n}\n\nexport declare namespace decodeString {\n  type ErrorType =\n    | Bytes.toNumber.ErrorType\n    | Bytes.toString.ErrorType\n    | Bytes.trimLeft.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function prepareParameters<\n  const parameters extends AbiParameters.AbiParameters,\n>({\n  checksumAddress,\n  parameters,\n  values,\n}: {\n  checksumAddress?: boolean | undefined\n  parameters: parameters\n  values: parameters extends AbiParameters.AbiParameters\n    ? ToPrimitiveTypes<parameters>\n    : never\n}) {\n  const preparedParameters: PreparedParameter[] = []\n  for (let i = 0; i < parameters.length; i++) {\n    preparedParameters.push(\n      prepareParameter({\n        checksumAddress,\n        parameter: parameters[i]!,\n        value: values[i],\n      }),\n    )\n  }\n  return preparedParameters\n}\n\n/** @internal */\nexport declare namespace prepareParameters {\n  type ErrorType = prepareParameter.ErrorType | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function prepareParameter<\n  const parameter extends AbiParameters.Parameter,\n>({\n  checksumAddress = false,\n  parameter: parameter_,\n  value,\n}: {\n  parameter: parameter\n  value: parameter extends AbiParameters.Parameter\n    ? ParameterToPrimitiveType<parameter>\n    : never\n  checksumAddress?: boolean | undefined\n}): PreparedParameter {\n  const parameter = parameter_ as AbiParameters.Parameter\n\n  const arrayComponents = getArrayComponents(parameter.type)\n  if (arrayComponents) {\n    const [length, type] = arrayComponents\n    return encodeArray(value, {\n      checksumAddress,\n      length,\n      parameter: {\n        ...parameter,\n        type,\n      },\n    })\n  }\n  if (parameter.type === 'tuple') {\n    return encodeTuple(value as unknown as Tuple, {\n      checksumAddress,\n      parameter: parameter as TupleAbiParameter,\n    })\n  }\n  if (parameter.type === 'address') {\n    return encodeAddress(value as unknown as Hex.Hex, {\n      checksum: checksumAddress,\n    })\n  }\n  if (parameter.type === 'bool') {\n    return encodeBoolean(value as unknown as boolean)\n  }\n  if (parameter.type.startsWith('uint') || parameter.type.startsWith('int')) {\n    const signed = parameter.type.startsWith('int')\n    const [, , size = '256'] = integerRegex.exec(parameter.type) ?? []\n    return encodeNumber(value as unknown as number, {\n      signed,\n      size: Number(size),\n    })\n  }\n  if (parameter.type.startsWith('bytes')) {\n    return encodeBytes(value as unknown as Hex.Hex, { type: parameter.type })\n  }\n  if (parameter.type === 'string') {\n    return encodeString(value as unknown as string)\n  }\n  throw new AbiParameters.InvalidTypeError(parameter.type)\n}\n\n/** @internal */\nexport declare namespace prepareParameter {\n  type ErrorType =\n    | encodeArray.ErrorType\n    | encodeTuple.ErrorType\n    | encodeAddress.ErrorType\n    | encodeBoolean.ErrorType\n    | encodeBytes.ErrorType\n    | encodeString.ErrorType\n    | AbiParameters.InvalidTypeError\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encode(preparedParameters: PreparedParameter[]): Hex.Hex {\n  // 1. Compute the size of the static part of the parameters.\n  let staticSize = 0\n  for (let i = 0; i < preparedParameters.length; i++) {\n    const { dynamic, encoded } = preparedParameters[i]!\n    if (dynamic) staticSize += 32\n    else staticSize += Hex.size(encoded)\n  }\n\n  // 2. Split the parameters into static and dynamic parts.\n  const staticParameters: Hex.Hex[] = []\n  const dynamicParameters: Hex.Hex[] = []\n  let dynamicSize = 0\n  for (let i = 0; i < preparedParameters.length; i++) {\n    const { dynamic, encoded } = preparedParameters[i]!\n    if (dynamic) {\n      staticParameters.push(\n        Hex.fromNumber(staticSize + dynamicSize, { size: 32 }),\n      )\n      dynamicParameters.push(encoded)\n      dynamicSize += Hex.size(encoded)\n    } else {\n      staticParameters.push(encoded)\n    }\n  }\n\n  // 3. Concatenate static and dynamic parts.\n  return Hex.concat(...staticParameters, ...dynamicParameters)\n}\n\n/** @internal */\nexport declare namespace encode {\n  type ErrorType =\n    | Hex.concat.ErrorType\n    | Hex.fromNumber.ErrorType\n    | Hex.size.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encodeAddress(\n  value: Hex.Hex,\n  options: { checksum: boolean },\n): PreparedParameter {\n  const { checksum = false } = options\n  Address.assert(value, { strict: checksum })\n  return {\n    dynamic: false,\n    encoded: Hex.padLeft(value.toLowerCase() as Hex.Hex),\n  }\n}\n\n/** @internal */\nexport declare namespace encodeAddress {\n  type ErrorType =\n    | Address.assert.ErrorType\n    | Hex.padLeft.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encodeArray<const parameter extends AbiParameters.Parameter>(\n  value: ParameterToPrimitiveType<parameter>,\n  options: {\n    checksumAddress?: boolean | undefined\n    length: number | null\n    parameter: parameter\n  },\n): PreparedParameter {\n  const { checksumAddress, length, parameter } = options\n\n  const dynamic = length === null\n\n  if (!Array.isArray(value)) throw new AbiParameters.InvalidArrayError(value)\n  if (!dynamic && value.length !== length)\n    throw new AbiParameters.ArrayLengthMismatchError({\n      expectedLength: length!,\n      givenLength: value.length,\n      type: `${parameter.type}[${length}]`,\n    })\n\n  let dynamicChild = false\n  const preparedParameters: PreparedParameter[] = []\n  for (let i = 0; i < value.length; i++) {\n    const preparedParam = prepareParameter({\n      checksumAddress,\n      parameter,\n      value: value[i],\n    })\n    if (preparedParam.dynamic) dynamicChild = true\n    preparedParameters.push(preparedParam)\n  }\n\n  if (dynamic || dynamicChild) {\n    const data = encode(preparedParameters)\n    if (dynamic) {\n      const length = Hex.fromNumber(preparedParameters.length, { size: 32 })\n      return {\n        dynamic: true,\n        encoded:\n          preparedParameters.length > 0 ? Hex.concat(length, data) : length,\n      }\n    }\n    if (dynamicChild) return { dynamic: true, encoded: data }\n  }\n  return {\n    dynamic: false,\n    encoded: Hex.concat(...preparedParameters.map(({ encoded }) => encoded)),\n  }\n}\n\n/** @internal */\nexport declare namespace encodeArray {\n  type ErrorType =\n    | AbiParameters.InvalidArrayError\n    | AbiParameters.ArrayLengthMismatchError\n    | Hex.concat.ErrorType\n    | Hex.fromNumber.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encodeBytes(\n  value: Hex.Hex,\n  { type }: { type: string },\n): PreparedParameter {\n  const [, parametersize] = type.split('bytes')\n  const bytesSize = Hex.size(value)\n  if (!parametersize) {\n    let value_ = value\n    // If the size is not divisible by 32 bytes, pad the end\n    // with empty bytes to the ceiling 32 bytes.\n    if (bytesSize % 32 !== 0)\n      value_ = Hex.padRight(value_, Math.ceil((value.length - 2) / 2 / 32) * 32)\n    return {\n      dynamic: true,\n      encoded: Hex.concat(\n        Hex.padLeft(Hex.fromNumber(bytesSize, { size: 32 })),\n        value_,\n      ),\n    }\n  }\n  if (bytesSize !== Number.parseInt(parametersize, 10))\n    throw new AbiParameters.BytesSizeMismatchError({\n      expectedSize: Number.parseInt(parametersize, 10),\n      value,\n    })\n  return { dynamic: false, encoded: Hex.padRight(value) }\n}\n\n/** @internal */\nexport declare namespace encodeBytes {\n  type ErrorType =\n    | Hex.padLeft.ErrorType\n    | Hex.padRight.ErrorType\n    | Hex.fromNumber.ErrorType\n    | Hex.slice.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encodeBoolean(value: boolean): PreparedParameter {\n  if (typeof value !== 'boolean')\n    throw new Errors.BaseError(\n      `Invalid boolean value: \"${value}\" (type: ${typeof value}). Expected: \\`true\\` or \\`false\\`.`,\n    )\n  return { dynamic: false, encoded: Hex.padLeft(Hex.fromBoolean(value)) }\n}\n\n/** @internal */\nexport declare namespace encodeBoolean {\n  type ErrorType =\n    | Hex.padLeft.ErrorType\n    | Hex.fromBoolean.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encodeNumber(\n  value: number,\n  { signed, size }: { signed: boolean; size: number },\n): PreparedParameter {\n  if (typeof size === 'number') {\n    const max = 2n ** (BigInt(size) - (signed ? 1n : 0n)) - 1n\n    const min = signed ? -max - 1n : 0n\n    if (value > max || value < min)\n      throw new Hex.IntegerOutOfRangeError({\n        max: max.toString(),\n        min: min.toString(),\n        signed,\n        size: size / 8,\n        value: value.toString(),\n      })\n  }\n  return {\n    dynamic: false,\n    encoded: Hex.fromNumber(value, {\n      size: 32,\n      signed,\n    }),\n  }\n}\n\n/** @internal */\nexport declare namespace encodeNumber {\n  type ErrorType = Hex.fromNumber.ErrorType | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encodeString(value: string): PreparedParameter {\n  const hexValue = Hex.fromString(value)\n  const partsLength = Math.ceil(Hex.size(hexValue) / 32)\n  const parts: Hex.Hex[] = []\n  for (let i = 0; i < partsLength; i++) {\n    parts.push(Hex.padRight(Hex.slice(hexValue, i * 32, (i + 1) * 32)))\n  }\n  return {\n    dynamic: true,\n    encoded: Hex.concat(\n      Hex.padRight(Hex.fromNumber(Hex.size(hexValue), { size: 32 })),\n      ...parts,\n    ),\n  }\n}\n\n/** @internal */\nexport declare namespace encodeString {\n  type ErrorType =\n    | Hex.fromNumber.ErrorType\n    | Hex.padRight.ErrorType\n    | Hex.slice.ErrorType\n    | Hex.size.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encodeTuple<\n  const parameter extends AbiParameters.Parameter & {\n    components: readonly AbiParameters.Parameter[]\n  },\n>(\n  value: ParameterToPrimitiveType<parameter>,\n  options: {\n    checksumAddress?: boolean | undefined\n    parameter: parameter\n  },\n): PreparedParameter {\n  const { checksumAddress, parameter } = options\n\n  let dynamic = false\n  const preparedParameters: PreparedParameter[] = []\n  for (let i = 0; i < parameter.components.length; i++) {\n    const param_ = parameter.components[i]!\n    const index = Array.isArray(value) ? i : param_.name\n    const preparedParam = prepareParameter({\n      checksumAddress,\n      parameter: param_,\n      value: (value as any)[index!] as readonly unknown[],\n    })\n    preparedParameters.push(preparedParam)\n    if (preparedParam.dynamic) dynamic = true\n  }\n  return {\n    dynamic,\n    encoded: dynamic\n      ? encode(preparedParameters)\n      : Hex.concat(...preparedParameters.map(({ encoded }) => encoded)),\n  }\n}\n\n/** @internal */\nexport declare namespace encodeTuple {\n  type ErrorType = Hex.concat.ErrorType | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function getArrayComponents(\n  type: string,\n): [length: number | null, innerType: string] | undefined {\n  const matches = type.match(/^(.*)\\[(\\d+)?\\]$/)\n  return matches\n    ? // Return `null` if the array is dynamic.\n      [matches[2]! ? Number(matches[2]!) : null, matches[1]!]\n    : undefined\n}\n\n/** @internal */\nexport function hasDynamicChild(param: AbiParameters.Parameter) {\n  const { type } = param\n  if (type === 'string') return true\n  if (type === 'bytes') return true\n  if (type.endsWith('[]')) return true\n\n  if (type === 'tuple') return (param as any).components?.some(hasDynamicChild)\n\n  const arrayComponents = getArrayComponents(param.type)\n  if (\n    arrayComponents &&\n    hasDynamicChild({\n      ...param,\n      type: arrayComponents[1],\n    } as AbiParameters.Parameter)\n  )\n    return true\n\n  return false\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}