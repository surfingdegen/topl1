{"ast":null,"code":"import _objectSpread from \"/Users/mac/Desktop/topl1/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport * as abitype from 'abitype';\nimport * as Errors from './Errors.js';\nimport * as Hash from './Hash.js';\nimport * as Hex from './Hex.js';\nimport * as internal from './internal/abiItem.js';\n/**\n * Formats an {@link ox#AbiItem.AbiItem} into a **Human Readable ABI Item**.\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const formatted = AbiItem.format({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param abiItem - The ABI Item to format.\n * @returns The formatted ABI Item  .\n */\nexport function format(abiItem) {\n  return abitype.formatAbiItem(abiItem);\n}\n/**\n * Parses an arbitrary **JSON ABI Item** or **Human Readable ABI Item** into a typed {@link ox#AbiItem.AbiItem}.\n *\n * @example\n * ### JSON ABIs\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable ABIs\n *\n * A Human Readable ABI can be parsed into a typed ABI object:\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from(\n *   'function approve(address spender, uint256 amount) returns (bool)' // [!code hl]\n * )\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from([\n *   'struct Foo { address spender; uint256 amount; }', // [!code hl]\n *   'function approve(Foo foo) returns (bool)',\n * ])\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param abiItem - The ABI Item to parse.\n * @returns The typed ABI Item.\n */\nexport function from(abiItem) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    prepare = true\n  } = options;\n  const item = (() => {\n    if (Array.isArray(abiItem)) return abitype.parseAbiItem(abiItem);\n    if (typeof abiItem === 'string') return abitype.parseAbiItem(abiItem);\n    return abiItem;\n  })();\n  return _objectSpread(_objectSpread({}, item), prepare ? {\n    hash: getSignatureHash(item)\n  } : {});\n}\n/**\n * Extracts an {@link ox#AbiItem.AbiItem} from an {@link ox#Abi.Abi} given a name and optional arguments.\n *\n * @example\n * ABI Items can be extracted by their name using the `name` option:\n *\n * ```ts twoslash\n * import { Abi, AbiItem } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiItem.fromAbi(abi, 'Transfer') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Extracting by Selector\n *\n * ABI Items can be extract by their selector when {@link ox#Hex.Hex} is provided to `name`.\n *\n * ```ts twoslash\n * import { Abi, AbiItem } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n * const item = AbiItem.fromAbi(abi, '0x095ea7b3') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * :::note\n *\n * Extracting via a hex selector is useful when extracting an ABI Item from an `eth_call` RPC response,\n * a Transaction `input`, or from Event Log `topics`.\n *\n * :::\n *\n * @param abi - The ABI to extract from.\n * @param name - The name (or selector) of the ABI item to extract.\n * @param options - Extraction options.\n * @returns The ABI item.\n */\nexport function fromAbi(abi, name, options) {\n  const {\n    args = [],\n    prepare = true\n  } = options !== null && options !== void 0 ? options : {};\n  const isSelector = Hex.validate(name, {\n    strict: false\n  });\n  const abiItems = abi.filter(abiItem => {\n    if (isSelector) {\n      if (abiItem.type === 'function' || abiItem.type === 'error') return getSelector(abiItem) === Hex.slice(name, 0, 4);\n      if (abiItem.type === 'event') return getSignatureHash(abiItem) === name;\n      return false;\n    }\n    return 'name' in abiItem && abiItem.name === name;\n  });\n  if (abiItems.length === 0) throw new NotFoundError({\n    name: name\n  });\n  if (abiItems.length === 1) return _objectSpread(_objectSpread({}, abiItems[0]), prepare ? {\n    hash: getSignatureHash(abiItems[0])\n  } : {});\n  let matchedAbiItem;\n  for (const abiItem of abiItems) {\n    if (!('inputs' in abiItem)) continue;\n    if (!args || args.length === 0) {\n      if (!abiItem.inputs || abiItem.inputs.length === 0) return _objectSpread(_objectSpread({}, abiItem), prepare ? {\n        hash: getSignatureHash(abiItem)\n      } : {});\n      continue;\n    }\n    if (!abiItem.inputs) continue;\n    if (abiItem.inputs.length === 0) continue;\n    if (abiItem.inputs.length !== args.length) continue;\n    const matched = args.every((arg, index) => {\n      const abiParameter = 'inputs' in abiItem && abiItem.inputs[index];\n      if (!abiParameter) return false;\n      return internal.isArgOfType(arg, abiParameter);\n    });\n    if (matched) {\n      // Check for ambiguity against already matched parameters (e.g. `address` vs `bytes20`).\n      if (matchedAbiItem && 'inputs' in matchedAbiItem && matchedAbiItem.inputs) {\n        const ambiguousTypes = internal.getAmbiguousTypes(abiItem.inputs, matchedAbiItem.inputs, args);\n        if (ambiguousTypes) throw new AmbiguityError({\n          abiItem,\n          type: ambiguousTypes[0]\n        }, {\n          abiItem: matchedAbiItem,\n          type: ambiguousTypes[1]\n        });\n      }\n      matchedAbiItem = abiItem;\n    }\n  }\n  const abiItem = (() => {\n    if (matchedAbiItem) return matchedAbiItem;\n    const [abiItem, ...overloads] = abiItems;\n    return _objectSpread(_objectSpread({}, abiItem), {}, {\n      overloads\n    });\n  })();\n  if (!abiItem) throw new NotFoundError({\n    name: name\n  });\n  return _objectSpread(_objectSpread({}, abiItem), prepare ? {\n    hash: getSignatureHash(abiItem)\n  } : {});\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function getSelector() {\n  for (var _len = arguments.length, parameters = new Array(_len), _key = 0; _key < _len; _key++) {\n    parameters[_key] = arguments[_key];\n  }\n  const abiItem = (() => {\n    if (Array.isArray(parameters[0])) {\n      const [abi, name] = parameters;\n      return fromAbi(abi, name);\n    }\n    return parameters[0];\n  })();\n  return Hex.slice(getSignatureHash(abiItem), 0, 4);\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function getSignature() {\n  for (var _len2 = arguments.length, parameters = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    parameters[_key2] = arguments[_key2];\n  }\n  const abiItem = (() => {\n    if (Array.isArray(parameters[0])) {\n      const [abi, name] = parameters;\n      return fromAbi(abi, name);\n    }\n    return parameters[0];\n  })();\n  const signature = (() => {\n    if (typeof abiItem === 'string') return abiItem;\n    return abitype.formatAbiItem(abiItem);\n  })();\n  return internal.normalizeSignature(signature);\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function getSignatureHash() {\n  for (var _len3 = arguments.length, parameters = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    parameters[_key3] = arguments[_key3];\n  }\n  const abiItem = (() => {\n    if (Array.isArray(parameters[0])) {\n      const [abi, name] = parameters;\n      return fromAbi(abi, name);\n    }\n    return parameters[0];\n  })();\n  if (typeof abiItem !== 'string' && 'hash' in abiItem && abiItem.hash) return abiItem.hash;\n  return Hash.keccak256(Hex.fromString(getSignature(abiItem)));\n}\n/**\n * Throws when ambiguous types are found on overloaded ABI items.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from(['function foo(address)', 'function foo(bytes20)'])\n * AbiFunction.fromAbi(foo, 'foo', {\n *   args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n * })\n * // @error: AbiItem.AmbiguityError: Found ambiguous types in overloaded ABI Items.\n * // @error: `bytes20` in `foo(bytes20)`, and\n * // @error: `address` in `foo(address)`\n * // @error: These types encode differently and cannot be distinguished at runtime.\n * // @error: Remove one of the ambiguous items in the ABI.\n * ```\n *\n * ### Solution\n *\n * Remove one of the ambiguous types from the ABI.\n *\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function foo(bytes20)' // [!code --]\n * ])\n * AbiFunction.fromAbi(foo, 'foo', {\n *   args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n * })\n * // @error: AbiItem.AmbiguityError: Found ambiguous types in overloaded ABI Items.\n * // @error: `bytes20` in `foo(bytes20)`, and\n * // @error: `address` in `foo(address)`\n * // @error: These types encode differently and cannot be distinguished at runtime.\n * // @error: Remove one of the ambiguous items in the ABI.\n * ```\n */\nexport class AmbiguityError extends Errors.BaseError {\n  constructor(x, y) {\n    super('Found ambiguous types in overloaded ABI Items.', {\n      metaMessages: [// TODO: abitype to add support for signature-formatted ABI items.\n      \"`\".concat(x.type, \"` in `\").concat(internal.normalizeSignature(abitype.formatAbiItem(x.abiItem)), \"`, and\"), \"`\".concat(y.type, \"` in `\").concat(internal.normalizeSignature(abitype.formatAbiItem(y.abiItem)), \"`\"), '', 'These types encode differently and cannot be distinguished at runtime.', 'Remove one of the ambiguous items in the ABI.']\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'AbiItem.AmbiguityError'\n    });\n  }\n}\n/**\n * Throws when an ABI item is not found in the ABI.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)'\n * ])\n * AbiFunction.fromAbi(foo, 'baz')\n * // @error: AbiItem.NotFoundError: ABI function with name \"baz\" not found.\n * ```\n *\n * ### Solution\n *\n * Ensure the ABI item exists on the ABI.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)',\n *   'function baz(bool)' // [!code ++]\n * ])\n * AbiFunction.fromAbi(foo, 'baz')\n * ```\n */\nexport class NotFoundError extends Errors.BaseError {\n  constructor(_ref) {\n    let {\n      name,\n      data,\n      type = 'item'\n    } = _ref;\n    const selector = (() => {\n      if (name) return \" with name \\\"\".concat(name, \"\\\"\");\n      if (data) return \" with data \\\"\".concat(data, \"\\\"\");\n      return '';\n    })();\n    super(\"ABI \".concat(type).concat(selector, \" not found.\"));\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'AbiItem.NotFoundError'\n    });\n  }\n}\n/**\n * Throws when the selector size is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)'\n * ])\n * AbiFunction.fromAbi(foo, '0xaaa')\n * // @error: AbiItem.InvalidSelectorSizeError: Selector size is invalid. Expected 4 bytes. Received 2 bytes (\"0xaaa\").\n * ```\n *\n * ### Solution\n *\n * Ensure the selector size is 4 bytes.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)'\n * ])\n * AbiFunction.fromAbi(foo, '0x7af82b1a')\n * ```\n */\nexport class InvalidSelectorSizeError extends Errors.BaseError {\n  constructor(_ref2) {\n    let {\n      data\n    } = _ref2;\n    super(\"Selector size is invalid. Expected 4 bytes. Received \".concat(Hex.size(data), \" bytes (\\\"\").concat(data, \"\\\").\"));\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'AbiItem.InvalidSelectorSizeError'\n    });\n  }\n}","map":{"version":3,"names":["abitype","Errors","Hash","Hex","internal","format","abiItem","formatAbiItem","from","options","arguments","length","undefined","prepare","item","Array","isArray","parseAbiItem","_objectSpread","hash","getSignatureHash","fromAbi","abi","name","args","isSelector","validate","strict","abiItems","filter","type","getSelector","slice","NotFoundError","matchedAbiItem","inputs","matched","every","arg","index","abiParameter","isArgOfType","ambiguousTypes","getAmbiguousTypes","AmbiguityError","overloads","_len","parameters","_key","getSignature","_len2","_key2","signature","normalizeSignature","_len3","_key3","keccak256","fromString","BaseError","constructor","x","y","metaMessages","concat","Object","defineProperty","_ref","data","selector","InvalidSelectorSizeError","_ref2","size"],"sources":["/Users/mac/Desktop/topl1/frontend/node_modules/ox/core/AbiItem.ts"],"sourcesContent":["import * as abitype from 'abitype'\nimport type * as Abi from './Abi.js'\nimport * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as Hex from './Hex.js'\nimport * as internal from './internal/abiItem.js'\nimport type { UnionCompute } from './internal/types.js'\n\n/** Root type for an item on an {@link ox#Abi.Abi}. */\nexport type AbiItem = Abi.Abi[number]\n\n/**\n * Extracts an {@link ox#AbiItem.AbiItem} item from an {@link ox#Abi.Abi}, given a name.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiItem } from 'ox'\n *\n * const abi = Abi.from([\n *   'error Foo(string)',\n *   'function foo(string)',\n *   'event Bar(uint256)',\n * ])\n *\n * type Foo = AbiItem.FromAbi<typeof abi, 'Foo'>\n * //   ^?\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n */\nexport type FromAbi<\n  abi extends Abi.Abi,\n  name extends ExtractNames<abi>,\n> = Extract<abi[number], { name: name }>\n\n/**\n * Extracts the names of all {@link ox#AbiItem.AbiItem} items in an {@link ox#Abi.Abi}.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiItem } from 'ox'\n *\n * const abi = Abi.from([\n *   'error Foo(string)',\n *   'function foo(string)',\n *   'event Bar(uint256)',\n * ])\n *\n * type names = AbiItem.Name<typeof abi>\n * //   ^?\n *\n * ```\n */\nexport type Name<abi extends Abi.Abi | readonly unknown[] = Abi.Abi> =\n  abi extends Abi.Abi ? ExtractNames<abi> : string\n\nexport type ExtractNames<abi extends Abi.Abi> = Extract<\n  abi[number],\n  { name: string }\n>['name']\n\n/**\n * Formats an {@link ox#AbiItem.AbiItem} into a **Human Readable ABI Item**.\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const formatted = AbiItem.format({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param abiItem - The ABI Item to format.\n * @returns The formatted ABI Item  .\n */\nexport function format<const abiItem extends AbiItem>(\n  abiItem: abiItem | AbiItem,\n): abitype.FormatAbiItem<abiItem> {\n  return abitype.formatAbiItem(abiItem) as never\n}\n\nexport declare namespace format {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Parses an arbitrary **JSON ABI Item** or **Human Readable ABI Item** into a typed {@link ox#AbiItem.AbiItem}.\n *\n * @example\n * ### JSON ABIs\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable ABIs\n *\n * A Human Readable ABI can be parsed into a typed ABI object:\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from(\n *   'function approve(address spender, uint256 amount) returns (bool)' // [!code hl]\n * )\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from([\n *   'struct Foo { address spender; uint256 amount; }', // [!code hl]\n *   'function approve(Foo foo) returns (bool)',\n * ])\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param abiItem - The ABI Item to parse.\n * @returns The typed ABI Item.\n */\nexport function from<\n  const abiItem extends AbiItem | string | readonly string[],\n>(\n  abiItem: (abiItem | AbiItem | string | readonly string[]) &\n    (\n      | (abiItem extends string ? internal.Signature<abiItem> : never)\n      | (abiItem extends readonly string[]\n          ? internal.Signatures<abiItem>\n          : never)\n      | AbiItem\n    ),\n  options: from.Options = {},\n): from.ReturnType<abiItem> {\n  const { prepare = true } = options\n  const item = (() => {\n    if (Array.isArray(abiItem)) return abitype.parseAbiItem(abiItem)\n    if (typeof abiItem === 'string')\n      return abitype.parseAbiItem(abiItem as never)\n    return abiItem\n  })() as AbiItem\n  return {\n    ...item,\n    ...(prepare ? { hash: getSignatureHash(item) } : {}),\n  } as never\n}\n\nexport declare namespace from {\n  type Options = {\n    /**\n     * Whether or not to prepare the extracted item (optimization for encoding performance).\n     * When `true`, the `hash` property is computed and included in the returned value.\n     *\n     * @default true\n     */\n    prepare?: boolean | undefined\n  }\n\n  type ReturnType<abiItem extends AbiItem | string | readonly string[]> =\n    abiItem extends string\n      ? abitype.ParseAbiItem<abiItem>\n      : abiItem extends readonly string[]\n        ? abitype.ParseAbiItem<abiItem>\n        : abiItem\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Extracts an {@link ox#AbiItem.AbiItem} from an {@link ox#Abi.Abi} given a name and optional arguments.\n *\n * @example\n * ABI Items can be extracted by their name using the `name` option:\n *\n * ```ts twoslash\n * import { Abi, AbiItem } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiItem.fromAbi(abi, 'Transfer') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Extracting by Selector\n *\n * ABI Items can be extract by their selector when {@link ox#Hex.Hex} is provided to `name`.\n *\n * ```ts twoslash\n * import { Abi, AbiItem } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n * const item = AbiItem.fromAbi(abi, '0x095ea7b3') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * :::note\n *\n * Extracting via a hex selector is useful when extracting an ABI Item from an `eth_call` RPC response,\n * a Transaction `input`, or from Event Log `topics`.\n *\n * :::\n *\n * @param abi - The ABI to extract from.\n * @param name - The name (or selector) of the ABI item to extract.\n * @param options - Extraction options.\n * @returns The ABI item.\n */\nexport function fromAbi<\n  const abi extends Abi.Abi | readonly unknown[],\n  name extends Name<abi>,\n  const args extends internal.ExtractArgs<abi, name> | undefined = undefined,\n  //\n  allNames = Name<abi>,\n>(\n  abi: abi | Abi.Abi | readonly unknown[],\n  name: Hex.Hex | (name extends allNames ? name : never),\n  options?: fromAbi.Options<abi, name, args>,\n): fromAbi.ReturnType<abi, name, args> {\n  const { args = [], prepare = true } = (options ??\n    {}) as unknown as fromAbi.Options\n\n  const isSelector = Hex.validate(name, { strict: false })\n  const abiItems = (abi as Abi.Abi).filter((abiItem) => {\n    if (isSelector) {\n      if (abiItem.type === 'function' || abiItem.type === 'error')\n        return getSelector(abiItem) === Hex.slice(name, 0, 4)\n      if (abiItem.type === 'event') return getSignatureHash(abiItem) === name\n      return false\n    }\n    return 'name' in abiItem && abiItem.name === name\n  })\n\n  if (abiItems.length === 0) throw new NotFoundError({ name: name as string })\n  if (abiItems.length === 1)\n    return {\n      ...abiItems[0],\n      ...(prepare ? { hash: getSignatureHash(abiItems[0]!) } : {}),\n    } as never\n\n  let matchedAbiItem: AbiItem | undefined\n  for (const abiItem of abiItems) {\n    if (!('inputs' in abiItem)) continue\n    if (!args || args.length === 0) {\n      if (!abiItem.inputs || abiItem.inputs.length === 0)\n        return {\n          ...abiItem,\n          ...(prepare ? { hash: getSignatureHash(abiItem) } : {}),\n        } as never\n      continue\n    }\n    if (!abiItem.inputs) continue\n    if (abiItem.inputs.length === 0) continue\n    if (abiItem.inputs.length !== args.length) continue\n    const matched = args.every((arg, index) => {\n      const abiParameter = 'inputs' in abiItem && abiItem.inputs![index]\n      if (!abiParameter) return false\n      return internal.isArgOfType(arg, abiParameter)\n    })\n    if (matched) {\n      // Check for ambiguity against already matched parameters (e.g. `address` vs `bytes20`).\n      if (\n        matchedAbiItem &&\n        'inputs' in matchedAbiItem &&\n        matchedAbiItem.inputs\n      ) {\n        const ambiguousTypes = internal.getAmbiguousTypes(\n          abiItem.inputs,\n          matchedAbiItem.inputs,\n          args as readonly unknown[],\n        )\n        if (ambiguousTypes)\n          throw new AmbiguityError(\n            {\n              abiItem,\n              type: ambiguousTypes[0]!,\n            },\n            {\n              abiItem: matchedAbiItem,\n              type: ambiguousTypes[1]!,\n            },\n          )\n      }\n\n      matchedAbiItem = abiItem\n    }\n  }\n\n  const abiItem = (() => {\n    if (matchedAbiItem) return matchedAbiItem\n    const [abiItem, ...overloads] = abiItems\n    return { ...abiItem!, overloads }\n  })()\n\n  if (!abiItem) throw new NotFoundError({ name: name as string })\n  return {\n    ...abiItem,\n    ...(prepare ? { hash: getSignatureHash(abiItem) } : {}),\n  } as never\n}\n\nexport declare namespace fromAbi {\n  type Options<\n    abi extends Abi.Abi | readonly unknown[] = Abi.Abi,\n    name extends Name<abi> = Name<abi>,\n    args extends\n      | internal.ExtractArgs<abi, name>\n      | undefined = internal.ExtractArgs<abi, name>,\n    ///\n    allArgs = internal.ExtractArgs<abi, name>,\n  > = {\n    /**\n     * Whether or not to prepare the extracted item (optimization for encoding performance).\n     * When `true`, the `hash` property is computed and included in the returned value.\n     *\n     * @default true\n     */\n    prepare?: boolean | undefined\n  } & UnionCompute<\n    readonly [] extends allArgs\n      ? {\n          args?:\n            | allArgs // show all options\n            // infer value, widen inferred value of `args` conditionally to match `allArgs`\n            | (abi extends Abi.Abi\n                ? args extends allArgs\n                  ? internal.Widen<args>\n                  : never\n                : never)\n            | undefined\n        }\n      : {\n          args?:\n            | allArgs // show all options\n            | (internal.Widen<args> & (args extends allArgs ? unknown : never)) // infer value, widen inferred value of `args` match `allArgs` (e.g. avoid union `args: readonly [123n] | readonly [bigint]`)\n            | undefined\n        }\n  >\n\n  type ReturnType<\n    abi extends Abi.Abi | readonly unknown[] = Abi.Abi,\n    name extends Name<abi> = Name<abi>,\n    args extends\n      | internal.ExtractArgs<abi, name>\n      | undefined = internal.ExtractArgs<abi, name>,\n    fallback = AbiItem,\n  > = abi extends Abi.Abi\n    ? Abi.Abi extends abi\n      ? fallback\n      : internal.ExtractForArgs<\n          abi,\n          name,\n          args extends internal.ExtractArgs<abi, name>\n            ? args\n            : internal.ExtractArgs<abi, name>\n        >\n    : fallback\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Computes the [4-byte selector](https://solidity-by-example.org/function-selector/) for an {@link ox#AbiItem.AbiItem}.\n *\n * Useful for computing function selectors for calldata.\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const selector = AbiItem.getSelector('function ownerOf(uint256 tokenId)')\n * // @log: '0x6352211e'\n * ```\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiItem } from 'ox'\n *\n * const erc20Abi = Abi.from([...])\n *\n * const selector = AbiItem.getSelector(erc20Abi, 'ownerOf')\n * // @log: '0x6352211e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const selector = AbiItem.getSelector({\n *   inputs: [{ type: 'uint256' }],\n *   name: 'ownerOf',\n *   outputs: [],\n *   stateMutability: 'view',\n *   type: 'function'\n * })\n * // @log: '0x6352211e'\n * ```\n *\n * @param abiItem - The ABI item to compute the selector for. Can be a signature or an ABI item for an error, event, function, etc.\n * @returns The first 4 bytes of the {@link ox#Hash.(keccak256:function)} hash of the function signature.\n */\nexport function getSelector<\n  abi extends Abi.Abi | readonly unknown[],\n  name extends Name<abi>,\n>(abi: abi | Abi.Abi | readonly unknown[], name: name): Hex.Hex\nexport function getSelector(abiItem: string | AbiItem): Hex.Hex\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function getSelector(\n  ...parameters:\n    | [abi: Abi.Abi | readonly unknown[], name: string]\n    | [string | AbiItem]\n): Hex.Hex {\n  const abiItem = (() => {\n    if (Array.isArray(parameters[0])) {\n      const [abi, name] = parameters as [Abi.Abi | readonly unknown[], string]\n      return fromAbi(abi, name)\n    }\n    return parameters[0] as string | AbiItem\n  })()\n  return Hex.slice(getSignatureHash(abiItem), 0, 4)\n}\n\nexport declare namespace getSelector {\n  type ErrorType =\n    | getSignatureHash.ErrorType\n    | Hex.slice.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Computes the stringified signature for a given {@link ox#AbiItem.AbiItem}.\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const signature = AbiItem.getSignature('function ownerOf(uint256 tokenId)')\n * // @log: 'ownerOf(uint256)'\n * ```\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiItem } from 'ox'\n *\n * const erc20Abi = Abi.from([...])\n *\n * const signature = AbiItem.getSignature(erc20Abi, 'ownerOf')\n * // @log: 'ownerOf(uint256)'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const signature = AbiItem.getSignature({\n *   name: 'ownerOf',\n *   type: 'function',\n *   inputs: [{ name: 'tokenId', type: 'uint256' }],\n *   outputs: [],\n *   stateMutability: 'view',\n * })\n * // @log: 'ownerOf(uint256)'\n * ```\n *\n * @param abiItem - The ABI Item to compute the signature for.\n * @returns The stringified signature of the ABI Item.\n */\nexport function getSignature<\n  abi extends Abi.Abi | readonly unknown[],\n  name extends Name<abi>,\n>(abi: abi | Abi.Abi | readonly unknown[], name: name): string\nexport function getSignature(abiItem: string | AbiItem): string\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function getSignature(\n  ...parameters:\n    | [abi: Abi.Abi | readonly unknown[], name: string]\n    | [string | AbiItem]\n): string {\n  const abiItem = (() => {\n    if (Array.isArray(parameters[0])) {\n      const [abi, name] = parameters as [Abi.Abi | readonly unknown[], string]\n      return fromAbi(abi, name)\n    }\n    return parameters[0] as string | AbiItem\n  })()\n  const signature = (() => {\n    if (typeof abiItem === 'string') return abiItem\n    return abitype.formatAbiItem(abiItem)\n  })()\n  return internal.normalizeSignature(signature)\n}\n\nexport declare namespace getSignature {\n  type ErrorType =\n    | internal.normalizeSignature.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Computes the signature hash for an {@link ox#AbiItem.AbiItem}.\n *\n * Useful for computing Event Topic values.\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const hash = AbiItem.getSignatureHash('event Transfer(address indexed from, address indexed to, uint256 amount)')\n * // @log: '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef'\n * ```\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiItem } from 'ox'\n *\n * const erc20Abi = Abi.from([...])\n *\n * const hash = AbiItem.getSignatureHash(erc20Abi, 'Transfer')\n * // @log: '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const hash = AbiItem.getSignatureHash({\n *   name: 'Transfer',\n *   type: 'event',\n *   inputs: [\n *     { name: 'from', type: 'address', indexed: true },\n *     { name: 'to', type: 'address', indexed: true },\n *     { name: 'amount', type: 'uint256', indexed: false },\n *   ],\n * })\n * // @log: '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef'\n * ```\n *\n * @param abiItem - The ABI Item to compute the signature hash for.\n * @returns The {@link ox#Hash.(keccak256:function)} hash of the ABI item's signature.\n */\nexport function getSignatureHash<\n  abi extends Abi.Abi | readonly unknown[],\n  name extends Name<abi>,\n>(abi: abi | Abi.Abi | readonly unknown[], name: name): Hex.Hex\nexport function getSignatureHash(abiItem: string | AbiItem): Hex.Hex\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function getSignatureHash(\n  ...parameters:\n    | [abi: Abi.Abi | readonly unknown[], name: string]\n    | [string | AbiItem]\n): Hex.Hex {\n  const abiItem = (() => {\n    if (Array.isArray(parameters[0])) {\n      const [abi, name] = parameters as [Abi.Abi | readonly unknown[], string]\n      return fromAbi(abi, name)\n    }\n    return parameters[0] as string | AbiItem\n  })()\n  if (typeof abiItem !== 'string' && 'hash' in abiItem && abiItem.hash)\n    return abiItem.hash as Hex.Hex\n  return Hash.keccak256(Hex.fromString(getSignature(abiItem)))\n}\n\nexport declare namespace getSignatureHash {\n  type ErrorType =\n    | getSignature.ErrorType\n    | Hash.keccak256.ErrorType\n    | Hex.fromString.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Throws when ambiguous types are found on overloaded ABI items.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from(['function foo(address)', 'function foo(bytes20)'])\n * AbiFunction.fromAbi(foo, 'foo', {\n *   args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n * })\n * // @error: AbiItem.AmbiguityError: Found ambiguous types in overloaded ABI Items.\n * // @error: `bytes20` in `foo(bytes20)`, and\n * // @error: `address` in `foo(address)`\n * // @error: These types encode differently and cannot be distinguished at runtime.\n * // @error: Remove one of the ambiguous items in the ABI.\n * ```\n *\n * ### Solution\n *\n * Remove one of the ambiguous types from the ABI.\n *\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function foo(bytes20)' // [!code --]\n * ])\n * AbiFunction.fromAbi(foo, 'foo', {\n *   args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n * })\n * // @error: AbiItem.AmbiguityError: Found ambiguous types in overloaded ABI Items.\n * // @error: `bytes20` in `foo(bytes20)`, and\n * // @error: `address` in `foo(address)`\n * // @error: These types encode differently and cannot be distinguished at runtime.\n * // @error: Remove one of the ambiguous items in the ABI.\n * ```\n */\nexport class AmbiguityError extends Errors.BaseError {\n  override readonly name = 'AbiItem.AmbiguityError'\n  constructor(\n    x: { abiItem: Abi.Abi[number]; type: string },\n    y: { abiItem: Abi.Abi[number]; type: string },\n  ) {\n    super('Found ambiguous types in overloaded ABI Items.', {\n      metaMessages: [\n        // TODO: abitype to add support for signature-formatted ABI items.\n        `\\`${x.type}\\` in \\`${internal.normalizeSignature(abitype.formatAbiItem(x.abiItem))}\\`, and`,\n        `\\`${y.type}\\` in \\`${internal.normalizeSignature(abitype.formatAbiItem(y.abiItem))}\\``,\n        '',\n        'These types encode differently and cannot be distinguished at runtime.',\n        'Remove one of the ambiguous items in the ABI.',\n      ],\n    })\n  }\n}\n\n/**\n * Throws when an ABI item is not found in the ABI.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)'\n * ])\n * AbiFunction.fromAbi(foo, 'baz')\n * // @error: AbiItem.NotFoundError: ABI function with name \"baz\" not found.\n * ```\n *\n * ### Solution\n *\n * Ensure the ABI item exists on the ABI.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)',\n *   'function baz(bool)' // [!code ++]\n * ])\n * AbiFunction.fromAbi(foo, 'baz')\n * ```\n */\nexport class NotFoundError extends Errors.BaseError {\n  override readonly name = 'AbiItem.NotFoundError'\n  constructor({\n    name,\n    data,\n    type = 'item',\n  }: {\n    name?: string | undefined\n    data?: Hex.Hex | undefined\n    type?: string | undefined\n  }) {\n    const selector = (() => {\n      if (name) return ` with name \"${name}\"`\n      if (data) return ` with data \"${data}\"`\n      return ''\n    })()\n    super(`ABI ${type}${selector} not found.`)\n  }\n}\n\n/**\n * Throws when the selector size is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)'\n * ])\n * AbiFunction.fromAbi(foo, '0xaaa')\n * // @error: AbiItem.InvalidSelectorSizeError: Selector size is invalid. Expected 4 bytes. Received 2 bytes (\"0xaaa\").\n * ```\n *\n * ### Solution\n *\n * Ensure the selector size is 4 bytes.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)'\n * ])\n * AbiFunction.fromAbi(foo, '0x7af82b1a')\n * ```\n */\nexport class InvalidSelectorSizeError extends Errors.BaseError {\n  override readonly name = 'AbiItem.InvalidSelectorSizeError'\n  constructor({ data }: { data: Hex.Hex }) {\n    super(\n      `Selector size is invalid. Expected 4 bytes. Received ${Hex.size(data)} bytes (\"${data}\").`,\n    )\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}