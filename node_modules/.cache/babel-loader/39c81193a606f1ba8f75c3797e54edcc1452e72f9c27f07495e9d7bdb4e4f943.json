{"ast":null,"code":"import _classPrivateFieldInitSpec from \"/Users/mac/Desktop/topl1/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _classPrivateFieldSet from \"/Users/mac/Desktop/topl1/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet2.js\";\nimport _classPrivateFieldGet from \"/Users/mac/Desktop/topl1/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet2.js\";\nimport { ZeroHash } from \"../constants/index.js\";\nimport { concat, dataLength, getBigInt, getBytes, getNumber, hexlify, toBeArray, isHexString, zeroPadValue, assertArgument, assertPrivate } from \"../utils/index.js\";\n// Constants\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_2 = BigInt(2);\nconst BN_27 = BigInt(27);\nconst BN_28 = BigInt(28);\nconst BN_35 = BigInt(35);\nconst BN_N = BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\nconst BN_N_2 = BN_N / BN_2; // Must be integer (floor) division; do NOT shifts\nconst inspect = Symbol.for(\"nodejs.util.inspect.custom\");\nconst _guard = {};\nfunction toUint256(value) {\n  return zeroPadValue(toBeArray(value), 32);\n}\n/**\n *  A Signature  @TODO\n *\n *\n *  @_docloc: api/crypto:Signing\n */\nvar _r2 = /*#__PURE__*/new WeakMap();\nvar _s = /*#__PURE__*/new WeakMap();\nvar _v2 = /*#__PURE__*/new WeakMap();\nvar _networkV = /*#__PURE__*/new WeakMap();\nexport class Signature {\n  /**\n   *  The ``r`` value for a signature.\n   *\n   *  This represents the ``x`` coordinate of a \"reference\" or\n   *  challenge point, from which the ``y`` can be computed.\n   */\n  get r() {\n    return _classPrivateFieldGet(_r2, this);\n  }\n  set r(value) {\n    assertArgument(dataLength(value) === 32, \"invalid r\", \"value\", value);\n    _classPrivateFieldSet(_r2, this, hexlify(value));\n  }\n  /**\n   *  The ``s`` value for a signature.\n   */\n  get s() {\n    assertArgument(parseInt(_classPrivateFieldGet(_s, this).substring(0, 3)) < 8, \"non-canonical s; use ._s\", \"s\", _classPrivateFieldGet(_s, this));\n    return _classPrivateFieldGet(_s, this);\n  }\n  set s(_value) {\n    assertArgument(dataLength(_value) === 32, \"invalid s\", \"value\", _value);\n    _classPrivateFieldSet(_s, this, hexlify(_value));\n  }\n  /**\n   *  Return the s value, unchecked for EIP-2 compliance.\n   *\n   *  This should generally not be used and is for situations where\n   *  a non-canonical S value might be relevant, such as Frontier blocks\n   *  that were mined prior to EIP-2 or invalid Authorization List\n   *  signatures.\n   */\n  get _s() {\n    return _classPrivateFieldGet(_s, this);\n  }\n  /**\n   *  Returns true if the Signature is valid for [[link-eip-2]] signatures.\n   */\n  isValid() {\n    const s = BigInt(_classPrivateFieldGet(_s, this));\n    return s <= BN_N_2;\n  }\n  /**\n   *  The ``v`` value for a signature.\n   *\n   *  Since a given ``x`` value for ``r`` has two possible values for\n   *  its correspondin ``y``, the ``v`` indicates which of the two ``y``\n   *  values to use.\n   *\n   *  It is normalized to the values ``27`` or ``28`` for legacy\n   *  purposes.\n   */\n  get v() {\n    return _classPrivateFieldGet(_v2, this);\n  }\n  set v(value) {\n    const v = getNumber(value, \"value\");\n    assertArgument(v === 27 || v === 28, \"invalid v\", \"v\", value);\n    _classPrivateFieldSet(_v2, this, v);\n  }\n  /**\n   *  The EIP-155 ``v`` for legacy transactions. For non-legacy\n   *  transactions, this value is ``null``.\n   */\n  get networkV() {\n    return _classPrivateFieldGet(_networkV, this);\n  }\n  /**\n   *  The chain ID for EIP-155 legacy transactions. For non-legacy\n   *  transactions, this value is ``null``.\n   */\n  get legacyChainId() {\n    const v = this.networkV;\n    if (v == null) {\n      return null;\n    }\n    return Signature.getChainId(v);\n  }\n  /**\n   *  The ``yParity`` for the signature.\n   *\n   *  See ``v`` for more details on how this value is used.\n   */\n  get yParity() {\n    return this.v === 27 ? 0 : 1;\n  }\n  /**\n   *  The [[link-eip-2098]] compact representation of the ``yParity``\n   *  and ``s`` compacted into a single ``bytes32``.\n   */\n  get yParityAndS() {\n    // The EIP-2098 compact representation\n    const yParityAndS = getBytes(this.s);\n    if (this.yParity) {\n      yParityAndS[0] |= 0x80;\n    }\n    return hexlify(yParityAndS);\n  }\n  /**\n   *  The [[link-eip-2098]] compact representation.\n   */\n  get compactSerialized() {\n    return concat([this.r, this.yParityAndS]);\n  }\n  /**\n   *  The serialized representation.\n   */\n  get serialized() {\n    return concat([this.r, this.s, this.yParity ? \"0x1c\" : \"0x1b\"]);\n  }\n  /**\n   *  @private\n   */\n  constructor(guard, r, s, v) {\n    _classPrivateFieldInitSpec(this, _r2, void 0);\n    _classPrivateFieldInitSpec(this, _s, void 0);\n    _classPrivateFieldInitSpec(this, _v2, void 0);\n    _classPrivateFieldInitSpec(this, _networkV, void 0);\n    assertPrivate(guard, _guard, \"Signature\");\n    _classPrivateFieldSet(_r2, this, r);\n    _classPrivateFieldSet(_s, this, s);\n    _classPrivateFieldSet(_v2, this, v);\n    _classPrivateFieldSet(_networkV, this, null);\n  }\n  /**\n   *  Returns the canonical signature.\n   *\n   *  This is only necessary when dealing with legacy transaction which\n   *  did not enforce canonical S values (i.e. [[link-eip-2]]. Most\n   *  developers should never require this.\n   */\n  getCanonical() {\n    if (this.isValid()) {\n      return this;\n    }\n    // Compute the canonical signature; s' = N - s, v = !v\n    const s = BN_N - BigInt(this._s);\n    const v = 55 - this.v;\n    const result = new Signature(_guard, this.r, toUint256(s), v);\n    // Populate the networkV if necessary\n    if (this.networkV) {\n      _classPrivateFieldSet(_networkV, result, this.networkV);\n    }\n    return result;\n  }\n  /**\n   *  Returns a new identical [[Signature]].\n   */\n  clone() {\n    const clone = new Signature(_guard, this.r, this._s, this.v);\n    if (this.networkV) {\n      _classPrivateFieldSet(_networkV, clone, this.networkV);\n    }\n    return clone;\n  }\n  /**\n   *  Returns a representation that is compatible with ``JSON.stringify``.\n   */\n  toJSON() {\n    const networkV = this.networkV;\n    return {\n      _type: \"signature\",\n      networkV: networkV != null ? networkV.toString() : null,\n      r: this.r,\n      s: this._s,\n      v: this.v\n    };\n  }\n  [inspect]() {\n    return this.toString();\n  }\n  toString() {\n    if (this.isValid()) {\n      return \"Signature { r: \".concat(this.r, \", s: \").concat(this._s, \", v: \").concat(this.v, \" }\");\n    }\n    return \"Signature { r: \".concat(this.r, \", s: \").concat(this._s, \", v: \").concat(this.v, \", valid: false }\");\n  }\n  /**\n   *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.\n   *\n   *  @example:\n   *    Signature.getChainId(45)\n   *    //_result:\n   *\n   *    Signature.getChainId(46)\n   *    //_result:\n   */\n  static getChainId(v) {\n    const bv = getBigInt(v, \"v\");\n    // The v is not an EIP-155 v, so it is the unspecified chain ID\n    if (bv == BN_27 || bv == BN_28) {\n      return BN_0;\n    }\n    // Bad value for an EIP-155 v\n    assertArgument(bv >= BN_35, \"invalid EIP-155 v\", \"v\", v);\n    return (bv - BN_35) / BN_2;\n  }\n  /**\n   *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.\n   *\n   *  Legacy transactions which use [[link-eip-155]] hijack the ``v``\n   *  property to include the chain ID.\n   *\n   *  @example:\n   *    Signature.getChainIdV(5, 27)\n   *    //_result:\n   *\n   *    Signature.getChainIdV(5, 28)\n   *    //_result:\n   *\n   */\n  static getChainIdV(chainId, v) {\n    return getBigInt(chainId) * BN_2 + BigInt(35 + v - 27);\n  }\n  /**\n   *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,\n   *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.\n   *\n   *  @example:\n   *    // The values 0 and 1 imply v is actually yParity\n   *    Signature.getNormalizedV(0)\n   *    //_result:\n   *\n   *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)\n   *    Signature.getNormalizedV(27)\n   *    //_result:\n   *\n   *    // Legacy EIP-155 transaction (i.e. >= 35)\n   *    Signature.getNormalizedV(46)\n   *    //_result:\n   *\n   *    // Invalid values throw\n   *    Signature.getNormalizedV(5)\n   *    //_error:\n   */\n  static getNormalizedV(v) {\n    const bv = getBigInt(v);\n    if (bv === BN_0 || bv === BN_27) {\n      return 27;\n    }\n    if (bv === BN_1 || bv === BN_28) {\n      return 28;\n    }\n    assertArgument(bv >= BN_35, \"invalid v\", \"v\", v);\n    // Otherwise, EIP-155 v means odd is 27 and even is 28\n    return bv & BN_1 ? 27 : 28;\n  }\n  /**\n   *  Creates a new [[Signature]].\n   *\n   *  If no %%sig%% is provided, a new [[Signature]] is created\n   *  with default values.\n   *\n   *  If %%sig%% is a string, it is parsed.\n   */\n  static from(sig) {\n    function assertError(check, message) {\n      assertArgument(check, message, \"signature\", sig);\n    }\n    ;\n    if (sig == null) {\n      return new Signature(_guard, ZeroHash, ZeroHash, 27);\n    }\n    if (typeof sig === \"string\") {\n      const bytes = getBytes(sig, \"signature\");\n      if (bytes.length === 64) {\n        const r = hexlify(bytes.slice(0, 32));\n        const s = bytes.slice(32, 64);\n        const v = s[0] & 0x80 ? 28 : 27;\n        s[0] &= 0x7f;\n        return new Signature(_guard, r, hexlify(s), v);\n      }\n      if (bytes.length === 65) {\n        const r = hexlify(bytes.slice(0, 32));\n        const s = hexlify(bytes.slice(32, 64));\n        const v = Signature.getNormalizedV(bytes[64]);\n        return new Signature(_guard, r, s, v);\n      }\n      assertError(false, \"invalid raw signature length\");\n    }\n    if (sig instanceof Signature) {\n      return sig.clone();\n    }\n    // Get r\n    const _r = sig.r;\n    assertError(_r != null, \"missing r\");\n    const r = toUint256(_r);\n    // Get s; by any means necessary (we check consistency below)\n    const s = function (s, yParityAndS) {\n      if (s != null) {\n        return toUint256(s);\n      }\n      if (yParityAndS != null) {\n        assertError(isHexString(yParityAndS, 32), \"invalid yParityAndS\");\n        const bytes = getBytes(yParityAndS);\n        bytes[0] &= 0x7f;\n        return hexlify(bytes);\n      }\n      assertError(false, \"missing s\");\n    }(sig.s, sig.yParityAndS);\n    // Get v; by any means necessary (we check consistency below)\n    const {\n      networkV,\n      v\n    } = function (_v, yParityAndS, yParity) {\n      if (_v != null) {\n        const v = getBigInt(_v);\n        return {\n          networkV: v >= BN_35 ? v : undefined,\n          v: Signature.getNormalizedV(v)\n        };\n      }\n      if (yParityAndS != null) {\n        assertError(isHexString(yParityAndS, 32), \"invalid yParityAndS\");\n        return {\n          v: getBytes(yParityAndS)[0] & 0x80 ? 28 : 27\n        };\n      }\n      if (yParity != null) {\n        switch (getNumber(yParity, \"sig.yParity\")) {\n          case 0:\n            return {\n              v: 27\n            };\n          case 1:\n            return {\n              v: 28\n            };\n        }\n        assertError(false, \"invalid yParity\");\n      }\n      assertError(false, \"missing v\");\n    }(sig.v, sig.yParityAndS, sig.yParity);\n    const result = new Signature(_guard, r, s, v);\n    if (networkV) {\n      _classPrivateFieldSet(_networkV, result, networkV);\n    }\n    // If multiple of v, yParity, yParityAndS we given, check they match\n    assertError(sig.yParity == null || getNumber(sig.yParity, \"sig.yParity\") === result.yParity, \"yParity mismatch\");\n    assertError(sig.yParityAndS == null || sig.yParityAndS === result.yParityAndS, \"yParityAndS mismatch\");\n    return result;\n  }\n}","map":{"version":3,"names":["ZeroHash","concat","dataLength","getBigInt","getBytes","getNumber","hexlify","toBeArray","isHexString","zeroPadValue","assertArgument","assertPrivate","BN_0","BigInt","BN_1","BN_2","BN_27","BN_28","BN_35","BN_N","BN_N_2","inspect","Symbol","for","_guard","toUint256","value","_r2","WeakMap","_s","_v2","_networkV","Signature","r","_classPrivateFieldGet","_classPrivateFieldSet","s","parseInt","substring","_value","isValid","v","networkV","legacyChainId","getChainId","yParity","yParityAndS","compactSerialized","serialized","constructor","guard","_classPrivateFieldInitSpec","getCanonical","result","clone","toJSON","_type","toString","bv","getChainIdV","chainId","getNormalizedV","from","sig","assertError","check","message","bytes","length","slice","_r","_v","undefined"],"sources":["/Users/mac/Desktop/topl1/frontend/node_modules/ethers/src.ts/crypto/signature.ts"],"sourcesContent":["\nimport { ZeroHash } from \"../constants/index.js\";\nimport {\n    concat, dataLength, getBigInt, getBytes, getNumber, hexlify,\n    toBeArray, isHexString, zeroPadValue,\n    assertArgument, assertPrivate\n} from \"../utils/index.js\";\n\nimport type {\n    BigNumberish, BytesLike, Numeric\n} from \"../utils/index.js\";\n\n\n// Constants\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_2 = BigInt(2);\nconst BN_27 = BigInt(27);\nconst BN_28 = BigInt(28);\nconst BN_35 = BigInt(35);\nconst BN_N = BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\nconst BN_N_2 = BN_N / BN_2; // Must be integer (floor) division; do NOT shifts\n\nconst inspect = Symbol.for(\"nodejs.util.inspect.custom\");\n\nconst _guard = { };\n\n// @TODO: Allow Uint8Array\n\n/**\n *  A SignatureLike\n *\n *  @_docloc: api/crypto:Signing\n */\nexport type SignatureLike = Signature | string | {\n    r: string;\n    s: string;\n    v: BigNumberish;\n    yParity?: 0 | 1;\n    yParityAndS?: string;\n} | {\n    r: string;\n    yParityAndS: string;\n    yParity?: 0 | 1;\n    s?: string;\n    v?: number;\n} | {\n    r: string;\n    s: string;\n    yParity: 0 | 1;\n    v?: BigNumberish;\n    yParityAndS?: string;\n};\n\nfunction toUint256(value: BigNumberish): string {\n    return zeroPadValue(toBeArray(value), 32);\n}\n\n/**\n *  A Signature  @TODO\n *\n *\n *  @_docloc: api/crypto:Signing\n */\nexport class Signature {\n    #r: string;\n    #s: string;\n    #v: 27 | 28;\n    #networkV: null | bigint;\n\n    /**\n     *  The ``r`` value for a signature.\n     *\n     *  This represents the ``x`` coordinate of a \"reference\" or\n     *  challenge point, from which the ``y`` can be computed.\n     */\n    get r(): string { return this.#r; }\n    set r(value: BytesLike) {\n        assertArgument(dataLength(value) === 32, \"invalid r\", \"value\", value);\n        this.#r = hexlify(value);\n    }\n\n    /**\n     *  The ``s`` value for a signature.\n     */\n    get s(): string {\n        assertArgument(parseInt(this.#s.substring(0, 3)) < 8, \"non-canonical s; use ._s\", \"s\", this.#s);\n        return this.#s;\n    }\n    set s(_value: BytesLike) {\n        assertArgument(dataLength(_value) === 32, \"invalid s\", \"value\", _value);\n        this.#s = hexlify(_value);\n    }\n\n    /**\n     *  Return the s value, unchecked for EIP-2 compliance.\n     *\n     *  This should generally not be used and is for situations where\n     *  a non-canonical S value might be relevant, such as Frontier blocks\n     *  that were mined prior to EIP-2 or invalid Authorization List\n     *  signatures.\n     */\n    get _s(): string { return this.#s; }\n\n    /**\n     *  Returns true if the Signature is valid for [[link-eip-2]] signatures.\n     */\n    isValid(): boolean {\n        const s = BigInt(this.#s);\n        return (s <= BN_N_2);\n    }\n\n    /**\n     *  The ``v`` value for a signature.\n     *\n     *  Since a given ``x`` value for ``r`` has two possible values for\n     *  its correspondin ``y``, the ``v`` indicates which of the two ``y``\n     *  values to use.\n     *\n     *  It is normalized to the values ``27`` or ``28`` for legacy\n     *  purposes.\n     */\n    get v(): 27 | 28 { return this.#v; }\n    set v(value: BigNumberish) {\n        const v = getNumber(value, \"value\");\n        assertArgument(v === 27 || v === 28, \"invalid v\", \"v\", value);\n        this.#v = v;\n    }\n\n    /**\n     *  The EIP-155 ``v`` for legacy transactions. For non-legacy\n     *  transactions, this value is ``null``.\n     */\n    get networkV(): null | bigint { return this.#networkV; }\n\n    /**\n     *  The chain ID for EIP-155 legacy transactions. For non-legacy\n     *  transactions, this value is ``null``.\n     */\n    get legacyChainId(): null | bigint {\n        const v = this.networkV;\n        if (v == null) { return null; }\n        return Signature.getChainId(v);\n    }\n\n    /**\n     *  The ``yParity`` for the signature.\n     *\n     *  See ``v`` for more details on how this value is used.\n     */\n    get yParity(): 0 | 1 {\n        return (this.v === 27) ? 0: 1;\n    }\n\n    /**\n     *  The [[link-eip-2098]] compact representation of the ``yParity``\n     *  and ``s`` compacted into a single ``bytes32``.\n     */\n    get yParityAndS(): string {\n        // The EIP-2098 compact representation\n        const yParityAndS = getBytes(this.s);\n        if (this.yParity) { yParityAndS[0] |= 0x80; }\n        return hexlify(yParityAndS);\n    }\n\n    /**\n     *  The [[link-eip-2098]] compact representation.\n     */\n    get compactSerialized(): string {\n        return concat([ this.r, this.yParityAndS ]);\n    }\n\n    /**\n     *  The serialized representation.\n     */\n    get serialized(): string {\n        return concat([ this.r, this.s, (this.yParity ? \"0x1c\": \"0x1b\") ]);\n    }\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, r: string, s: string, v: 27 | 28) {\n        assertPrivate(guard, _guard, \"Signature\");\n        this.#r = r;\n        this.#s = s;\n        this.#v = v;\n        this.#networkV = null;\n    }\n\n    /**\n     *  Returns the canonical signature.\n     *\n     *  This is only necessary when dealing with legacy transaction which\n     *  did not enforce canonical S values (i.e. [[link-eip-2]]. Most\n     *  developers should never require this.\n     */\n    getCanonical(): Signature {\n        if (this.isValid()) { return this; }\n\n        // Compute the canonical signature; s' = N - s, v = !v\n        const s = BN_N - BigInt(this._s);\n        const v = <27 | 28>(55 - this.v);\n        const result = new Signature(_guard, this.r, toUint256(s), v);\n\n        // Populate the networkV if necessary\n        if (this.networkV) { result.#networkV =  this.networkV; }\n\n        return result;\n    }\n\n    /**\n     *  Returns a new identical [[Signature]].\n     */\n    clone(): Signature {\n        const clone = new Signature(_guard, this.r, this._s, this.v);\n        if (this.networkV) { clone.#networkV = this.networkV; }\n        return clone;\n    }\n\n    /**\n     *  Returns a representation that is compatible with ``JSON.stringify``.\n     */\n    toJSON(): any {\n        const networkV = this.networkV;\n        return {\n            _type: \"signature\",\n            networkV: ((networkV != null) ? networkV.toString(): null),\n            r: this.r, s: this._s, v: this.v,\n        };\n    }\n\n    [inspect](): string {\n        return this.toString();\n    }\n\n    toString(): string {\n        if (this.isValid()) {\n            return `Signature { r: ${ this.r }, s: ${ this._s }, v: ${ this.v } }`;\n        }\n        return `Signature { r: ${ this.r }, s: ${ this._s }, v: ${ this.v }, valid: false }`;\n    }\n\n    /**\n     *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.\n     *\n     *  @example:\n     *    Signature.getChainId(45)\n     *    //_result:\n     *\n     *    Signature.getChainId(46)\n     *    //_result:\n     */\n    static getChainId(v: BigNumberish): bigint {\n        const bv = getBigInt(v, \"v\");\n\n        // The v is not an EIP-155 v, so it is the unspecified chain ID\n        if ((bv == BN_27) || (bv == BN_28)) { return BN_0; }\n\n        // Bad value for an EIP-155 v\n        assertArgument(bv >= BN_35, \"invalid EIP-155 v\", \"v\", v);\n\n        return (bv - BN_35) / BN_2;\n    }\n\n    /**\n     *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.\n     *\n     *  Legacy transactions which use [[link-eip-155]] hijack the ``v``\n     *  property to include the chain ID.\n     *\n     *  @example:\n     *    Signature.getChainIdV(5, 27)\n     *    //_result:\n     *\n     *    Signature.getChainIdV(5, 28)\n     *    //_result:\n     *\n     */\n    static getChainIdV(chainId: BigNumberish, v: 27 | 28): bigint {\n        return (getBigInt(chainId) * BN_2) + BigInt(35 + v - 27);\n    }\n\n    /**\n     *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,\n     *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.\n     *\n     *  @example:\n     *    // The values 0 and 1 imply v is actually yParity\n     *    Signature.getNormalizedV(0)\n     *    //_result:\n     *\n     *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)\n     *    Signature.getNormalizedV(27)\n     *    //_result:\n     *\n     *    // Legacy EIP-155 transaction (i.e. >= 35)\n     *    Signature.getNormalizedV(46)\n     *    //_result:\n     *\n     *    // Invalid values throw\n     *    Signature.getNormalizedV(5)\n     *    //_error:\n     */\n    static getNormalizedV(v: BigNumberish): 27 | 28 {\n        const bv = getBigInt(v);\n\n        if (bv === BN_0 || bv === BN_27) { return 27; }\n        if (bv === BN_1 || bv === BN_28) { return 28; }\n\n        assertArgument(bv >= BN_35, \"invalid v\", \"v\", v);\n\n        // Otherwise, EIP-155 v means odd is 27 and even is 28\n        return (bv & BN_1) ? 27: 28;\n    }\n\n    /**\n     *  Creates a new [[Signature]].\n     *\n     *  If no %%sig%% is provided, a new [[Signature]] is created\n     *  with default values.\n     *\n     *  If %%sig%% is a string, it is parsed.\n     */\n    static from(sig?: SignatureLike): Signature {\n        function assertError(check: unknown, message: string): asserts check {\n            assertArgument(check, message, \"signature\", sig);\n        };\n\n        if (sig == null) {\n            return new Signature(_guard, ZeroHash, ZeroHash, 27);\n        }\n\n        if (typeof(sig) === \"string\") {\n            const bytes = getBytes(sig, \"signature\");\n            if (bytes.length === 64) {\n                const r = hexlify(bytes.slice(0, 32));\n                const s = bytes.slice(32, 64);\n                const v = (s[0] & 0x80) ? 28: 27;\n                s[0] &= 0x7f;\n                return new Signature(_guard, r, hexlify(s), v);\n            }\n\n            if (bytes.length === 65) {\n                const r = hexlify(bytes.slice(0, 32));\n                const s = hexlify(bytes.slice(32, 64));\n                const v = Signature.getNormalizedV(bytes[64]);\n                return new Signature(_guard, r, s, v);\n            }\n\n            assertError(false, \"invalid raw signature length\");\n        }\n\n        if (sig instanceof Signature) { return sig.clone(); }\n\n        // Get r\n        const _r = sig.r;\n        assertError(_r != null, \"missing r\");\n        const r = toUint256(_r);\n\n        // Get s; by any means necessary (we check consistency below)\n        const s = (function(s?: string, yParityAndS?: string) {\n            if (s != null) { return toUint256(s); }\n\n            if (yParityAndS != null) {\n                assertError(isHexString(yParityAndS, 32), \"invalid yParityAndS\");\n                const bytes = getBytes(yParityAndS);\n                bytes[0] &= 0x7f;\n                return hexlify(bytes);\n            }\n\n            assertError(false, \"missing s\");\n        })(sig.s, sig.yParityAndS);\n\n        // Get v; by any means necessary (we check consistency below)\n        const { networkV, v } = (function(_v?: BigNumberish, yParityAndS?: string, yParity?: Numeric): { networkV?: bigint, v: 27 | 28 } {\n            if (_v != null) {\n                const v = getBigInt(_v);\n                return {\n                    networkV: ((v >= BN_35) ? v: undefined),\n                    v: Signature.getNormalizedV(v)\n                };\n            }\n\n            if (yParityAndS != null) {\n                assertError(isHexString(yParityAndS, 32), \"invalid yParityAndS\");\n                return { v: ((getBytes(yParityAndS)[0] & 0x80) ? 28: 27) };\n            }\n\n            if (yParity != null) {\n                switch (getNumber(yParity, \"sig.yParity\")) {\n                    case 0: return { v: 27 };\n                    case 1: return { v: 28 };\n                }\n                assertError(false, \"invalid yParity\");\n            }\n\n            assertError(false, \"missing v\");\n        })(sig.v, sig.yParityAndS, sig.yParity);\n\n        const result = new Signature(_guard, r, s, v);\n        if (networkV) { result.#networkV =  networkV; }\n\n        // If multiple of v, yParity, yParityAndS we given, check they match\n        assertError(sig.yParity == null || getNumber(sig.yParity, \"sig.yParity\") === result.yParity, \"yParity mismatch\");\n        assertError(sig.yParityAndS == null || sig.yParityAndS === result.yParityAndS, \"yParityAndS mismatch\");\n\n        return result;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}