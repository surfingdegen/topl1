{"ast":null,"code":"import _objectSpread from \"/Users/mac/Desktop/topl1/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { SocketClosedError, TimeoutError } from '../../errors/request.js';\nimport { createBatchScheduler } from '../promise/createBatchScheduler.js';\nimport { withTimeout } from '../promise/withTimeout.js';\nimport { idCache } from './id.js';\nexport const socketClientCache = /*#__PURE__*/new Map();\nexport async function getSocketRpcClient(parameters) {\n  const {\n    getSocket,\n    keepAlive = true,\n    key = 'socket',\n    reconnect = true,\n    url\n  } = parameters;\n  const {\n    interval: keepAliveInterval = 30000\n  } = typeof keepAlive === 'object' ? keepAlive : {};\n  const {\n    attempts = 5,\n    delay = 2000\n  } = typeof reconnect === 'object' ? reconnect : {};\n  const id = JSON.stringify({\n    keepAlive,\n    key,\n    url,\n    reconnect\n  });\n  let socketClient = socketClientCache.get(id);\n  // If the socket already exists, return it.\n  if (socketClient) return socketClient;\n  let reconnectCount = 0;\n  const {\n    schedule\n  } = createBatchScheduler({\n    id,\n    fn: async () => {\n      // Set up a cache for incoming \"synchronous\" requests.\n      const requests = new Map();\n      // Set up a cache for subscriptions (eth_subscribe).\n      const subscriptions = new Map();\n      let error;\n      let socket;\n      let keepAliveTimer;\n      let reconnectInProgress = false;\n      function attemptReconnect() {\n        // Attempt to reconnect.\n        if (reconnect && reconnectCount < attempts) {\n          var _socket;\n          if (reconnectInProgress) return;\n          reconnectInProgress = true;\n          reconnectCount++;\n          // Make sure the previous socket is definitely closed.\n          (_socket = socket) === null || _socket === void 0 || _socket.close();\n          setTimeout(async () => {\n            // biome-ignore lint/suspicious/noConsole: _\n            await setup().catch(console.error);\n            reconnectInProgress = false;\n          }, delay);\n        }\n        // Otherwise, clear all requests and subscriptions.\n        else {\n          requests.clear();\n          subscriptions.clear();\n        }\n      }\n      // Set up socket implementation.\n      async function setup() {\n        const result = await getSocket({\n          onClose() {\n            // Notify all requests and subscriptions of the closure error.\n            for (const request of requests.values()) {\n              var _request$onError;\n              (_request$onError = request.onError) === null || _request$onError === void 0 || _request$onError.call(request, new SocketClosedError({\n                url\n              }));\n            }\n            for (const subscription of subscriptions.values()) {\n              var _subscription$onError;\n              (_subscription$onError = subscription.onError) === null || _subscription$onError === void 0 || _subscription$onError.call(subscription, new SocketClosedError({\n                url\n              }));\n            }\n            attemptReconnect();\n          },\n          onError(error_) {\n            error = error_;\n            // Notify all requests and subscriptions of the error.\n            for (const request of requests.values()) {\n              var _request$onError2;\n              (_request$onError2 = request.onError) === null || _request$onError2 === void 0 || _request$onError2.call(request, error);\n            }\n            for (const subscription of subscriptions.values()) {\n              var _subscription$onError2;\n              (_subscription$onError2 = subscription.onError) === null || _subscription$onError2 === void 0 || _subscription$onError2.call(subscription, error);\n            }\n            attemptReconnect();\n          },\n          onOpen() {\n            error = undefined;\n            reconnectCount = 0;\n          },\n          onResponse(data) {\n            const isSubscription = data.method === 'eth_subscription';\n            const id = isSubscription ? data.params.subscription : data.id;\n            const cache = isSubscription ? subscriptions : requests;\n            const callback = cache.get(id);\n            if (callback) callback.onResponse(data);\n            if (!isSubscription) cache.delete(id);\n          }\n        });\n        socket = result;\n        if (keepAlive) {\n          if (keepAliveTimer) clearInterval(keepAliveTimer);\n          keepAliveTimer = setInterval(() => {\n            var _socket$ping, _socket2;\n            return (_socket$ping = (_socket2 = socket).ping) === null || _socket$ping === void 0 ? void 0 : _socket$ping.call(_socket2);\n          }, keepAliveInterval);\n        }\n        if (reconnect && subscriptions.size > 0) {\n          const subscriptionEntries = subscriptions.entries();\n          for (const [key, {\n            onResponse,\n            body,\n            onError\n          }] of subscriptionEntries) {\n            var _socketClient;\n            if (!body) continue;\n            subscriptions.delete(key);\n            (_socketClient = socketClient) === null || _socketClient === void 0 || _socketClient.request({\n              body,\n              onResponse,\n              onError\n            });\n          }\n        }\n        return result;\n      }\n      await setup();\n      error = undefined;\n      // Create a new socket instance.\n      socketClient = {\n        close() {\n          keepAliveTimer && clearInterval(keepAliveTimer);\n          socket.close();\n          socketClientCache.delete(id);\n        },\n        get socket() {\n          return socket;\n        },\n        request(_ref) {\n          var _body$id, _body$params;\n          let {\n            body,\n            onError,\n            onResponse\n          } = _ref;\n          if (error && onError) onError(error);\n          const id = (_body$id = body.id) !== null && _body$id !== void 0 ? _body$id : idCache.take();\n          const callback = response => {\n            if (typeof response.id === 'number' && id !== response.id) return;\n            // If we are subscribing to a topic, we want to set up a listener for incoming\n            // messages.\n            if (body.method === 'eth_subscribe' && typeof response.result === 'string') subscriptions.set(response.result, {\n              onResponse: callback,\n              onError,\n              body\n            });\n            onResponse(response);\n          };\n          // If we are unsubscribing from a topic, remove the listener immediately\n          // to prevent it from being re-subscribed on reconnect.\n          if (body.method === 'eth_unsubscribe') subscriptions.delete((_body$params = body.params) === null || _body$params === void 0 ? void 0 : _body$params[0]);\n          requests.set(id, {\n            onResponse: callback,\n            onError\n          });\n          try {\n            socket.request({\n              body: _objectSpread({\n                jsonrpc: '2.0',\n                id\n              }, body)\n            });\n          } catch (error) {\n            onError === null || onError === void 0 || onError(error);\n          }\n        },\n        requestAsync(_ref2) {\n          let {\n            body,\n            timeout = 10000\n          } = _ref2;\n          return withTimeout(() => new Promise((onResponse, onError) => this.request({\n            body,\n            onError,\n            onResponse\n          })), {\n            errorInstance: new TimeoutError({\n              body,\n              url\n            }),\n            timeout\n          });\n        },\n        requests,\n        subscriptions,\n        url\n      };\n      socketClientCache.set(id, socketClient);\n      return [socketClient];\n    }\n  });\n  const [_, [socketClient_]] = await schedule();\n  return socketClient_;\n}","map":{"version":3,"names":["SocketClosedError","TimeoutError","createBatchScheduler","withTimeout","idCache","socketClientCache","Map","getSocketRpcClient","parameters","getSocket","keepAlive","key","reconnect","url","interval","keepAliveInterval","attempts","delay","id","JSON","stringify","socketClient","get","reconnectCount","schedule","fn","requests","subscriptions","error","socket","keepAliveTimer","reconnectInProgress","attemptReconnect","_socket","close","setTimeout","setup","catch","console","clear","result","onClose","request","values","_request$onError","onError","call","subscription","_subscription$onError","error_","_request$onError2","_subscription$onError2","onOpen","undefined","onResponse","data","isSubscription","method","params","cache","callback","delete","clearInterval","setInterval","_socket$ping","_socket2","ping","size","subscriptionEntries","entries","body","_socketClient","_ref","_body$id","_body$params","take","response","set","_objectSpread","jsonrpc","requestAsync","_ref2","timeout","Promise","errorInstance","_","socketClient_"],"sources":["/Users/mac/Desktop/topl1/frontend/node_modules/viem/utils/rpc/socket.ts"],"sourcesContent":["import { SocketClosedError, TimeoutError } from '../../errors/request.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { RpcRequest, RpcResponse } from '../../types/rpc.js'\nimport {\n  type CreateBatchSchedulerErrorType,\n  createBatchScheduler,\n} from '../promise/createBatchScheduler.js'\nimport { withTimeout } from '../promise/withTimeout.js'\nimport { idCache } from './id.js'\n\ntype Id = string | number\ntype CallbackFn = {\n  onResponse: (message: any) => void\n  onError?: ((error?: Error | Event | undefined) => void) | undefined\n  body?: RpcRequest\n}\ntype CallbackMap = Map<Id, CallbackFn>\n\nexport type GetSocketParameters = {\n  onClose: () => void\n  onError: (error?: Error | Event | undefined) => void\n  onOpen: () => void\n  onResponse: (data: RpcResponse) => void\n}\n\nexport type Socket<socket extends {}> = socket & {\n  close(): void\n  ping?: (() => void) | undefined\n  request(params: { body: RpcRequest }): void\n}\n\nexport type SocketRpcClient<socket extends {}> = {\n  close(): void\n  socket: Socket<socket>\n  request(params: {\n    body: RpcRequest\n    onError?: ((error?: Error | Event | undefined) => void) | undefined\n    onResponse: (message: RpcResponse) => void\n  }): void\n  requestAsync(params: {\n    body: RpcRequest\n    timeout?: number | undefined\n  }): Promise<RpcResponse>\n  requests: CallbackMap\n  subscriptions: CallbackMap\n  url: string\n}\n\nexport type GetSocketRpcClientParameters<socket extends {} = {}> = {\n  getSocket(params: GetSocketParameters): Promise<Socket<socket>>\n  /**\n   * Whether or not to send keep-alive messages.\n   * @default true\n   */\n  keepAlive?:\n    | boolean\n    | {\n        /**\n         * The interval (in ms) to send keep-alive messages.\n         * @default 30_000\n         */\n        interval?: number | undefined\n      }\n    | undefined\n  key?: string\n  /**\n   * Whether or not to attempt to reconnect on socket failure or closure.\n   * @default true\n   */\n  reconnect?:\n    | boolean\n    | {\n        /**\n         * The maximum number of reconnection attempts.\n         * @default 5\n         */\n        attempts?: number | undefined\n        /**\n         * The delay (in ms) between reconnection attempts.\n         * @default 2_000\n         */\n        delay?: number | undefined\n      }\n    | undefined\n  url: string\n}\n\nexport type GetSocketRpcClientErrorType =\n  | CreateBatchSchedulerErrorType\n  | ErrorType\n\nexport const socketClientCache = /*#__PURE__*/ new Map<\n  string,\n  SocketRpcClient<Socket<{}>>\n>()\n\nexport async function getSocketRpcClient<socket extends {}>(\n  parameters: GetSocketRpcClientParameters<socket>,\n): Promise<SocketRpcClient<socket>> {\n  const {\n    getSocket,\n    keepAlive = true,\n    key = 'socket',\n    reconnect = true,\n    url,\n  } = parameters\n  const { interval: keepAliveInterval = 30_000 } =\n    typeof keepAlive === 'object' ? keepAlive : {}\n  const { attempts = 5, delay = 2_000 } =\n    typeof reconnect === 'object' ? reconnect : {}\n\n  const id = JSON.stringify({ keepAlive, key, url, reconnect })\n  let socketClient = socketClientCache.get(id)\n\n  // If the socket already exists, return it.\n  if (socketClient) return socketClient as {} as SocketRpcClient<socket>\n\n  let reconnectCount = 0\n  const { schedule } = createBatchScheduler<\n    undefined,\n    [SocketRpcClient<socket>]\n  >({\n    id,\n    fn: async () => {\n      // Set up a cache for incoming \"synchronous\" requests.\n      const requests = new Map<Id, CallbackFn>()\n\n      // Set up a cache for subscriptions (eth_subscribe).\n      const subscriptions = new Map<Id, CallbackFn>()\n\n      let error: Error | Event | undefined\n      let socket: Socket<{}>\n      let keepAliveTimer: ReturnType<typeof setInterval> | undefined\n\n      let reconnectInProgress = false\n      function attemptReconnect() {\n        // Attempt to reconnect.\n        if (reconnect && reconnectCount < attempts) {\n          if (reconnectInProgress) return\n          reconnectInProgress = true\n          reconnectCount++\n\n          // Make sure the previous socket is definitely closed.\n          socket?.close()\n\n          setTimeout(async () => {\n            // biome-ignore lint/suspicious/noConsole: _\n            await setup().catch(console.error)\n            reconnectInProgress = false\n          }, delay)\n        }\n        // Otherwise, clear all requests and subscriptions.\n        else {\n          requests.clear()\n          subscriptions.clear()\n        }\n      }\n\n      // Set up socket implementation.\n      async function setup() {\n        const result = await getSocket({\n          onClose() {\n            // Notify all requests and subscriptions of the closure error.\n            for (const request of requests.values())\n              request.onError?.(new SocketClosedError({ url }))\n            for (const subscription of subscriptions.values())\n              subscription.onError?.(new SocketClosedError({ url }))\n\n            attemptReconnect()\n          },\n          onError(error_) {\n            error = error_\n\n            // Notify all requests and subscriptions of the error.\n            for (const request of requests.values()) request.onError?.(error)\n            for (const subscription of subscriptions.values())\n              subscription.onError?.(error)\n\n            attemptReconnect()\n          },\n          onOpen() {\n            error = undefined\n            reconnectCount = 0\n          },\n          onResponse(data) {\n            const isSubscription = data.method === 'eth_subscription'\n            const id = isSubscription ? data.params.subscription : data.id\n            const cache = isSubscription ? subscriptions : requests\n            const callback = cache.get(id)\n            if (callback) callback.onResponse(data)\n            if (!isSubscription) cache.delete(id)\n          },\n        })\n\n        socket = result\n\n        if (keepAlive) {\n          if (keepAliveTimer) clearInterval(keepAliveTimer)\n          keepAliveTimer = setInterval(() => socket.ping?.(), keepAliveInterval)\n        }\n\n        if (reconnect && subscriptions.size > 0) {\n          const subscriptionEntries = subscriptions.entries()\n          for (const [\n            key,\n            { onResponse, body, onError },\n          ] of subscriptionEntries) {\n            if (!body) continue\n\n            subscriptions.delete(key)\n            socketClient?.request({ body, onResponse, onError })\n          }\n        }\n\n        return result\n      }\n      await setup()\n      error = undefined\n\n      // Create a new socket instance.\n      socketClient = {\n        close() {\n          keepAliveTimer && clearInterval(keepAliveTimer)\n          socket.close()\n          socketClientCache.delete(id)\n        },\n        get socket() {\n          return socket\n        },\n        request({ body, onError, onResponse }) {\n          if (error && onError) onError(error)\n\n          const id = body.id ?? idCache.take()\n\n          const callback = (response: RpcResponse) => {\n            if (typeof response.id === 'number' && id !== response.id) return\n\n            // If we are subscribing to a topic, we want to set up a listener for incoming\n            // messages.\n            if (\n              body.method === 'eth_subscribe' &&\n              typeof response.result === 'string'\n            )\n              subscriptions.set(response.result, {\n                onResponse: callback,\n                onError,\n                body,\n              })\n\n            onResponse(response)\n          }\n\n          // If we are unsubscribing from a topic, remove the listener immediately\n          // to prevent it from being re-subscribed on reconnect.\n          if (body.method === 'eth_unsubscribe')\n            subscriptions.delete(body.params?.[0])\n\n          requests.set(id, { onResponse: callback, onError })\n          try {\n            socket.request({\n              body: {\n                jsonrpc: '2.0',\n                id,\n                ...body,\n              },\n            })\n          } catch (error) {\n            onError?.(error as Error)\n          }\n        },\n        requestAsync({ body, timeout = 10_000 }) {\n          return withTimeout(\n            () =>\n              new Promise<RpcResponse>((onResponse, onError) =>\n                this.request({\n                  body,\n                  onError,\n                  onResponse,\n                }),\n              ),\n            {\n              errorInstance: new TimeoutError({ body, url }),\n              timeout,\n            },\n          )\n        },\n        requests,\n        subscriptions,\n        url,\n      }\n      socketClientCache.set(id, socketClient)\n\n      return [socketClient as {} as SocketRpcClient<socket>]\n    },\n  })\n\n  const [_, [socketClient_]] = await schedule()\n  return socketClient_\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}