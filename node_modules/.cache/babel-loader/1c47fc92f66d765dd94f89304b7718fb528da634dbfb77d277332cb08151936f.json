{"ast":null,"code":"import _objectSpread from \"/Users/mac/Desktop/topl1/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { HttpRequestError, TimeoutError } from '../../errors/request.js';\nimport { withTimeout } from '../promise/withTimeout.js';\nimport { stringify } from '../stringify.js';\nimport { idCache } from './id.js';\nexport function getHttpRpcClient(url_) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    url,\n    headers: headers_url\n  } = parseUrl(url_);\n  return {\n    async request(params) {\n      var _options$fetchFn, _options$timeout, _options$fetchOptions, _params$fetchOptions;\n      const {\n        body,\n        fetchFn = (_options$fetchFn = options.fetchFn) !== null && _options$fetchFn !== void 0 ? _options$fetchFn : fetch,\n        onRequest = options.onRequest,\n        onResponse = options.onResponse,\n        timeout = (_options$timeout = options.timeout) !== null && _options$timeout !== void 0 ? _options$timeout : 10000\n      } = params;\n      const fetchOptions = _objectSpread(_objectSpread({}, (_options$fetchOptions = options.fetchOptions) !== null && _options$fetchOptions !== void 0 ? _options$fetchOptions : {}), (_params$fetchOptions = params.fetchOptions) !== null && _params$fetchOptions !== void 0 ? _params$fetchOptions : {});\n      const {\n        headers,\n        method,\n        signal: signal_\n      } = fetchOptions;\n      try {\n        var _response$headers$get;\n        const response = await withTimeout(async _ref => {\n          var _body$id2, _await$onRequest, _args$url;\n          let {\n            signal\n          } = _ref;\n          const init = _objectSpread(_objectSpread({}, fetchOptions), {}, {\n            body: Array.isArray(body) ? stringify(body.map(body => {\n              var _body$id;\n              return _objectSpread({\n                jsonrpc: '2.0',\n                id: (_body$id = body.id) !== null && _body$id !== void 0 ? _body$id : idCache.take()\n              }, body);\n            })) : stringify(_objectSpread({\n              jsonrpc: '2.0',\n              id: (_body$id2 = body.id) !== null && _body$id2 !== void 0 ? _body$id2 : idCache.take()\n            }, body)),\n            headers: _objectSpread(_objectSpread({}, headers_url), {}, {\n              'Content-Type': 'application/json'\n            }, headers),\n            method: method || 'POST',\n            signal: signal_ || (timeout > 0 ? signal : null)\n          });\n          const request = new Request(url, init);\n          const args = (_await$onRequest = await (onRequest === null || onRequest === void 0 ? void 0 : onRequest(request, init))) !== null && _await$onRequest !== void 0 ? _await$onRequest : _objectSpread(_objectSpread({}, init), {}, {\n            url\n          });\n          const response = await fetchFn((_args$url = args.url) !== null && _args$url !== void 0 ? _args$url : url, args);\n          return response;\n        }, {\n          errorInstance: new TimeoutError({\n            body,\n            url\n          }),\n          timeout,\n          signal: true\n        });\n        if (onResponse) await onResponse(response);\n        let data;\n        if ((_response$headers$get = response.headers.get('Content-Type')) !== null && _response$headers$get !== void 0 && _response$headers$get.startsWith('application/json')) data = await response.json();else {\n          data = await response.text();\n          try {\n            data = JSON.parse(data || '{}');\n          } catch (err) {\n            if (response.ok) throw err;\n            data = {\n              error: data\n            };\n          }\n        }\n        if (!response.ok) {\n          throw new HttpRequestError({\n            body,\n            details: stringify(data.error) || response.statusText,\n            headers: response.headers,\n            status: response.status,\n            url\n          });\n        }\n        return data;\n      } catch (err) {\n        if (err instanceof HttpRequestError) throw err;\n        if (err instanceof TimeoutError) throw err;\n        throw new HttpRequestError({\n          body,\n          cause: err,\n          url\n        });\n      }\n    }\n  };\n}\n/** @internal */\nexport function parseUrl(url_) {\n  try {\n    const url = new URL(url_);\n    const result = (() => {\n      // Handle Basic authentication credentials\n      if (url.username) {\n        const credentials = \"\".concat(decodeURIComponent(url.username), \":\").concat(decodeURIComponent(url.password));\n        url.username = '';\n        url.password = '';\n        return {\n          url: url.toString(),\n          headers: {\n            Authorization: \"Basic \".concat(btoa(credentials))\n          }\n        };\n      }\n      return;\n    })();\n    return _objectSpread({\n      url: url.toString()\n    }, result);\n  } catch (_unused) {\n    return {\n      url: url_\n    };\n  }\n}","map":{"version":3,"names":["HttpRequestError","TimeoutError","withTimeout","stringify","idCache","getHttpRpcClient","url_","options","arguments","length","undefined","url","headers","headers_url","parseUrl","request","params","_options$fetchFn","_options$timeout","_options$fetchOptions","_params$fetchOptions","body","fetchFn","fetch","onRequest","onResponse","timeout","fetchOptions","_objectSpread","method","signal","signal_","_response$headers$get","response","_ref","_body$id2","_await$onRequest","_args$url","init","Array","isArray","map","_body$id","jsonrpc","id","take","Request","args","errorInstance","data","get","startsWith","json","text","JSON","parse","err","ok","error","details","statusText","status","cause","URL","result","username","credentials","concat","decodeURIComponent","password","toString","Authorization","btoa","_unused"],"sources":["/Users/mac/Desktop/topl1/frontend/node_modules/viem/utils/rpc/http.ts"],"sourcesContent":["import {\n  HttpRequestError,\n  type HttpRequestErrorType as HttpRequestErrorType_,\n  TimeoutError,\n  type TimeoutErrorType,\n} from '../../errors/request.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { RpcRequest, RpcResponse } from '../../types/rpc.js'\nimport type { MaybePromise } from '../../types/utils.js'\nimport {\n  type WithTimeoutErrorType,\n  withTimeout,\n} from '../promise/withTimeout.js'\nimport { stringify } from '../stringify.js'\nimport { idCache } from './id.js'\n\nexport type HttpRpcClientOptions = {\n  /** Override for the fetch function used to make requests. */\n  fetchFn?:\n    | ((input: string | URL | Request, init?: RequestInit) => Promise<Response>)\n    | undefined\n  /** Request configuration to pass to `fetch`. */\n  fetchOptions?: Omit<RequestInit, 'body'> | undefined\n  /** A callback to handle the request. */\n  onRequest?:\n    | ((\n        request: Request,\n        init: RequestInit,\n      ) => MaybePromise<\n        void | undefined | (RequestInit & { url?: string | undefined })\n      >)\n    | undefined\n  /** A callback to handle the response. */\n  onResponse?: ((response: Response) => Promise<void> | void) | undefined\n  /** The timeout (in ms) for the request. */\n  timeout?: number | undefined\n}\n\nexport type HttpRequestParameters<\n  body extends RpcRequest | RpcRequest[] = RpcRequest,\n> = {\n  /** The RPC request body. */\n  body: body\n  /** Override for the fetch function used to make requests. */\n  fetchFn?: HttpRpcClientOptions['fetchFn'] | undefined\n  /** Request configuration to pass to `fetch`. */\n  fetchOptions?: HttpRpcClientOptions['fetchOptions'] | undefined\n  /** A callback to handle the response. */\n  onRequest?:\n    | ((\n        request: Request,\n        init: RequestInit,\n      ) => MaybePromise<\n        void | undefined | (RequestInit & { url?: string | undefined })\n      >)\n    | undefined\n  /** A callback to handle the response. */\n  onResponse?: ((response: Response) => Promise<void> | void) | undefined\n  /** The timeout (in ms) for the request. */\n  timeout?: HttpRpcClientOptions['timeout'] | undefined\n}\n\nexport type HttpRequestReturnType<\n  body extends RpcRequest | RpcRequest[] = RpcRequest,\n> = body extends RpcRequest[] ? RpcResponse[] : RpcResponse\n\nexport type HttpRequestErrorType =\n  | HttpRequestErrorType_\n  | TimeoutErrorType\n  | WithTimeoutErrorType\n  | ErrorType\n\nexport type HttpRpcClient = {\n  request<body extends RpcRequest | RpcRequest[]>(\n    params: HttpRequestParameters<body>,\n  ): Promise<HttpRequestReturnType<body>>\n}\n\nexport function getHttpRpcClient(\n  url_: string,\n  options: HttpRpcClientOptions = {},\n): HttpRpcClient {\n  const { url, headers: headers_url } = parseUrl(url_)\n\n  return {\n    async request(params) {\n      const {\n        body,\n        fetchFn = options.fetchFn ?? fetch,\n        onRequest = options.onRequest,\n        onResponse = options.onResponse,\n        timeout = options.timeout ?? 10_000,\n      } = params\n\n      const fetchOptions = {\n        ...(options.fetchOptions ?? {}),\n        ...(params.fetchOptions ?? {}),\n      }\n\n      const { headers, method, signal: signal_ } = fetchOptions\n\n      try {\n        const response = await withTimeout(\n          async ({ signal }) => {\n            const init: RequestInit = {\n              ...fetchOptions,\n              body: Array.isArray(body)\n                ? stringify(\n                    body.map((body) => ({\n                      jsonrpc: '2.0',\n                      id: body.id ?? idCache.take(),\n                      ...body,\n                    })),\n                  )\n                : stringify({\n                    jsonrpc: '2.0',\n                    id: body.id ?? idCache.take(),\n                    ...body,\n                  }),\n              headers: {\n                ...headers_url,\n                'Content-Type': 'application/json',\n                ...headers,\n              },\n              method: method || 'POST',\n              signal: signal_ || (timeout > 0 ? signal : null),\n            }\n            const request = new Request(url, init)\n            const args = (await onRequest?.(request, init)) ?? { ...init, url }\n            const response = await fetchFn(args.url ?? url, args)\n            return response\n          },\n          {\n            errorInstance: new TimeoutError({ body, url }),\n            timeout,\n            signal: true,\n          },\n        )\n\n        if (onResponse) await onResponse(response)\n\n        let data: any\n        if (\n          response.headers.get('Content-Type')?.startsWith('application/json')\n        )\n          data = await response.json()\n        else {\n          data = await response.text()\n          try {\n            data = JSON.parse(data || '{}')\n          } catch (err) {\n            if (response.ok) throw err\n            data = { error: data }\n          }\n        }\n\n        if (!response.ok) {\n          throw new HttpRequestError({\n            body,\n            details: stringify(data.error) || response.statusText,\n            headers: response.headers,\n            status: response.status,\n            url,\n          })\n        }\n\n        return data\n      } catch (err) {\n        if (err instanceof HttpRequestError) throw err\n        if (err instanceof TimeoutError) throw err\n        throw new HttpRequestError({\n          body,\n          cause: err as Error,\n          url,\n        })\n      }\n    },\n  }\n}\n\n/** @internal */\nexport function parseUrl(url_: string) {\n  try {\n    const url = new URL(url_)\n\n    const result = (() => {\n      // Handle Basic authentication credentials\n      if (url.username) {\n        const credentials = `${decodeURIComponent(url.username)}:${decodeURIComponent(url.password)}`\n        url.username = ''\n        url.password = ''\n\n        return {\n          url: url.toString(),\n          headers: { Authorization: `Basic ${btoa(credentials)}` },\n        }\n      }\n\n      return\n    })()\n\n    return { url: url.toString(), ...result }\n  } catch {\n    return { url: url_ }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}