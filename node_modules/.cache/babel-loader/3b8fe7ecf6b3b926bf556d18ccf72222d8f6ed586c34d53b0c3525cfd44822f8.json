{"ast":null,"code":"import { BlockNotFoundError } from '../../errors/block.js';\nimport { TransactionNotFoundError, TransactionReceiptNotFoundError, WaitForTransactionReceiptTimeoutError } from '../../errors/transaction.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { observe } from '../../utils/observe.js';\nimport { withResolvers } from '../../utils/promise/withResolvers.js';\nimport { withRetry } from '../../utils/promise/withRetry.js';\nimport { stringify } from '../../utils/stringify.js';\nimport { getBlock } from './getBlock.js';\nimport { getTransaction } from './getTransaction.js';\nimport { getTransactionReceipt } from './getTransactionReceipt.js';\nimport { watchBlockNumber } from './watchBlockNumber.js';\n/**\n * Waits for the [Transaction](https://viem.sh/docs/glossary/terms#transaction) to be included on a [Block](https://viem.sh/docs/glossary/terms#block) (one confirmation), and then returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms#transaction-receipt).\n *\n * - Docs: https://viem.sh/docs/actions/public/waitForTransactionReceipt\n * - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_sending-transactions\n * - JSON-RPC Methods:\n *   - Polls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt) on each block until it has been processed.\n *   - If a Transaction has been replaced:\n *     - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) and extracts the transactions\n *     - Checks if one of the Transactions is a replacement\n *     - If so, calls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt).\n *\n * The `waitForTransactionReceipt` action additionally supports Replacement detection (e.g. sped up Transactions).\n *\n * Transactions can be replaced when a user modifies their transaction in their wallet (to speed up or cancel). Transactions are replaced when they are sent from the same nonce.\n *\n * There are 3 types of Transaction Replacement reasons:\n *\n * - `repriced`: The gas price has been modified (e.g. different `maxFeePerGas`)\n * - `cancelled`: The Transaction has been cancelled (e.g. `value === 0n`)\n * - `replaced`: The Transaction has been replaced (e.g. different `value` or `data`)\n *\n * @param client - Client to use\n * @param parameters - {@link WaitForTransactionReceiptParameters}\n * @returns The transaction receipt. {@link WaitForTransactionReceiptReturnType}\n *\n * @example\n * import { createPublicClient, waitForTransactionReceipt, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const transactionReceipt = await waitForTransactionReceipt(client, {\n *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n * })\n */\nexport async function waitForTransactionReceipt(client, parameters) {\n  const {\n    checkReplacement = true,\n    confirmations = 1,\n    hash,\n    onReplaced,\n    retryCount = 6,\n    retryDelay = ({\n      count\n    }) => ~~(1 << count) * 200,\n    // exponential backoff\n    timeout = 180_000\n  } = parameters;\n  const observerId = stringify(['waitForTransactionReceipt', client.uid, hash]);\n  const pollingInterval = (() => {\n    if (parameters.pollingInterval) return parameters.pollingInterval;\n    if (client.chain?.experimental_preconfirmationTime) return client.chain.experimental_preconfirmationTime;\n    return client.pollingInterval;\n  })();\n  let transaction;\n  let replacedTransaction;\n  let receipt;\n  let retrying = false;\n  let _unobserve;\n  let _unwatch;\n  const {\n    promise,\n    resolve,\n    reject\n  } = withResolvers();\n  const timer = timeout ? setTimeout(() => {\n    _unwatch?.();\n    _unobserve?.();\n    reject(new WaitForTransactionReceiptTimeoutError({\n      hash\n    }));\n  }, timeout) : undefined;\n  _unobserve = observe(observerId, {\n    onReplaced,\n    resolve,\n    reject\n  }, async emit => {\n    receipt = await getAction(client, getTransactionReceipt, 'getTransactionReceipt')({\n      hash\n    }).catch(() => undefined);\n    if (receipt && confirmations <= 1) {\n      clearTimeout(timer);\n      emit.resolve(receipt);\n      _unobserve?.();\n      return;\n    }\n    _unwatch = getAction(client, watchBlockNumber, 'watchBlockNumber')({\n      emitMissed: true,\n      emitOnBegin: true,\n      poll: true,\n      pollingInterval,\n      async onBlockNumber(blockNumber_) {\n        const done = fn => {\n          clearTimeout(timer);\n          _unwatch?.();\n          fn();\n          _unobserve?.();\n        };\n        let blockNumber = blockNumber_;\n        if (retrying) return;\n        try {\n          // If we already have a valid receipt, let's check if we have enough\n          // confirmations. If we do, then we can resolve.\n          if (receipt) {\n            if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations)) return;\n            done(() => emit.resolve(receipt));\n            return;\n          }\n          // Get the transaction to check if it's been replaced.\n          // We need to retry as some RPC Providers may be slow to sync\n          // up mined transactions.\n          if (checkReplacement && !transaction) {\n            retrying = true;\n            await withRetry(async () => {\n              transaction = await getAction(client, getTransaction, 'getTransaction')({\n                hash\n              });\n              if (transaction.blockNumber) blockNumber = transaction.blockNumber;\n            }, {\n              delay: retryDelay,\n              retryCount\n            });\n            retrying = false;\n          }\n          // Get the receipt to check if it's been processed.\n          receipt = await getAction(client, getTransactionReceipt, 'getTransactionReceipt')({\n            hash\n          });\n          // Check if we have enough confirmations. If not, continue polling.\n          if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations)) return;\n          done(() => emit.resolve(receipt));\n        } catch (err) {\n          // If the receipt is not found, the transaction will be pending.\n          // We need to check if it has potentially been replaced.\n          if (err instanceof TransactionNotFoundError || err instanceof TransactionReceiptNotFoundError) {\n            if (!transaction) {\n              retrying = false;\n              return;\n            }\n            try {\n              replacedTransaction = transaction;\n              // Let's retrieve the transactions from the current block.\n              // We need to retry as some RPC Providers may be slow to sync\n              // up mined blocks.\n              retrying = true;\n              const block = await withRetry(() => getAction(client, getBlock, 'getBlock')({\n                blockNumber,\n                includeTransactions: true\n              }), {\n                delay: retryDelay,\n                retryCount,\n                shouldRetry: ({\n                  error\n                }) => error instanceof BlockNotFoundError\n              });\n              retrying = false;\n              const replacementTransaction = block.transactions.find(({\n                from,\n                nonce\n              }) => from === replacedTransaction.from && nonce === replacedTransaction.nonce);\n              // If we couldn't find a replacement transaction, continue polling.\n              if (!replacementTransaction) return;\n              // If we found a replacement transaction, return it's receipt.\n              receipt = await getAction(client, getTransactionReceipt, 'getTransactionReceipt')({\n                hash: replacementTransaction.hash\n              });\n              // Check if we have enough confirmations. If not, continue polling.\n              if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations)) return;\n              let reason = 'replaced';\n              if (replacementTransaction.to === replacedTransaction.to && replacementTransaction.value === replacedTransaction.value && replacementTransaction.input === replacedTransaction.input) {\n                reason = 'repriced';\n              } else if (replacementTransaction.from === replacementTransaction.to && replacementTransaction.value === 0n) {\n                reason = 'cancelled';\n              }\n              done(() => {\n                emit.onReplaced?.({\n                  reason,\n                  replacedTransaction: replacedTransaction,\n                  transaction: replacementTransaction,\n                  transactionReceipt: receipt\n                });\n                emit.resolve(receipt);\n              });\n            } catch (err_) {\n              done(() => emit.reject(err_));\n            }\n          } else {\n            done(() => emit.reject(err));\n          }\n        }\n      }\n    });\n  });\n  return promise;\n}","map":{"version":3,"names":["BlockNotFoundError","TransactionNotFoundError","TransactionReceiptNotFoundError","WaitForTransactionReceiptTimeoutError","getAction","observe","withResolvers","withRetry","stringify","getBlock","getTransaction","getTransactionReceipt","watchBlockNumber","waitForTransactionReceipt","client","parameters","checkReplacement","confirmations","hash","onReplaced","retryCount","retryDelay","count","timeout","observerId","uid","pollingInterval","chain","experimental_preconfirmationTime","transaction","replacedTransaction","receipt","retrying","_unobserve","_unwatch","promise","resolve","reject","timer","setTimeout","undefined","emit","catch","clearTimeout","emitMissed","emitOnBegin","poll","onBlockNumber","blockNumber_","done","fn","blockNumber","delay","err","block","includeTransactions","shouldRetry","error","replacementTransaction","transactions","find","from","nonce","reason","to","value","input","transactionReceipt","err_"],"sources":["/Users/mac/Desktop/topl1/frontend/node_modules/viem/actions/public/waitForTransactionReceipt.ts"],"sourcesContent":["import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { BlockNotFoundError } from '../../errors/block.js'\nimport {\n  TransactionNotFoundError,\n  TransactionReceiptNotFoundError,\n  WaitForTransactionReceiptTimeoutError,\n  type WaitForTransactionReceiptTimeoutErrorType,\n} from '../../errors/transaction.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hash } from '../../types/misc.js'\nimport type { Transaction } from '../../types/transaction.js'\nimport { getAction } from '../../utils/getAction.js'\nimport { type ObserveErrorType, observe } from '../../utils/observe.js'\nimport { withResolvers } from '../../utils/promise/withResolvers.js'\nimport {\n  type WithRetryParameters,\n  withRetry,\n} from '../../utils/promise/withRetry.js'\nimport { stringify } from '../../utils/stringify.js'\n\nimport { type GetBlockErrorType, getBlock } from './getBlock.js'\nimport {\n  type GetTransactionErrorType,\n  type GetTransactionReturnType,\n  getTransaction,\n} from './getTransaction.js'\nimport {\n  type GetTransactionReceiptErrorType,\n  type GetTransactionReceiptReturnType,\n  getTransactionReceipt,\n} from './getTransactionReceipt.js'\nimport {\n  type WatchBlockNumberErrorType,\n  watchBlockNumber,\n} from './watchBlockNumber.js'\n\nexport type ReplacementReason = 'cancelled' | 'replaced' | 'repriced'\nexport type ReplacementReturnType<\n  chain extends Chain | undefined = Chain | undefined,\n> = {\n  reason: ReplacementReason\n  replacedTransaction: Transaction\n  transaction: Transaction\n  transactionReceipt: GetTransactionReceiptReturnType<chain>\n}\n\nexport type WaitForTransactionReceiptReturnType<\n  chain extends Chain | undefined = Chain | undefined,\n> = GetTransactionReceiptReturnType<chain>\n\nexport type WaitForTransactionReceiptParameters<\n  chain extends Chain | undefined = Chain | undefined,\n> = {\n  /**\n   * Whether to check for transaction replacements.\n   * @default true\n   */\n  checkReplacement?: boolean | undefined\n  /**\n   * The number of confirmations (blocks that have passed) to wait before resolving.\n   * @default 1\n   */\n  confirmations?: number | undefined\n  /** The hash of the transaction. */\n  hash: Hash\n  /** Optional callback to emit if the transaction has been replaced. */\n  onReplaced?: ((response: ReplacementReturnType<chain>) => void) | undefined\n  /**\n   * Polling frequency (in ms). Defaults to the client's pollingInterval config.\n   * @default client.pollingInterval\n   */\n  pollingInterval?: number | undefined\n  /**\n   * Number of times to retry if the transaction or block is not found.\n   * @default 6 (exponential backoff)\n   */\n  retryCount?: WithRetryParameters['retryCount'] | undefined\n  /**\n   * Time to wait (in ms) between retries.\n   * @default `({ count }) => ~~(1 << count) * 200` (exponential backoff)\n   */\n  retryDelay?: WithRetryParameters['delay'] | undefined\n  /**\n   * Optional timeout (in milliseconds) to wait before stopping polling.\n   * @default 180_000\n   */\n  timeout?: number | undefined\n}\n\nexport type WaitForTransactionReceiptErrorType =\n  | ObserveErrorType\n  | GetBlockErrorType\n  | GetTransactionErrorType\n  | GetTransactionReceiptErrorType\n  | WatchBlockNumberErrorType\n  | WaitForTransactionReceiptTimeoutErrorType\n  | ErrorType\n\n/**\n * Waits for the [Transaction](https://viem.sh/docs/glossary/terms#transaction) to be included on a [Block](https://viem.sh/docs/glossary/terms#block) (one confirmation), and then returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms#transaction-receipt).\n *\n * - Docs: https://viem.sh/docs/actions/public/waitForTransactionReceipt\n * - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_sending-transactions\n * - JSON-RPC Methods:\n *   - Polls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt) on each block until it has been processed.\n *   - If a Transaction has been replaced:\n *     - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) and extracts the transactions\n *     - Checks if one of the Transactions is a replacement\n *     - If so, calls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt).\n *\n * The `waitForTransactionReceipt` action additionally supports Replacement detection (e.g. sped up Transactions).\n *\n * Transactions can be replaced when a user modifies their transaction in their wallet (to speed up or cancel). Transactions are replaced when they are sent from the same nonce.\n *\n * There are 3 types of Transaction Replacement reasons:\n *\n * - `repriced`: The gas price has been modified (e.g. different `maxFeePerGas`)\n * - `cancelled`: The Transaction has been cancelled (e.g. `value === 0n`)\n * - `replaced`: The Transaction has been replaced (e.g. different `value` or `data`)\n *\n * @param client - Client to use\n * @param parameters - {@link WaitForTransactionReceiptParameters}\n * @returns The transaction receipt. {@link WaitForTransactionReceiptReturnType}\n *\n * @example\n * import { createPublicClient, waitForTransactionReceipt, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const transactionReceipt = await waitForTransactionReceipt(client, {\n *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n * })\n */\nexport async function waitForTransactionReceipt<\n  chain extends Chain | undefined,\n>(\n  client: Client<Transport, chain>,\n  parameters: WaitForTransactionReceiptParameters<chain>,\n): Promise<WaitForTransactionReceiptReturnType<chain>> {\n  const {\n    checkReplacement = true,\n    confirmations = 1,\n    hash,\n    onReplaced,\n    retryCount = 6,\n    retryDelay = ({ count }) => ~~(1 << count) * 200, // exponential backoff\n    timeout = 180_000,\n  } = parameters\n\n  const observerId = stringify(['waitForTransactionReceipt', client.uid, hash])\n\n  const pollingInterval = (() => {\n    if (parameters.pollingInterval) return parameters.pollingInterval\n    if (client.chain?.experimental_preconfirmationTime)\n      return client.chain.experimental_preconfirmationTime\n    return client.pollingInterval\n  })()\n\n  let transaction: GetTransactionReturnType<chain> | undefined\n  let replacedTransaction: GetTransactionReturnType<chain> | undefined\n  let receipt: GetTransactionReceiptReturnType<chain> | undefined\n  let retrying = false\n\n  let _unobserve: () => void\n  let _unwatch: () => void\n\n  const { promise, resolve, reject } =\n    withResolvers<WaitForTransactionReceiptReturnType<chain>>()\n\n  const timer = timeout\n    ? setTimeout(() => {\n        _unwatch?.()\n        _unobserve?.()\n        reject(new WaitForTransactionReceiptTimeoutError({ hash }))\n      }, timeout)\n    : undefined\n\n  _unobserve = observe(\n    observerId,\n    { onReplaced, resolve, reject },\n    async (emit) => {\n      receipt = await getAction(\n        client,\n        getTransactionReceipt,\n        'getTransactionReceipt',\n      )({ hash }).catch(() => undefined)\n\n      if (receipt && confirmations <= 1) {\n        clearTimeout(timer)\n        emit.resolve(receipt)\n        _unobserve?.()\n        return\n      }\n\n      _unwatch = getAction(\n        client,\n        watchBlockNumber,\n        'watchBlockNumber',\n      )({\n        emitMissed: true,\n        emitOnBegin: true,\n        poll: true,\n        pollingInterval,\n        async onBlockNumber(blockNumber_) {\n          const done = (fn: () => void) => {\n            clearTimeout(timer)\n            _unwatch?.()\n            fn()\n            _unobserve?.()\n          }\n\n          let blockNumber = blockNumber_\n\n          if (retrying) return\n\n          try {\n            // If we already have a valid receipt, let's check if we have enough\n            // confirmations. If we do, then we can resolve.\n            if (receipt) {\n              if (\n                confirmations > 1 &&\n                (!receipt.blockNumber ||\n                  blockNumber - receipt.blockNumber + 1n < confirmations)\n              )\n                return\n\n              done(() => emit.resolve(receipt!))\n              return\n            }\n\n            // Get the transaction to check if it's been replaced.\n            // We need to retry as some RPC Providers may be slow to sync\n            // up mined transactions.\n            if (checkReplacement && !transaction) {\n              retrying = true\n              await withRetry(\n                async () => {\n                  transaction = (await getAction(\n                    client,\n                    getTransaction,\n                    'getTransaction',\n                  )({ hash })) as GetTransactionReturnType<chain>\n                  if (transaction.blockNumber)\n                    blockNumber = transaction.blockNumber\n                },\n                {\n                  delay: retryDelay,\n                  retryCount,\n                },\n              )\n              retrying = false\n            }\n\n            // Get the receipt to check if it's been processed.\n            receipt = await getAction(\n              client,\n              getTransactionReceipt,\n              'getTransactionReceipt',\n            )({ hash })\n\n            // Check if we have enough confirmations. If not, continue polling.\n            if (\n              confirmations > 1 &&\n              (!receipt.blockNumber ||\n                blockNumber - receipt.blockNumber + 1n < confirmations)\n            )\n              return\n\n            done(() => emit.resolve(receipt!))\n          } catch (err) {\n            // If the receipt is not found, the transaction will be pending.\n            // We need to check if it has potentially been replaced.\n            if (\n              err instanceof TransactionNotFoundError ||\n              err instanceof TransactionReceiptNotFoundError\n            ) {\n              if (!transaction) {\n                retrying = false\n                return\n              }\n\n              try {\n                replacedTransaction = transaction\n\n                // Let's retrieve the transactions from the current block.\n                // We need to retry as some RPC Providers may be slow to sync\n                // up mined blocks.\n                retrying = true\n                const block = await withRetry(\n                  () =>\n                    getAction(\n                      client,\n                      getBlock,\n                      'getBlock',\n                    )({\n                      blockNumber,\n                      includeTransactions: true,\n                    }),\n                  {\n                    delay: retryDelay,\n                    retryCount,\n                    shouldRetry: ({ error }) =>\n                      error instanceof BlockNotFoundError,\n                  },\n                )\n                retrying = false\n\n                const replacementTransaction = (\n                  block.transactions as {} as Transaction[]\n                ).find(\n                  ({ from, nonce }) =>\n                    from === replacedTransaction!.from &&\n                    nonce === replacedTransaction!.nonce,\n                )\n\n                // If we couldn't find a replacement transaction, continue polling.\n                if (!replacementTransaction) return\n\n                // If we found a replacement transaction, return it's receipt.\n                receipt = await getAction(\n                  client,\n                  getTransactionReceipt,\n                  'getTransactionReceipt',\n                )({\n                  hash: replacementTransaction.hash,\n                })\n\n                // Check if we have enough confirmations. If not, continue polling.\n                if (\n                  confirmations > 1 &&\n                  (!receipt.blockNumber ||\n                    blockNumber - receipt.blockNumber + 1n < confirmations)\n                )\n                  return\n\n                let reason: ReplacementReason = 'replaced'\n                if (\n                  replacementTransaction.to === replacedTransaction.to &&\n                  replacementTransaction.value === replacedTransaction.value &&\n                  replacementTransaction.input === replacedTransaction.input\n                ) {\n                  reason = 'repriced'\n                } else if (\n                  replacementTransaction.from === replacementTransaction.to &&\n                  replacementTransaction.value === 0n\n                ) {\n                  reason = 'cancelled'\n                }\n\n                done(() => {\n                  emit.onReplaced?.({\n                    reason,\n                    replacedTransaction: replacedTransaction! as any,\n                    transaction: replacementTransaction,\n                    transactionReceipt: receipt!,\n                  })\n                  emit.resolve(receipt!)\n                })\n              } catch (err_) {\n                done(() => emit.reject(err_))\n              }\n            } else {\n              done(() => emit.reject(err))\n            }\n          }\n        },\n      })\n    },\n  )\n\n  return promise\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}