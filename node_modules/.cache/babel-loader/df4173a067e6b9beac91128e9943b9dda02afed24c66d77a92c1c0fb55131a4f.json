{"ast":null,"code":"import { withResolvers } from './withResolvers.js';\nconst schedulerCache = /*#__PURE__*/new Map();\n/** @internal */\nexport function createBatchScheduler(_ref) {\n  let {\n    fn,\n    id,\n    shouldSplitBatch,\n    wait = 0,\n    sort\n  } = _ref;\n  const exec = async () => {\n    const scheduler = getScheduler();\n    flush();\n    const args = scheduler.map(_ref2 => {\n      let {\n        args\n      } = _ref2;\n      return args;\n    });\n    if (args.length === 0) return;\n    fn(args).then(data => {\n      if (sort && Array.isArray(data)) data.sort(sort);\n      for (let i = 0; i < scheduler.length; i++) {\n        const {\n          resolve\n        } = scheduler[i];\n        resolve === null || resolve === void 0 || resolve([data[i], data]);\n      }\n    }).catch(err => {\n      for (let i = 0; i < scheduler.length; i++) {\n        const {\n          reject\n        } = scheduler[i];\n        reject === null || reject === void 0 || reject(err);\n      }\n    });\n  };\n  const flush = () => schedulerCache.delete(id);\n  const getBatchedArgs = () => getScheduler().map(_ref3 => {\n    let {\n      args\n    } = _ref3;\n    return args;\n  });\n  const getScheduler = () => schedulerCache.get(id) || [];\n  const setScheduler = item => schedulerCache.set(id, [...getScheduler(), item]);\n  return {\n    flush,\n    async schedule(args) {\n      const {\n        promise,\n        resolve,\n        reject\n      } = withResolvers();\n      const split = shouldSplitBatch === null || shouldSplitBatch === void 0 ? void 0 : shouldSplitBatch([...getBatchedArgs(), args]);\n      if (split) exec();\n      const hasActiveScheduler = getScheduler().length > 0;\n      if (hasActiveScheduler) {\n        setScheduler({\n          args,\n          resolve,\n          reject\n        });\n        return promise;\n      }\n      setScheduler({\n        args,\n        resolve,\n        reject\n      });\n      setTimeout(exec, wait);\n      return promise;\n    }\n  };\n}","map":{"version":3,"names":["withResolvers","schedulerCache","Map","createBatchScheduler","_ref","fn","id","shouldSplitBatch","wait","sort","exec","scheduler","getScheduler","flush","args","map","_ref2","length","then","data","Array","isArray","i","resolve","catch","err","reject","delete","getBatchedArgs","_ref3","get","setScheduler","item","set","schedule","promise","split","hasActiveScheduler","setTimeout"],"sources":["/Users/mac/Desktop/topl1/frontend/node_modules/viem/utils/promise/createBatchScheduler.ts"],"sourcesContent":["import type { ErrorType } from '../../errors/utils.js'\nimport { type PromiseWithResolvers, withResolvers } from './withResolvers.js'\n\ntype Resolved<returnType extends readonly unknown[] = any> = [\n  result: returnType[number],\n  results: returnType,\n]\n\ntype SchedulerItem = {\n  args: unknown\n  resolve: PromiseWithResolvers<unknown>['resolve']\n  reject: PromiseWithResolvers<unknown>['reject']\n}\n\ntype BatchResultsCompareFn<result = unknown> = (a: result, b: result) => number\n\ntype CreateBatchSchedulerArguments<\n  parameters = unknown,\n  returnType extends readonly unknown[] = readonly unknown[],\n> = {\n  fn: (args: parameters[]) => Promise<returnType>\n  id: number | string\n  shouldSplitBatch?: ((args: parameters[]) => boolean) | undefined\n  wait?: number | undefined\n  sort?: BatchResultsCompareFn<returnType[number]> | undefined\n}\n\ntype CreateBatchSchedulerReturnType<\n  parameters = unknown,\n  returnType extends readonly unknown[] = readonly unknown[],\n> = {\n  flush: () => void\n  schedule: parameters extends undefined\n    ? (args?: parameters | undefined) => Promise<Resolved<returnType>>\n    : (args: parameters) => Promise<Resolved<returnType>>\n}\n\nexport type CreateBatchSchedulerErrorType = ErrorType\n\nconst schedulerCache = /*#__PURE__*/ new Map<number | string, SchedulerItem[]>()\n\n/** @internal */\nexport function createBatchScheduler<\n  parameters,\n  returnType extends readonly unknown[],\n>({\n  fn,\n  id,\n  shouldSplitBatch,\n  wait = 0,\n  sort,\n}: CreateBatchSchedulerArguments<\n  parameters,\n  returnType\n>): CreateBatchSchedulerReturnType<parameters, returnType> {\n  const exec = async () => {\n    const scheduler = getScheduler()\n    flush()\n\n    const args = scheduler.map(({ args }) => args)\n\n    if (args.length === 0) return\n\n    fn(args as parameters[])\n      .then((data) => {\n        if (sort && Array.isArray(data)) data.sort(sort)\n        for (let i = 0; i < scheduler.length; i++) {\n          const { resolve } = scheduler[i]\n          resolve?.([data[i], data])\n        }\n      })\n      .catch((err) => {\n        for (let i = 0; i < scheduler.length; i++) {\n          const { reject } = scheduler[i]\n          reject?.(err)\n        }\n      })\n  }\n\n  const flush = () => schedulerCache.delete(id)\n\n  const getBatchedArgs = () =>\n    getScheduler().map(({ args }) => args) as parameters[]\n\n  const getScheduler = () => schedulerCache.get(id) || []\n\n  const setScheduler = (item: SchedulerItem) =>\n    schedulerCache.set(id, [...getScheduler(), item])\n\n  return {\n    flush,\n    async schedule(args: parameters) {\n      const { promise, resolve, reject } = withResolvers()\n\n      const split = shouldSplitBatch?.([...getBatchedArgs(), args])\n\n      if (split) exec()\n\n      const hasActiveScheduler = getScheduler().length > 0\n      if (hasActiveScheduler) {\n        setScheduler({ args, resolve, reject })\n        return promise\n      }\n\n      setScheduler({ args, resolve, reject })\n      setTimeout(exec, wait)\n      return promise\n    },\n  } as unknown as CreateBatchSchedulerReturnType<parameters, returnType>\n}\n"],"mappings":"AACA,SAAoCA,aAAa,QAAQ,oBAAoB;AAsC7E,MAAMC,cAAc,GAAG,aAAc,IAAIC,GAAG,EAAoC;AAEhF;AACA,OAAM,SAAUC,oBAAoBA,CAAAC,IAAA,EAYnC;EAAA,IATC;IACAC,EAAE;IACFC,EAAE;IACFC,gBAAgB;IAChBC,IAAI,GAAG,CAAC;IACRC;EAAI,CAIL,GAAAL,IAAA;EACC,MAAMM,IAAI,GAAG,MAAAA,CAAA,KAAW;IACtB,MAAMC,SAAS,GAAGC,YAAY,EAAE;IAChCC,KAAK,EAAE;IAEP,MAAMC,IAAI,GAAGH,SAAS,CAACI,GAAG,CAACC,KAAA;MAAA,IAAC;QAAEF;MAAI,CAAE,GAAAE,KAAA;MAAA,OAAKF,IAAI;IAAA,EAAC;IAE9C,IAAIA,IAAI,CAACG,MAAM,KAAK,CAAC,EAAE;IAEvBZ,EAAE,CAACS,IAAoB,CAAC,CACrBI,IAAI,CAAEC,IAAI,IAAI;MACb,IAAIV,IAAI,IAAIW,KAAK,CAACC,OAAO,CAACF,IAAI,CAAC,EAAEA,IAAI,CAACV,IAAI,CAACA,IAAI,CAAC;MAChD,KAAK,IAAIa,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGX,SAAS,CAACM,MAAM,EAAEK,CAAC,EAAE,EAAE;QACzC,MAAM;UAAEC;QAAO,CAAE,GAAGZ,SAAS,CAACW,CAAC,CAAC;QAChCC,OAAO,aAAPA,OAAO,eAAPA,OAAO,CAAG,CAACJ,IAAI,CAACG,CAAC,CAAC,EAAEH,IAAI,CAAC,CAAC;MAC5B;IACF,CAAC,CAAC,CACDK,KAAK,CAAEC,GAAG,IAAI;MACb,KAAK,IAAIH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGX,SAAS,CAACM,MAAM,EAAEK,CAAC,EAAE,EAAE;QACzC,MAAM;UAAEI;QAAM,CAAE,GAAGf,SAAS,CAACW,CAAC,CAAC;QAC/BI,MAAM,aAANA,MAAM,eAANA,MAAM,CAAGD,GAAG,CAAC;MACf;IACF,CAAC,CAAC;EACN,CAAC;EAED,MAAMZ,KAAK,GAAGA,CAAA,KAAMZ,cAAc,CAAC0B,MAAM,CAACrB,EAAE,CAAC;EAE7C,MAAMsB,cAAc,GAAGA,CAAA,KACrBhB,YAAY,EAAE,CAACG,GAAG,CAACc,KAAA;IAAA,IAAC;MAAEf;IAAI,CAAE,GAAAe,KAAA;IAAA,OAAKf,IAAI;EAAA,EAAiB;EAExD,MAAMF,YAAY,GAAGA,CAAA,KAAMX,cAAc,CAAC6B,GAAG,CAACxB,EAAE,CAAC,IAAI,EAAE;EAEvD,MAAMyB,YAAY,GAAIC,IAAmB,IACvC/B,cAAc,CAACgC,GAAG,CAAC3B,EAAE,EAAE,CAAC,GAAGM,YAAY,EAAE,EAAEoB,IAAI,CAAC,CAAC;EAEnD,OAAO;IACLnB,KAAK;IACL,MAAMqB,QAAQA,CAACpB,IAAgB;MAC7B,MAAM;QAAEqB,OAAO;QAAEZ,OAAO;QAAEG;MAAM,CAAE,GAAG1B,aAAa,EAAE;MAEpD,MAAMoC,KAAK,GAAG7B,gBAAgB,aAAhBA,gBAAgB,uBAAhBA,gBAAgB,CAAG,CAAC,GAAGqB,cAAc,EAAE,EAAEd,IAAI,CAAC,CAAC;MAE7D,IAAIsB,KAAK,EAAE1B,IAAI,EAAE;MAEjB,MAAM2B,kBAAkB,GAAGzB,YAAY,EAAE,CAACK,MAAM,GAAG,CAAC;MACpD,IAAIoB,kBAAkB,EAAE;QACtBN,YAAY,CAAC;UAAEjB,IAAI;UAAES,OAAO;UAAEG;QAAM,CAAE,CAAC;QACvC,OAAOS,OAAO;MAChB;MAEAJ,YAAY,CAAC;QAAEjB,IAAI;QAAES,OAAO;QAAEG;MAAM,CAAE,CAAC;MACvCY,UAAU,CAAC5B,IAAI,EAAEF,IAAI,CAAC;MACtB,OAAO2B,OAAO;IAChB;GACoE;AACxE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}