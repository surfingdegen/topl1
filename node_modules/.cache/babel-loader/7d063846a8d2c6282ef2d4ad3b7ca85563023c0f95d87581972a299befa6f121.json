{"ast":null,"code":"import { DecodeLogDataMismatch, DecodeLogTopicsMismatch } from '../../errors/abi.js';\nimport { InvalidInputRpcError } from '../../errors/rpc.js';\nimport { decodeEventLog } from '../../utils/abi/decodeEventLog.js';\nimport { encodeEventTopics } from '../../utils/abi/encodeEventTopics.js';\nimport { formatLog } from '../../utils/formatters/log.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { observe } from '../../utils/observe.js';\nimport { poll } from '../../utils/poll.js';\nimport { stringify } from '../../utils/stringify.js';\nimport { createEventFilter } from './createEventFilter.js';\nimport { getBlockNumber } from './getBlockNumber.js';\nimport { getFilterChanges } from './getFilterChanges.js';\nimport { getLogs } from './getLogs.js';\nimport { uninstallFilter } from './uninstallFilter.js';\n/**\n * Watches and returns emitted [Event Logs](https://viem.sh/docs/glossary/terms#event-log).\n *\n * - Docs: https://viem.sh/docs/actions/public/watchEvent\n * - JSON-RPC Methods:\n *   - **RPC Provider supports `eth_newFilter`:**\n *     - Calls [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter) to create a filter (called on initialize).\n *     - On a polling interval, it will call [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges).\n *   - **RPC Provider does not support `eth_newFilter`:**\n *     - Calls [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs) for each block between the polling interval.\n *\n * This Action will batch up all the Event Logs found within the [`pollingInterval`](https://viem.sh/docs/actions/public/watchEvent#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/actions/public/watchEvent#onLogs).\n *\n * `watchEvent` will attempt to create an [Event Filter](https://viem.sh/docs/actions/public/createEventFilter) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs) instead.\n *\n * @param client - Client to use\n * @param parameters - {@link WatchEventParameters}\n * @returns A function that can be invoked to stop watching for new Event Logs. {@link WatchEventReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { watchEvent } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const unwatch = watchEvent(client, {\n *   onLogs: (logs) => console.log(logs),\n * })\n */\nexport function watchEvent(client, _ref) {\n  let {\n    address,\n    args,\n    batch = true,\n    event,\n    events,\n    fromBlock,\n    onError,\n    onLogs,\n    poll: poll_,\n    pollingInterval = client.pollingInterval,\n    strict: strict_\n  } = _ref;\n  const enablePolling = (() => {\n    if (typeof poll_ !== 'undefined') return poll_;\n    if (typeof fromBlock === 'bigint') return true;\n    if (client.transport.type === 'webSocket' || client.transport.type === 'ipc') return false;\n    if (client.transport.type === 'fallback' && (client.transport.transports[0].config.type === 'webSocket' || client.transport.transports[0].config.type === 'ipc')) return false;\n    return true;\n  })();\n  const strict = strict_ !== null && strict_ !== void 0 ? strict_ : false;\n  const pollEvent = () => {\n    const observerId = stringify(['watchEvent', address, args, batch, client.uid, event, pollingInterval, fromBlock]);\n    return observe(observerId, {\n      onLogs,\n      onError\n    }, emit => {\n      let previousBlockNumber;\n      if (fromBlock !== undefined) previousBlockNumber = fromBlock - 1n;\n      let filter;\n      let initialized = false;\n      const unwatch = poll(async () => {\n        if (!initialized) {\n          try {\n            filter = await getAction(client, createEventFilter, 'createEventFilter')({\n              address,\n              args,\n              event: event,\n              events,\n              strict,\n              fromBlock\n            });\n          } catch (_unused) {}\n          initialized = true;\n          return;\n        }\n        try {\n          let logs;\n          if (filter) {\n            logs = await getAction(client, getFilterChanges, 'getFilterChanges')({\n              filter\n            });\n          } else {\n            // If the filter doesn't exist, we will fall back to use `getLogs`.\n            // The fall back exists because some RPC Providers do not support filters.\n            // Fetch the block number to use for `getLogs`.\n            const blockNumber = await getAction(client, getBlockNumber, 'getBlockNumber')({});\n            // If the block number has changed, we will need to fetch the logs.\n            // If the block number doesn't exist, we are yet to reach the first poll interval,\n            // so do not emit any logs.\n            if (previousBlockNumber && previousBlockNumber !== blockNumber) {\n              logs = await getAction(client, getLogs, 'getLogs')({\n                address,\n                args,\n                event: event,\n                events,\n                fromBlock: previousBlockNumber + 1n,\n                toBlock: blockNumber\n              });\n            } else {\n              logs = [];\n            }\n            previousBlockNumber = blockNumber;\n          }\n          if (logs.length === 0) return;\n          if (batch) emit.onLogs(logs);else for (const log of logs) emit.onLogs([log]);\n        } catch (err) {\n          var _emit$onError;\n          // If a filter has been set and gets uninstalled, providers will throw an InvalidInput error.\n          // Reinitialize the filter when this occurs\n          if (filter && err instanceof InvalidInputRpcError) initialized = false;\n          (_emit$onError = emit.onError) === null || _emit$onError === void 0 || _emit$onError.call(emit, err);\n        }\n      }, {\n        emitOnBegin: true,\n        interval: pollingInterval\n      });\n      return async () => {\n        if (filter) await getAction(client, uninstallFilter, 'uninstallFilter')({\n          filter\n        });\n        unwatch();\n      };\n    });\n  };\n  const subscribeEvent = () => {\n    let active = true;\n    let unsubscribe = () => active = false;\n    (async () => {\n      try {\n        const transport = (() => {\n          if (client.transport.type === 'fallback') {\n            const transport = client.transport.transports.find(transport => transport.config.type === 'webSocket' || transport.config.type === 'ipc');\n            if (!transport) return client.transport;\n            return transport.value;\n          }\n          return client.transport;\n        })();\n        const events_ = events !== null && events !== void 0 ? events : event ? [event] : undefined;\n        let topics = [];\n        if (events_) {\n          const encoded = events_.flatMap(event => encodeEventTopics({\n            abi: [event],\n            eventName: event.name,\n            args\n          }));\n          // TODO: Clean up type casting\n          topics = [encoded];\n          if (event) topics = topics[0];\n        }\n        const {\n          unsubscribe: unsubscribe_\n        } = await transport.subscribe({\n          params: ['logs', {\n            address,\n            topics\n          }],\n          onData(data) {\n            if (!active) return;\n            const log = data.result;\n            try {\n              const {\n                eventName,\n                args\n              } = decodeEventLog({\n                abi: events_ !== null && events_ !== void 0 ? events_ : [],\n                data: log.data,\n                topics: log.topics,\n                strict\n              });\n              const formatted = formatLog(log, {\n                args,\n                eventName\n              });\n              onLogs([formatted]);\n            } catch (err) {\n              let eventName;\n              let isUnnamed;\n              if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {\n                var _err$abiItem$inputs;\n                // If strict mode is on, and log data/topics do not match event definition, skip.\n                if (strict_) return;\n                eventName = err.abiItem.name;\n                isUnnamed = (_err$abiItem$inputs = err.abiItem.inputs) === null || _err$abiItem$inputs === void 0 ? void 0 : _err$abiItem$inputs.some(x => !('name' in x && x.name));\n              }\n              // Set args to empty if there is an error decoding (e.g. indexed/non-indexed params mismatch).\n              const formatted = formatLog(log, {\n                args: isUnnamed ? [] : {},\n                eventName\n              });\n              onLogs([formatted]);\n            }\n          },\n          onError(error) {\n            onError === null || onError === void 0 || onError(error);\n          }\n        });\n        unsubscribe = unsubscribe_;\n        if (!active) unsubscribe();\n      } catch (err) {\n        onError === null || onError === void 0 || onError(err);\n      }\n    })();\n    return () => unsubscribe();\n  };\n  return enablePolling ? pollEvent() : subscribeEvent();\n}","map":{"version":3,"names":["DecodeLogDataMismatch","DecodeLogTopicsMismatch","InvalidInputRpcError","decodeEventLog","encodeEventTopics","formatLog","getAction","observe","poll","stringify","createEventFilter","getBlockNumber","getFilterChanges","getLogs","uninstallFilter","watchEvent","client","_ref","address","args","batch","event","events","fromBlock","onError","onLogs","poll_","pollingInterval","strict","strict_","enablePolling","transport","type","transports","config","pollEvent","observerId","uid","emit","previousBlockNumber","undefined","filter","initialized","unwatch","_unused","logs","blockNumber","toBlock","length","log","err","_emit$onError","call","emitOnBegin","interval","subscribeEvent","active","unsubscribe","find","value","events_","topics","encoded","flatMap","abi","eventName","name","unsubscribe_","subscribe","params","onData","data","result","formatted","isUnnamed","_err$abiItem$inputs","abiItem","inputs","some","x","error"],"sources":["/Users/mac/Desktop/topl1/frontend/node_modules/viem/actions/public/watchEvent.ts"],"sourcesContent":["import type { AbiEvent, Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  DecodeLogDataMismatch,\n  DecodeLogTopicsMismatch,\n} from '../../errors/abi.js'\nimport { InvalidInputRpcError } from '../../errors/rpc.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { BlockNumber } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type {\n  MaybeAbiEventName,\n  MaybeExtractEventArgsFromAbi,\n} from '../../types/contract.js'\nimport type { Filter } from '../../types/filter.js'\nimport type { Log } from '../../types/log.js'\nimport type { LogTopic } from '../../types/misc.js'\nimport type { GetPollOptions } from '../../types/transport.js'\nimport { decodeEventLog } from '../../utils/abi/decodeEventLog.js'\nimport {\n  type EncodeEventTopicsParameters,\n  encodeEventTopics,\n} from '../../utils/abi/encodeEventTopics.js'\nimport { formatLog } from '../../utils/formatters/log.js'\nimport { getAction } from '../../utils/getAction.js'\nimport { type ObserveErrorType, observe } from '../../utils/observe.js'\nimport { poll } from '../../utils/poll.js'\nimport { type StringifyErrorType, stringify } from '../../utils/stringify.js'\nimport {\n  type CreateEventFilterParameters,\n  createEventFilter,\n} from './createEventFilter.js'\nimport { getBlockNumber } from './getBlockNumber.js'\nimport { getFilterChanges } from './getFilterChanges.js'\nimport { type GetLogsParameters, getLogs } from './getLogs.js'\nimport { uninstallFilter } from './uninstallFilter.js'\n\nexport type WatchEventOnLogsParameter<\n  abiEvent extends AbiEvent | undefined = undefined,\n  abiEvents extends\n    | readonly AbiEvent[]\n    | readonly unknown[]\n    | undefined = abiEvent extends AbiEvent ? [abiEvent] : undefined,\n  strict extends boolean | undefined = undefined,\n  eventName extends string | undefined = MaybeAbiEventName<abiEvent>,\n> = Log<bigint, number, false, abiEvent, strict, abiEvents, eventName>[]\nexport type WatchEventOnLogsFn<\n  abiEvent extends AbiEvent | undefined = undefined,\n  abiEvents extends\n    | readonly AbiEvent[]\n    | readonly unknown[]\n    | undefined = abiEvent extends AbiEvent ? [abiEvent] : undefined,\n  strict extends boolean | undefined = undefined,\n  //\n  _eventName extends string | undefined = MaybeAbiEventName<abiEvent>,\n> = (\n  logs: WatchEventOnLogsParameter<abiEvent, abiEvents, strict, _eventName>,\n) => void\n\nexport type WatchEventParameters<\n  abiEvent extends AbiEvent | undefined = undefined,\n  abiEvents extends\n    | readonly AbiEvent[]\n    | readonly unknown[]\n    | undefined = abiEvent extends AbiEvent ? [abiEvent] : undefined,\n  strict extends boolean | undefined = undefined,\n  transport extends Transport = Transport,\n  //\n  _eventName extends string | undefined = MaybeAbiEventName<abiEvent>,\n> = {\n  /** The address of the contract. */\n  address?: Address | Address[] | undefined\n  /** Block to start listening from. */\n  fromBlock?: BlockNumber<bigint> | undefined\n  /** The callback to call when an error occurred when trying to get for a new block. */\n  onError?: ((error: Error) => void) | undefined\n  /** The callback to call when new event logs are received. */\n  onLogs: WatchEventOnLogsFn<abiEvent, abiEvents, strict, _eventName>\n} & GetPollOptions<transport> &\n  (\n    | {\n        event: abiEvent\n        events?: undefined\n        args?: MaybeExtractEventArgsFromAbi<abiEvents, _eventName> | undefined\n        /**\n         * Whether or not the logs must match the indexed/non-indexed arguments on `event`.\n         * @default false\n         */\n        strict?: strict | undefined\n      }\n    | {\n        event?: undefined\n        events?: abiEvents | undefined\n        args?: undefined\n        /**\n         * Whether or not the logs must match the indexed/non-indexed arguments on `event`.\n         * @default false\n         */\n        strict?: strict | undefined\n      }\n    | {\n        event?: undefined\n        events?: undefined\n        args?: undefined\n        strict?: undefined\n      }\n  )\n\nexport type WatchEventReturnType = () => void\n\nexport type WatchEventErrorType =\n  | StringifyErrorType\n  | ObserveErrorType\n  | ErrorType\n\n/**\n * Watches and returns emitted [Event Logs](https://viem.sh/docs/glossary/terms#event-log).\n *\n * - Docs: https://viem.sh/docs/actions/public/watchEvent\n * - JSON-RPC Methods:\n *   - **RPC Provider supports `eth_newFilter`:**\n *     - Calls [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter) to create a filter (called on initialize).\n *     - On a polling interval, it will call [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges).\n *   - **RPC Provider does not support `eth_newFilter`:**\n *     - Calls [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs) for each block between the polling interval.\n *\n * This Action will batch up all the Event Logs found within the [`pollingInterval`](https://viem.sh/docs/actions/public/watchEvent#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/actions/public/watchEvent#onLogs).\n *\n * `watchEvent` will attempt to create an [Event Filter](https://viem.sh/docs/actions/public/createEventFilter) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs) instead.\n *\n * @param client - Client to use\n * @param parameters - {@link WatchEventParameters}\n * @returns A function that can be invoked to stop watching for new Event Logs. {@link WatchEventReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { watchEvent } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const unwatch = watchEvent(client, {\n *   onLogs: (logs) => console.log(logs),\n * })\n */\nexport function watchEvent<\n  chain extends Chain | undefined,\n  const abiEvent extends AbiEvent | undefined = undefined,\n  const abiEvents extends\n    | readonly AbiEvent[]\n    | readonly unknown[]\n    | undefined = abiEvent extends AbiEvent ? [abiEvent] : undefined,\n  strict extends boolean | undefined = undefined,\n  transport extends Transport = Transport,\n  _eventName extends string | undefined = undefined,\n>(\n  client: Client<transport, chain>,\n  {\n    address,\n    args,\n    batch = true,\n    event,\n    events,\n    fromBlock,\n    onError,\n    onLogs,\n    poll: poll_,\n    pollingInterval = client.pollingInterval,\n    strict: strict_,\n  }: WatchEventParameters<abiEvent, abiEvents, strict, transport>,\n): WatchEventReturnType {\n  const enablePolling = (() => {\n    if (typeof poll_ !== 'undefined') return poll_\n    if (typeof fromBlock === 'bigint') return true\n    if (\n      client.transport.type === 'webSocket' ||\n      client.transport.type === 'ipc'\n    )\n      return false\n    if (\n      client.transport.type === 'fallback' &&\n      (client.transport.transports[0].config.type === 'webSocket' ||\n        client.transport.transports[0].config.type === 'ipc')\n    )\n      return false\n    return true\n  })()\n  const strict = strict_ ?? false\n\n  const pollEvent = () => {\n    const observerId = stringify([\n      'watchEvent',\n      address,\n      args,\n      batch,\n      client.uid,\n      event,\n      pollingInterval,\n      fromBlock,\n    ])\n\n    return observe(observerId, { onLogs, onError }, (emit) => {\n      let previousBlockNumber: bigint\n      if (fromBlock !== undefined) previousBlockNumber = fromBlock - 1n\n      let filter: Filter<'event', abiEvents, _eventName, any>\n      let initialized = false\n\n      const unwatch = poll(\n        async () => {\n          if (!initialized) {\n            try {\n              filter = (await getAction(\n                client,\n                createEventFilter as any,\n                'createEventFilter',\n              )({\n                address,\n                args,\n                event: event!,\n                events,\n                strict,\n                fromBlock,\n              } as unknown as CreateEventFilterParameters)) as unknown as Filter<\n                'event',\n                abiEvents,\n                _eventName\n              >\n            } catch {}\n            initialized = true\n            return\n          }\n\n          try {\n            let logs: Log[]\n            if (filter) {\n              logs = await getAction(\n                client,\n                getFilterChanges,\n                'getFilterChanges',\n              )({ filter })\n            } else {\n              // If the filter doesn't exist, we will fall back to use `getLogs`.\n              // The fall back exists because some RPC Providers do not support filters.\n\n              // Fetch the block number to use for `getLogs`.\n              const blockNumber = await getAction(\n                client,\n                getBlockNumber,\n                'getBlockNumber',\n              )({})\n\n              // If the block number has changed, we will need to fetch the logs.\n              // If the block number doesn't exist, we are yet to reach the first poll interval,\n              // so do not emit any logs.\n              if (previousBlockNumber && previousBlockNumber !== blockNumber) {\n                logs = await getAction(\n                  client,\n                  getLogs,\n                  'getLogs',\n                )({\n                  address,\n                  args,\n                  event: event!,\n                  events,\n                  fromBlock: previousBlockNumber + 1n,\n                  toBlock: blockNumber,\n                } as unknown as GetLogsParameters)\n              } else {\n                logs = []\n              }\n              previousBlockNumber = blockNumber\n            }\n\n            if (logs.length === 0) return\n            if (batch) emit.onLogs(logs as any)\n            else for (const log of logs) emit.onLogs([log] as any)\n          } catch (err) {\n            // If a filter has been set and gets uninstalled, providers will throw an InvalidInput error.\n            // Reinitialize the filter when this occurs\n            if (filter && err instanceof InvalidInputRpcError)\n              initialized = false\n            emit.onError?.(err as Error)\n          }\n        },\n        {\n          emitOnBegin: true,\n          interval: pollingInterval,\n        },\n      )\n\n      return async () => {\n        if (filter)\n          await getAction(\n            client,\n            uninstallFilter,\n            'uninstallFilter',\n          )({ filter })\n        unwatch()\n      }\n    })\n  }\n\n  const subscribeEvent = () => {\n    let active = true\n    let unsubscribe = () => (active = false)\n    ;(async () => {\n      try {\n        const transport = (() => {\n          if (client.transport.type === 'fallback') {\n            const transport = client.transport.transports.find(\n              (transport: ReturnType<Transport>) =>\n                transport.config.type === 'webSocket' ||\n                transport.config.type === 'ipc',\n            )\n            if (!transport) return client.transport\n            return transport.value\n          }\n          return client.transport\n        })()\n\n        const events_ = events ?? (event ? [event] : undefined)\n        let topics: LogTopic[] = []\n        if (events_) {\n          const encoded = (events_ as AbiEvent[]).flatMap((event) =>\n            encodeEventTopics({\n              abi: [event],\n              eventName: (event as AbiEvent).name,\n              args,\n            } as EncodeEventTopicsParameters),\n          )\n          // TODO: Clean up type casting\n          topics = [encoded as LogTopic]\n          if (event) topics = topics[0] as LogTopic[]\n        }\n\n        const { unsubscribe: unsubscribe_ } = await transport.subscribe({\n          params: ['logs', { address, topics }],\n          onData(data: any) {\n            if (!active) return\n            const log = data.result\n            try {\n              const { eventName, args } = decodeEventLog({\n                abi: events_ ?? [],\n                data: log.data,\n                topics: log.topics,\n                strict,\n              })\n              const formatted = formatLog(log, { args, eventName })\n              onLogs([formatted] as any)\n            } catch (err) {\n              let eventName: string | undefined\n              let isUnnamed: boolean | undefined\n              if (\n                err instanceof DecodeLogDataMismatch ||\n                err instanceof DecodeLogTopicsMismatch\n              ) {\n                // If strict mode is on, and log data/topics do not match event definition, skip.\n                if (strict_) return\n                eventName = err.abiItem.name\n                isUnnamed = err.abiItem.inputs?.some(\n                  (x) => !('name' in x && x.name),\n                )\n              }\n\n              // Set args to empty if there is an error decoding (e.g. indexed/non-indexed params mismatch).\n              const formatted = formatLog(log, {\n                args: isUnnamed ? [] : {},\n                eventName,\n              })\n              onLogs([formatted] as any)\n            }\n          },\n          onError(error: Error) {\n            onError?.(error)\n          },\n        })\n        unsubscribe = unsubscribe_\n        if (!active) unsubscribe()\n      } catch (err) {\n        onError?.(err as Error)\n      }\n    })()\n    return () => unsubscribe()\n  }\n\n  return enablePolling ? pollEvent() : subscribeEvent()\n}\n"],"mappings":"AAIA,SACEA,qBAAqB,EACrBC,uBAAuB,QAClB,qBAAqB;AAC5B,SAASC,oBAAoB,QAAQ,qBAAqB;AAY1D,SAASC,cAAc,QAAQ,mCAAmC;AAClE,SAEEC,iBAAiB,QACZ,sCAAsC;AAC7C,SAASC,SAAS,QAAQ,+BAA+B;AACzD,SAASC,SAAS,QAAQ,0BAA0B;AACpD,SAAgCC,OAAO,QAAQ,wBAAwB;AACvE,SAASC,IAAI,QAAQ,qBAAqB;AAC1C,SAAkCC,SAAS,QAAQ,0BAA0B;AAC7E,SAEEC,iBAAiB,QACZ,wBAAwB;AAC/B,SAASC,cAAc,QAAQ,qBAAqB;AACpD,SAASC,gBAAgB,QAAQ,uBAAuB;AACxD,SAAiCC,OAAO,QAAQ,cAAc;AAC9D,SAASC,eAAe,QAAQ,sBAAsB;AAgFtD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgCA,OAAM,SAAUC,UAAUA,CAWxBC,MAAgC,EAAAC,IAAA,EAa+B;EAAA,IAZ/D;IACEC,OAAO;IACPC,IAAI;IACJC,KAAK,GAAG,IAAI;IACZC,KAAK;IACLC,MAAM;IACNC,SAAS;IACTC,OAAO;IACPC,MAAM;IACNjB,IAAI,EAAEkB,KAAK;IACXC,eAAe,GAAGX,MAAM,CAACW,eAAe;IACxCC,MAAM,EAAEC;EAAO,CAC8C,GAAAZ,IAAA;EAE/D,MAAMa,aAAa,GAAG,CAAC,MAAK;IAC1B,IAAI,OAAOJ,KAAK,KAAK,WAAW,EAAE,OAAOA,KAAK;IAC9C,IAAI,OAAOH,SAAS,KAAK,QAAQ,EAAE,OAAO,IAAI;IAC9C,IACEP,MAAM,CAACe,SAAS,CAACC,IAAI,KAAK,WAAW,IACrChB,MAAM,CAACe,SAAS,CAACC,IAAI,KAAK,KAAK,EAE/B,OAAO,KAAK;IACd,IACEhB,MAAM,CAACe,SAAS,CAACC,IAAI,KAAK,UAAU,KACnChB,MAAM,CAACe,SAAS,CAACE,UAAU,CAAC,CAAC,CAAC,CAACC,MAAM,CAACF,IAAI,KAAK,WAAW,IACzDhB,MAAM,CAACe,SAAS,CAACE,UAAU,CAAC,CAAC,CAAC,CAACC,MAAM,CAACF,IAAI,KAAK,KAAK,CAAC,EAEvD,OAAO,KAAK;IACd,OAAO,IAAI;EACb,CAAC,EAAC,CAAE;EACJ,MAAMJ,MAAM,GAAGC,OAAO,aAAPA,OAAO,cAAPA,OAAO,GAAI,KAAK;EAE/B,MAAMM,SAAS,GAAGA,CAAA,KAAK;IACrB,MAAMC,UAAU,GAAG3B,SAAS,CAAC,CAC3B,YAAY,EACZS,OAAO,EACPC,IAAI,EACJC,KAAK,EACLJ,MAAM,CAACqB,GAAG,EACVhB,KAAK,EACLM,eAAe,EACfJ,SAAS,CACV,CAAC;IAEF,OAAOhB,OAAO,CAAC6B,UAAU,EAAE;MAAEX,MAAM;MAAED;IAAO,CAAE,EAAGc,IAAI,IAAI;MACvD,IAAIC,mBAA2B;MAC/B,IAAIhB,SAAS,KAAKiB,SAAS,EAAED,mBAAmB,GAAGhB,SAAS,GAAG,EAAE;MACjE,IAAIkB,MAAmD;MACvD,IAAIC,WAAW,GAAG,KAAK;MAEvB,MAAMC,OAAO,GAAGnC,IAAI,CAClB,YAAW;QACT,IAAI,CAACkC,WAAW,EAAE;UAChB,IAAI;YACFD,MAAM,GAAI,MAAMnC,SAAS,CACvBU,MAAM,EACNN,iBAAwB,EACxB,mBAAmB,CACpB,CAAC;cACAQ,OAAO;cACPC,IAAI;cACJE,KAAK,EAAEA,KAAM;cACbC,MAAM;cACNM,MAAM;cACNL;aACyC,CAI1C;UACH,CAAC,CAAC,OAAAqB,OAAA,EAAM,CAAC;UACTF,WAAW,GAAG,IAAI;UAClB;QACF;QAEA,IAAI;UACF,IAAIG,IAAW;UACf,IAAIJ,MAAM,EAAE;YACVI,IAAI,GAAG,MAAMvC,SAAS,CACpBU,MAAM,EACNJ,gBAAgB,EAChB,kBAAkB,CACnB,CAAC;cAAE6B;YAAM,CAAE,CAAC;UACf,CAAC,MAAM;YACL;YACA;YAEA;YACA,MAAMK,WAAW,GAAG,MAAMxC,SAAS,CACjCU,MAAM,EACNL,cAAc,EACd,gBAAgB,CACjB,CAAC,EAAE,CAAC;YAEL;YACA;YACA;YACA,IAAI4B,mBAAmB,IAAIA,mBAAmB,KAAKO,WAAW,EAAE;cAC9DD,IAAI,GAAG,MAAMvC,SAAS,CACpBU,MAAM,EACNH,OAAO,EACP,SAAS,CACV,CAAC;gBACAK,OAAO;gBACPC,IAAI;gBACJE,KAAK,EAAEA,KAAM;gBACbC,MAAM;gBACNC,SAAS,EAAEgB,mBAAmB,GAAG,EAAE;gBACnCQ,OAAO,EAAED;eACsB,CAAC;YACpC,CAAC,MAAM;cACLD,IAAI,GAAG,EAAE;YACX;YACAN,mBAAmB,GAAGO,WAAW;UACnC;UAEA,IAAID,IAAI,CAACG,MAAM,KAAK,CAAC,EAAE;UACvB,IAAI5B,KAAK,EAAEkB,IAAI,CAACb,MAAM,CAACoB,IAAW,CAAC,MAC9B,KAAK,MAAMI,GAAG,IAAIJ,IAAI,EAAEP,IAAI,CAACb,MAAM,CAAC,CAACwB,GAAG,CAAQ,CAAC;QACxD,CAAC,CAAC,OAAOC,GAAG,EAAE;UAAA,IAAAC,aAAA;UACZ;UACA;UACA,IAAIV,MAAM,IAAIS,GAAG,YAAYhD,oBAAoB,EAC/CwC,WAAW,GAAG,KAAK;UACrB,CAAAS,aAAA,GAAAb,IAAI,CAACd,OAAO,cAAA2B,aAAA,eAAZA,aAAA,CAAAC,IAAA,CAAAd,IAAI,EAAWY,GAAY,CAAC;QAC9B;MACF,CAAC,EACD;QACEG,WAAW,EAAE,IAAI;QACjBC,QAAQ,EAAE3B;OACX,CACF;MAED,OAAO,YAAW;QAChB,IAAIc,MAAM,EACR,MAAMnC,SAAS,CACbU,MAAM,EACNF,eAAe,EACf,iBAAiB,CAClB,CAAC;UAAE2B;QAAM,CAAE,CAAC;QACfE,OAAO,EAAE;MACX,CAAC;IACH,CAAC,CAAC;EACJ,CAAC;EAED,MAAMY,cAAc,GAAGA,CAAA,KAAK;IAC1B,IAAIC,MAAM,GAAG,IAAI;IACjB,IAAIC,WAAW,GAAGA,CAAA,KAAOD,MAAM,GAAG,KAAM;IACvC,CAAC,YAAW;MACX,IAAI;QACF,MAAMzB,SAAS,GAAG,CAAC,MAAK;UACtB,IAAIf,MAAM,CAACe,SAAS,CAACC,IAAI,KAAK,UAAU,EAAE;YACxC,MAAMD,SAAS,GAAGf,MAAM,CAACe,SAAS,CAACE,UAAU,CAACyB,IAAI,CAC/C3B,SAAgC,IAC/BA,SAAS,CAACG,MAAM,CAACF,IAAI,KAAK,WAAW,IACrCD,SAAS,CAACG,MAAM,CAACF,IAAI,KAAK,KAAK,CAClC;YACD,IAAI,CAACD,SAAS,EAAE,OAAOf,MAAM,CAACe,SAAS;YACvC,OAAOA,SAAS,CAAC4B,KAAK;UACxB;UACA,OAAO3C,MAAM,CAACe,SAAS;QACzB,CAAC,EAAC,CAAE;QAEJ,MAAM6B,OAAO,GAAGtC,MAAM,aAANA,MAAM,cAANA,MAAM,GAAKD,KAAK,GAAG,CAACA,KAAK,CAAC,GAAGmB,SAAU;QACvD,IAAIqB,MAAM,GAAe,EAAE;QAC3B,IAAID,OAAO,EAAE;UACX,MAAME,OAAO,GAAIF,OAAsB,CAACG,OAAO,CAAE1C,KAAK,IACpDjB,iBAAiB,CAAC;YAChB4D,GAAG,EAAE,CAAC3C,KAAK,CAAC;YACZ4C,SAAS,EAAG5C,KAAkB,CAAC6C,IAAI;YACnC/C;WAC8B,CAAC,CAClC;UACD;UACA0C,MAAM,GAAG,CAACC,OAAmB,CAAC;UAC9B,IAAIzC,KAAK,EAAEwC,MAAM,GAAGA,MAAM,CAAC,CAAC,CAAe;QAC7C;QAEA,MAAM;UAAEJ,WAAW,EAAEU;QAAY,CAAE,GAAG,MAAMpC,SAAS,CAACqC,SAAS,CAAC;UAC9DC,MAAM,EAAE,CAAC,MAAM,EAAE;YAAEnD,OAAO;YAAE2C;UAAM,CAAE,CAAC;UACrCS,MAAMA,CAACC,IAAS;YACd,IAAI,CAACf,MAAM,EAAE;YACb,MAAMP,GAAG,GAAGsB,IAAI,CAACC,MAAM;YACvB,IAAI;cACF,MAAM;gBAAEP,SAAS;gBAAE9C;cAAI,CAAE,GAAGhB,cAAc,CAAC;gBACzC6D,GAAG,EAAEJ,OAAO,aAAPA,OAAO,cAAPA,OAAO,GAAI,EAAE;gBAClBW,IAAI,EAAEtB,GAAG,CAACsB,IAAI;gBACdV,MAAM,EAAEZ,GAAG,CAACY,MAAM;gBAClBjC;eACD,CAAC;cACF,MAAM6C,SAAS,GAAGpE,SAAS,CAAC4C,GAAG,EAAE;gBAAE9B,IAAI;gBAAE8C;cAAS,CAAE,CAAC;cACrDxC,MAAM,CAAC,CAACgD,SAAS,CAAQ,CAAC;YAC5B,CAAC,CAAC,OAAOvB,GAAG,EAAE;cACZ,IAAIe,SAA6B;cACjC,IAAIS,SAA8B;cAClC,IACExB,GAAG,YAAYlD,qBAAqB,IACpCkD,GAAG,YAAYjD,uBAAuB,EACtC;gBAAA,IAAA0E,mBAAA;gBACA;gBACA,IAAI9C,OAAO,EAAE;gBACboC,SAAS,GAAGf,GAAG,CAAC0B,OAAO,CAACV,IAAI;gBAC5BQ,SAAS,IAAAC,mBAAA,GAAGzB,GAAG,CAAC0B,OAAO,CAACC,MAAM,cAAAF,mBAAA,uBAAlBA,mBAAA,CAAoBG,IAAI,CACjCC,CAAC,IAAK,EAAE,MAAM,IAAIA,CAAC,IAAIA,CAAC,CAACb,IAAI,CAAC,CAChC;cACH;cAEA;cACA,MAAMO,SAAS,GAAGpE,SAAS,CAAC4C,GAAG,EAAE;gBAC/B9B,IAAI,EAAEuD,SAAS,GAAG,EAAE,GAAG,EAAE;gBACzBT;eACD,CAAC;cACFxC,MAAM,CAAC,CAACgD,SAAS,CAAQ,CAAC;YAC5B;UACF,CAAC;UACDjD,OAAOA,CAACwD,KAAY;YAClBxD,OAAO,aAAPA,OAAO,eAAPA,OAAO,CAAGwD,KAAK,CAAC;UAClB;SACD,CAAC;QACFvB,WAAW,GAAGU,YAAY;QAC1B,IAAI,CAACX,MAAM,EAAEC,WAAW,EAAE;MAC5B,CAAC,CAAC,OAAOP,GAAG,EAAE;QACZ1B,OAAO,aAAPA,OAAO,eAAPA,OAAO,CAAG0B,GAAY,CAAC;MACzB;IACF,CAAC,EAAC,CAAE;IACJ,OAAO,MAAMO,WAAW,EAAE;EAC5B,CAAC;EAED,OAAO3B,aAAa,GAAGK,SAAS,EAAE,GAAGoB,cAAc,EAAE;AACvD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}