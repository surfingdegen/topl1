{"ast":null,"code":"import _objectSpread from \"/Users/mac/Desktop/topl1/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { secp256k1 } from '@noble/curves/secp256k1';\nimport * as Bytes from './Bytes.js';\nimport * as Errors from './Errors.js';\nimport * as Hex from './Hex.js';\nimport * as Json from './Json.js';\nimport * as Solidity from './Solidity.js';\n/**\n * Asserts that a Signature is valid.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.assert({\n *   r: -49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @error: InvalidSignatureRError:\n * // @error: Value `-549...n` is an invalid r value.\n * // @error: r must be a positive integer less than 2^256.\n * ```\n *\n * @param signature - The signature object to assert.\n */\nexport function assert(signature) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    recovered\n  } = options;\n  if (typeof signature.r === 'undefined') throw new MissingPropertiesError({\n    signature\n  });\n  if (typeof signature.s === 'undefined') throw new MissingPropertiesError({\n    signature\n  });\n  if (recovered && typeof signature.yParity === 'undefined') throw new MissingPropertiesError({\n    signature\n  });\n  if (signature.r < 0n || signature.r > Solidity.maxUint256) throw new InvalidRError({\n    value: signature.r\n  });\n  if (signature.s < 0n || signature.s > Solidity.maxUint256) throw new InvalidSError({\n    value: signature.s\n  });\n  if (typeof signature.yParity === 'number' && signature.yParity !== 0 && signature.yParity !== 1) throw new InvalidYParityError({\n    value: signature.yParity\n  });\n}\n/**\n * Deserializes a {@link ox#Bytes.Bytes} signature into a structured {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * Signature.fromBytes(new Uint8Array([128, 3, 131, ...]))\n * // @log: { r: 5231...n, s: 3522...n, yParity: 0 }\n * ```\n *\n * @param signature - The serialized signature.\n * @returns The deserialized {@link ox#Signature.Signature}.\n */\nexport function fromBytes(signature) {\n  return fromHex(Hex.fromBytes(signature));\n}\n/**\n * Deserializes a {@link ox#Hex.Hex} signature into a structured {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.fromHex('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c')\n * // @log: { r: 5231...n, s: 3522...n, yParity: 0 }\n * ```\n *\n * @param serialized - The serialized signature.\n * @returns The deserialized {@link ox#Signature.Signature}.\n */\nexport function fromHex(signature) {\n  if (signature.length !== 130 && signature.length !== 132) throw new InvalidSerializedSizeError({\n    signature\n  });\n  const r = BigInt(Hex.slice(signature, 0, 32));\n  const s = BigInt(Hex.slice(signature, 32, 64));\n  const yParity = (() => {\n    const yParity = Number(\"0x\".concat(signature.slice(130)));\n    if (Number.isNaN(yParity)) return undefined;\n    try {\n      return vToYParity(yParity);\n    } catch (_unused) {\n      throw new InvalidYParityError({\n        value: yParity\n      });\n    }\n  })();\n  if (typeof yParity === 'undefined') return {\n    r,\n    s\n  };\n  return {\n    r,\n    s,\n    yParity\n  };\n}\n/**\n * Extracts a {@link ox#Signature.Signature} from an arbitrary object that may include signature properties.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * Signature.extract({\n *   baz: 'barry',\n *   foo: 'bar',\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n *   zebra: 'stripes',\n * })\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1\n * // @log: }\n * ```\n *\n * @param value - The arbitrary object to extract the signature from.\n * @returns The extracted {@link ox#Signature.Signature}.\n */\nexport function extract(value) {\n  if (typeof value.r === 'undefined') return undefined;\n  if (typeof value.s === 'undefined') return undefined;\n  return from(value);\n}\n/**\n * Instantiates a typed {@link ox#Signature.Signature} object from a {@link ox#Signature.Signature}, {@link ox#Signature.Legacy}, {@link ox#Bytes.Bytes}, or {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db801')\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1,\n * // @log: }\n * ```\n *\n * @example\n * ### From Legacy\n *\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from({\n *   r: 47323457007453657207889730243826965761922296599680473886588287015755652701072n,\n *   s: 57228803202727131502949358313456071280488184270258293674242124340113824882788n,\n *   v: 27,\n * })\n * // @log: {\n * // @log:   r: 47323457007453657207889730243826965761922296599680473886588287015755652701072n,\n * // @log:   s: 57228803202727131502949358313456071280488184270258293674242124340113824882788n,\n * // @log:   yParity: 0\n * // @log: }\n * ```\n *\n * @param signature - The signature value to instantiate.\n * @returns The instantiated {@link ox#Signature.Signature}.\n */\nexport function from(signature) {\n  const signature_ = (() => {\n    if (typeof signature === 'string') return fromHex(signature);\n    if (signature instanceof Uint8Array) return fromBytes(signature);\n    if (typeof signature.r === 'string') return fromRpc(signature);\n    if (signature.v) return fromLegacy(signature);\n    return _objectSpread({\n      r: signature.r,\n      s: signature.s\n    }, typeof signature.yParity !== 'undefined' ? {\n      yParity: signature.yParity\n    } : {});\n  })();\n  assert(signature_);\n  return signature_;\n}\n/**\n * Converts a DER-encoded signature to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromDerBytes(new Uint8Array([132, 51, 23, ...]))\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log: }\n * ```\n *\n * @param signature - The DER-encoded signature to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nexport function fromDerBytes(signature) {\n  return fromDerHex(Hex.fromBytes(signature));\n}\n/**\n * Converts a DER-encoded signature to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromDerHex('0x304402206e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf02204a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8')\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log: }\n * ```\n *\n * @param signature - The DER-encoded signature to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nexport function fromDerHex(signature) {\n  const {\n    r,\n    s\n  } = secp256k1.Signature.fromDER(Hex.from(signature).slice(2));\n  return {\n    r,\n    s\n  };\n}\n/**\n * Converts a {@link ox#Signature.Legacy} into a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const legacy = Signature.fromLegacy({ r: 1n, s: 2n, v: 28 })\n * // @log: { r: 1n, s: 2n, yParity: 1 }\n * ```\n *\n * @param signature - The {@link ox#Signature.Legacy} to convert.\n * @returns The converted {@link ox#Signature.Signature}.\n */\nexport function fromLegacy(signature) {\n  return {\n    r: signature.r,\n    s: signature.s,\n    yParity: vToYParity(signature.v)\n  };\n}\n/**\n * Converts a {@link ox#Signature.Rpc} into a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromRpc({\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n * })\n * ```\n *\n * @param signature - The {@link ox#Signature.Rpc} to convert.\n * @returns The converted {@link ox#Signature.Signature}.\n */\nexport function fromRpc(signature) {\n  const yParity = (() => {\n    const v = signature.v ? Number(signature.v) : undefined;\n    let yParity = signature.yParity ? Number(signature.yParity) : undefined;\n    if (typeof v === 'number' && typeof yParity !== 'number') yParity = vToYParity(v);\n    if (typeof yParity !== 'number') throw new InvalidYParityError({\n      value: signature.yParity\n    });\n    return yParity;\n  })();\n  return {\n    r: BigInt(signature.r),\n    s: BigInt(signature.s),\n    yParity\n  };\n}\n/**\n * Converts a {@link ox#Signature.Tuple} to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromTuple(['0x01', '0x7b', '0x1c8'])\n * // @log: {\n * // @log:   r: 123n,\n * // @log:   s: 456n,\n * // @log:   yParity: 1,\n * // @log: }\n * ```\n *\n * @param tuple - The {@link ox#Signature.Tuple} to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nexport function fromTuple(tuple) {\n  const [yParity, r, s] = tuple;\n  return from({\n    r: r === '0x' ? 0n : BigInt(r),\n    s: s === '0x' ? 0n : BigInt(s),\n    yParity: yParity === '0x' ? 0 : Number(yParity)\n  });\n}\n/**\n * Serializes a {@link ox#Signature.Signature} to {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toBytes({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * // @log: Uint8Array [102, 16, 10, ...]\n * ```\n *\n * @param signature - The signature to serialize.\n * @returns The serialized signature.\n */\nexport function toBytes(signature) {\n  return Bytes.fromHex(toHex(signature));\n}\n/**\n * Serializes a {@link ox#Signature.Signature} to {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toHex({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * // @log: '0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c'\n * ```\n *\n * @param signature - The signature to serialize.\n * @returns The serialized signature.\n */\nexport function toHex(signature) {\n  assert(signature);\n  const r = signature.r;\n  const s = signature.s;\n  const signature_ = Hex.concat(Hex.fromNumber(r, {\n    size: 32\n  }), Hex.fromNumber(s, {\n    size: 32\n  }),\n  // If the signature is recovered, add the recovery byte to the signature.\n  typeof signature.yParity === 'number' ? Hex.fromNumber(yParityToV(signature.yParity), {\n    size: 1\n  }) : '0x');\n  return signature_;\n}\n/**\n * Converts a {@link ox#Signature.Signature} to DER-encoded format.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * })\n *\n * const signature_der = Signature.toDerBytes(signature)\n * // @log: Uint8Array [132, 51, 23, ...]\n * ```\n *\n * @param signature - The signature to convert.\n * @returns The DER-encoded signature.\n */\nexport function toDerBytes(signature) {\n  const sig = new secp256k1.Signature(signature.r, signature.s);\n  return sig.toDERRawBytes();\n}\n/**\n * Converts a {@link ox#Signature.Signature} to DER-encoded format.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * })\n *\n * const signature_der = Signature.toDerHex(signature)\n * // @log: '0x304402206e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf02204a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8'\n * ```\n *\n * @param signature - The signature to convert.\n * @returns The DER-encoded signature.\n */\nexport function toDerHex(signature) {\n  const sig = new secp256k1.Signature(signature.r, signature.s);\n  return \"0x\".concat(sig.toDERHex());\n}\n/**\n * Converts a {@link ox#Signature.Signature} into a {@link ox#Signature.Legacy}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const legacy = Signature.toLegacy({ r: 1n, s: 2n, yParity: 1 })\n * // @log: { r: 1n, s: 2n, v: 28 }\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The converted {@link ox#Signature.Legacy}.\n */\nexport function toLegacy(signature) {\n  return {\n    r: signature.r,\n    s: signature.s,\n    v: yParityToV(signature.yParity)\n  };\n}\n/**\n * Converts a {@link ox#Signature.Signature} into a {@link ox#Signature.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toRpc({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The converted {@link ox#Signature.Rpc}.\n */\nexport function toRpc(signature) {\n  const {\n    r,\n    s,\n    yParity\n  } = signature;\n  return {\n    r: Hex.fromNumber(r, {\n      size: 32\n    }),\n    s: Hex.fromNumber(s, {\n      size: 32\n    }),\n    yParity: yParity === 0 ? '0x0' : '0x1'\n  };\n}\n/**\n * Converts a {@link ox#Signature.Signature} to a serialized {@link ox#Signature.Tuple} to be used for signatures in Transaction Envelopes, EIP-7702 Authorization Lists, etc.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signatureTuple = Signature.toTuple({\n *   r: 123n,\n *   s: 456n,\n *   yParity: 1,\n * })\n * // @log: [yParity: '0x01', r: '0x7b', s: '0x1c8']\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The {@link ox#Signature.Tuple}.\n */\nexport function toTuple(signature) {\n  const {\n    r,\n    s,\n    yParity\n  } = signature;\n  return [yParity ? '0x01' : '0x', r === 0n ? '0x' : Hex.trimLeft(Hex.fromNumber(r)), s === 0n ? '0x' : Hex.trimLeft(Hex.fromNumber(s))];\n}\n/**\n * Validates a Signature. Returns `true` if the signature is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const valid = Signature.validate({\n *   r: -49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @log: false\n * ```\n *\n * @param signature - The signature object to assert.\n */\nexport function validate(signature) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  try {\n    assert(signature, options);\n    return true;\n  } catch (_unused2) {\n    return false;\n  }\n}\n/**\n * Converts a ECDSA `v` value to a `yParity` value.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const yParity = Signature.vToYParity(28)\n * // @log: 1\n * ```\n *\n * @param v - The ECDSA `v` value to convert.\n * @returns The `yParity` value.\n */\nexport function vToYParity(v) {\n  if (v === 0 || v === 27) return 0;\n  if (v === 1 || v === 28) return 1;\n  if (v >= 35) return v % 2 === 0 ? 1 : 0;\n  throw new InvalidVError({\n    value: v\n  });\n}\n/**\n * Converts a ECDSA `v` value to a `yParity` value.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const v = Signature.yParityToV(1)\n * // @log: 28\n * ```\n *\n * @param yParity - The ECDSA `yParity` value to convert.\n * @returns The `v` value.\n */\nexport function yParityToV(yParity) {\n  if (yParity === 0) return 27;\n  if (yParity === 1) return 28;\n  throw new InvalidYParityError({\n    value: yParity\n  });\n}\n/** Thrown when the serialized signature is of an invalid size. */\nexport class InvalidSerializedSizeError extends Errors.BaseError {\n  constructor(_ref) {\n    let {\n      signature\n    } = _ref;\n    super(\"Value `\".concat(signature, \"` is an invalid signature size.\"), {\n      metaMessages: ['Expected: 64 bytes or 65 bytes.', \"Received \".concat(Hex.size(Hex.from(signature)), \" bytes.\")]\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Signature.InvalidSerializedSizeError'\n    });\n  }\n}\n/** Thrown when the signature is missing either an `r`, `s`, or `yParity` property. */\nexport class MissingPropertiesError extends Errors.BaseError {\n  constructor(_ref2) {\n    let {\n      signature\n    } = _ref2;\n    super(\"Signature `\".concat(Json.stringify(signature), \"` is missing either an `r`, `s`, or `yParity` property.\"));\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Signature.MissingPropertiesError'\n    });\n  }\n}\n/** Thrown when the signature has an invalid `r` value. */\nexport class InvalidRError extends Errors.BaseError {\n  constructor(_ref3) {\n    let {\n      value\n    } = _ref3;\n    super(\"Value `\".concat(value, \"` is an invalid r value. r must be a positive integer less than 2^256.\"));\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Signature.InvalidRError'\n    });\n  }\n}\n/** Thrown when the signature has an invalid `s` value. */\nexport class InvalidSError extends Errors.BaseError {\n  constructor(_ref4) {\n    let {\n      value\n    } = _ref4;\n    super(\"Value `\".concat(value, \"` is an invalid s value. s must be a positive integer less than 2^256.\"));\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Signature.InvalidSError'\n    });\n  }\n}\n/** Thrown when the signature has an invalid `yParity` value. */\nexport class InvalidYParityError extends Errors.BaseError {\n  constructor(_ref5) {\n    let {\n      value\n    } = _ref5;\n    super(\"Value `\".concat(value, \"` is an invalid y-parity value. Y-parity must be 0 or 1.\"));\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Signature.InvalidYParityError'\n    });\n  }\n}\n/** Thrown when the signature has an invalid `v` value. */\nexport class InvalidVError extends Errors.BaseError {\n  constructor(_ref6) {\n    let {\n      value\n    } = _ref6;\n    super(\"Value `\".concat(value, \"` is an invalid v value. v must be 27, 28 or >=35.\"));\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Signature.InvalidVError'\n    });\n  }\n}","map":{"version":3,"names":["secp256k1","Bytes","Errors","Hex","Json","Solidity","assert","signature","options","arguments","length","undefined","recovered","r","MissingPropertiesError","s","yParity","maxUint256","InvalidRError","value","InvalidSError","InvalidYParityError","fromBytes","fromHex","InvalidSerializedSizeError","BigInt","slice","Number","concat","isNaN","vToYParity","_unused","extract","from","signature_","Uint8Array","fromRpc","v","fromLegacy","_objectSpread","fromDerBytes","fromDerHex","Signature","fromDER","fromTuple","tuple","toBytes","toHex","fromNumber","size","yParityToV","toDerBytes","sig","toDERRawBytes","toDerHex","toDERHex","toLegacy","toRpc","toTuple","trimLeft","validate","_unused2","InvalidVError","BaseError","constructor","_ref","metaMessages","Object","defineProperty","_ref2","stringify","_ref3","_ref4","_ref5","_ref6"],"sources":["/Users/mac/Desktop/topl1/frontend/node_modules/ox/core/Signature.ts"],"sourcesContent":["import { secp256k1 } from '@noble/curves/secp256k1'\nimport * as Bytes from './Bytes.js'\nimport * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport type { Compute, ExactPartial, OneOf } from './internal/types.js'\nimport * as Json from './Json.js'\nimport * as Solidity from './Solidity.js'\n\n/** Root type for an ECDSA signature. */\nexport type Signature<\n  recovered extends boolean = true,\n  bigintType = bigint,\n  numberType = number,\n> = Compute<\n  recovered extends true\n    ? {\n        r: bigintType\n        s: bigintType\n        yParity: numberType\n      }\n    : {\n        r: bigintType\n        s: bigintType\n        yParity?: numberType | undefined\n      }\n>\n\n/** RPC-formatted ECDSA signature. */\nexport type Rpc<recovered extends boolean = true> = Signature<\n  recovered,\n  Hex.Hex,\n  Hex.Hex\n>\n\n/** (Legacy) ECDSA signature. */\nexport type Legacy<bigintType = bigint, numberType = number> = {\n  r: bigintType\n  s: bigintType\n  v: numberType\n}\n\n/** RPC-formatted (Legacy) ECDSA signature. */\nexport type LegacyRpc = Legacy<Hex.Hex, Hex.Hex>\n\nexport type Tuple = readonly [yParity: Hex.Hex, r: Hex.Hex, s: Hex.Hex]\n\n/**\n * Asserts that a Signature is valid.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.assert({\n *   r: -49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @error: InvalidSignatureRError:\n * // @error: Value `-549...n` is an invalid r value.\n * // @error: r must be a positive integer less than 2^256.\n * ```\n *\n * @param signature - The signature object to assert.\n */\nexport function assert(\n  signature: ExactPartial<Signature>,\n  options: assert.Options = {},\n): asserts signature is Signature {\n  const { recovered } = options\n  if (typeof signature.r === 'undefined')\n    throw new MissingPropertiesError({ signature })\n  if (typeof signature.s === 'undefined')\n    throw new MissingPropertiesError({ signature })\n  if (recovered && typeof signature.yParity === 'undefined')\n    throw new MissingPropertiesError({ signature })\n  if (signature.r < 0n || signature.r > Solidity.maxUint256)\n    throw new InvalidRError({ value: signature.r })\n  if (signature.s < 0n || signature.s > Solidity.maxUint256)\n    throw new InvalidSError({ value: signature.s })\n  if (\n    typeof signature.yParity === 'number' &&\n    signature.yParity !== 0 &&\n    signature.yParity !== 1\n  )\n    throw new InvalidYParityError({ value: signature.yParity })\n}\n\nexport declare namespace assert {\n  type Options = {\n    /** Whether or not the signature should be recovered (contain `yParity`). */\n    recovered?: boolean\n  }\n\n  type ErrorType =\n    | MissingPropertiesError\n    | InvalidRError\n    | InvalidSError\n    | InvalidYParityError\n    | Errors.GlobalErrorType\n}\n\n/**\n * Deserializes a {@link ox#Bytes.Bytes} signature into a structured {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * Signature.fromBytes(new Uint8Array([128, 3, 131, ...]))\n * // @log: { r: 5231...n, s: 3522...n, yParity: 0 }\n * ```\n *\n * @param signature - The serialized signature.\n * @returns The deserialized {@link ox#Signature.Signature}.\n */\nexport function fromBytes(signature: Bytes.Bytes): Signature {\n  return fromHex(Hex.fromBytes(signature))\n}\n\nexport declare namespace fromBytes {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Deserializes a {@link ox#Hex.Hex} signature into a structured {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.fromHex('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c')\n * // @log: { r: 5231...n, s: 3522...n, yParity: 0 }\n * ```\n *\n * @param serialized - The serialized signature.\n * @returns The deserialized {@link ox#Signature.Signature}.\n */\nexport function fromHex(signature: Hex.Hex): Signature {\n  if (signature.length !== 130 && signature.length !== 132)\n    throw new InvalidSerializedSizeError({ signature })\n\n  const r = BigInt(Hex.slice(signature, 0, 32))\n  const s = BigInt(Hex.slice(signature, 32, 64))\n\n  const yParity = (() => {\n    const yParity = Number(`0x${signature.slice(130)}`)\n    if (Number.isNaN(yParity)) return undefined\n    try {\n      return vToYParity(yParity)\n    } catch {\n      throw new InvalidYParityError({ value: yParity })\n    }\n  })()\n\n  if (typeof yParity === 'undefined')\n    return {\n      r,\n      s,\n    } as never\n  return {\n    r,\n    s,\n    yParity,\n  } as never\n}\n\nexport declare namespace fromHex {\n  type ErrorType =\n    | Hex.from.ErrorType\n    | InvalidSerializedSizeError\n    | Errors.GlobalErrorType\n}\n\n/**\n * Extracts a {@link ox#Signature.Signature} from an arbitrary object that may include signature properties.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * Signature.extract({\n *   baz: 'barry',\n *   foo: 'bar',\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n *   zebra: 'stripes',\n * })\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1\n * // @log: }\n * ```\n *\n * @param value - The arbitrary object to extract the signature from.\n * @returns The extracted {@link ox#Signature.Signature}.\n */\nexport function extract(value: extract.Value): Signature | undefined {\n  if (typeof value.r === 'undefined') return undefined\n  if (typeof value.s === 'undefined') return undefined\n  return from(value as any)\n}\n\nexport declare namespace extract {\n  type Value = {\n    r?: bigint | Hex.Hex | undefined\n    s?: bigint | Hex.Hex | undefined\n    yParity?: number | Hex.Hex | undefined\n    v?: number | Hex.Hex | undefined\n  }\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Instantiates a typed {@link ox#Signature.Signature} object from a {@link ox#Signature.Signature}, {@link ox#Signature.Legacy}, {@link ox#Bytes.Bytes}, or {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db801')\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1,\n * // @log: }\n * ```\n *\n * @example\n * ### From Legacy\n *\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from({\n *   r: 47323457007453657207889730243826965761922296599680473886588287015755652701072n,\n *   s: 57228803202727131502949358313456071280488184270258293674242124340113824882788n,\n *   v: 27,\n * })\n * // @log: {\n * // @log:   r: 47323457007453657207889730243826965761922296599680473886588287015755652701072n,\n * // @log:   s: 57228803202727131502949358313456071280488184270258293674242124340113824882788n,\n * // @log:   yParity: 0\n * // @log: }\n * ```\n *\n * @param signature - The signature value to instantiate.\n * @returns The instantiated {@link ox#Signature.Signature}.\n */\nexport function from<\n  const signature extends\n    | OneOf<Signature<boolean> | Rpc<boolean> | Legacy | LegacyRpc>\n    | Hex.Hex\n    | Bytes.Bytes,\n>(\n  signature:\n    | signature\n    | OneOf<Signature<boolean> | Rpc<boolean> | Legacy | LegacyRpc>\n    | Hex.Hex\n    | Bytes.Bytes,\n): from.ReturnType<signature> {\n  const signature_ = (() => {\n    if (typeof signature === 'string') return fromHex(signature)\n    if (signature instanceof Uint8Array) return fromBytes(signature)\n    if (typeof signature.r === 'string') return fromRpc(signature)\n    if (signature.v) return fromLegacy(signature)\n    return {\n      r: signature.r,\n      s: signature.s,\n      ...(typeof signature.yParity !== 'undefined'\n        ? { yParity: signature.yParity }\n        : {}),\n    }\n  })()\n  assert(signature_)\n  return signature_ as never\n}\n\nexport declare namespace from {\n  type ReturnType<\n    signature extends\n      | OneOf<Signature<boolean> | Rpc<boolean> | Legacy | LegacyRpc>\n      | Hex.Hex\n      | Bytes.Bytes,\n  > = signature extends Signature<boolean> & { v?: undefined }\n    ? signature\n    : Signature\n\n  type ErrorType =\n    | assert.ErrorType\n    | fromBytes.ErrorType\n    | fromHex.ErrorType\n    | vToYParity.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Converts a DER-encoded signature to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromDerBytes(new Uint8Array([132, 51, 23, ...]))\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log: }\n * ```\n *\n * @param signature - The DER-encoded signature to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nexport function fromDerBytes(signature: Bytes.Bytes): Signature<false> {\n  return fromDerHex(Hex.fromBytes(signature))\n}\n\nexport declare namespace fromDerBytes {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a DER-encoded signature to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromDerHex('0x304402206e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf02204a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8')\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log: }\n * ```\n *\n * @param signature - The DER-encoded signature to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nexport function fromDerHex(signature: Hex.Hex): Signature<false> {\n  const { r, s } = secp256k1.Signature.fromDER(Hex.from(signature).slice(2))\n  return { r, s }\n}\n\nexport declare namespace fromDerHex {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Legacy} into a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const legacy = Signature.fromLegacy({ r: 1n, s: 2n, v: 28 })\n * // @log: { r: 1n, s: 2n, yParity: 1 }\n * ```\n *\n * @param signature - The {@link ox#Signature.Legacy} to convert.\n * @returns The converted {@link ox#Signature.Signature}.\n */\nexport function fromLegacy(signature: Legacy): Signature {\n  return {\n    r: signature.r,\n    s: signature.s,\n    yParity: vToYParity(signature.v),\n  }\n}\n\nexport declare namespace fromLegacy {\n  type ErrorType = vToYParity.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Rpc} into a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromRpc({\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n * })\n * ```\n *\n * @param signature - The {@link ox#Signature.Rpc} to convert.\n * @returns The converted {@link ox#Signature.Signature}.\n */\nexport function fromRpc(signature: {\n  r: Hex.Hex\n  s: Hex.Hex\n  yParity?: Hex.Hex | undefined\n  v?: Hex.Hex | undefined\n}): Signature {\n  const yParity = (() => {\n    const v = signature.v ? Number(signature.v) : undefined\n    let yParity = signature.yParity ? Number(signature.yParity) : undefined\n    if (typeof v === 'number' && typeof yParity !== 'number')\n      yParity = vToYParity(v)\n    if (typeof yParity !== 'number')\n      throw new InvalidYParityError({ value: signature.yParity })\n    return yParity\n  })()\n\n  return {\n    r: BigInt(signature.r),\n    s: BigInt(signature.s),\n    yParity,\n  }\n}\n\nexport declare namespace fromRpc {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Tuple} to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromTuple(['0x01', '0x7b', '0x1c8'])\n * // @log: {\n * // @log:   r: 123n,\n * // @log:   s: 456n,\n * // @log:   yParity: 1,\n * // @log: }\n * ```\n *\n * @param tuple - The {@link ox#Signature.Tuple} to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nexport function fromTuple(tuple: Tuple): Signature {\n  const [yParity, r, s] = tuple\n  return from({\n    r: r === '0x' ? 0n : BigInt(r),\n    s: s === '0x' ? 0n : BigInt(s),\n    yParity: yParity === '0x' ? 0 : Number(yParity),\n  })\n}\n\nexport declare namespace fromTuple {\n  type ErrorType = from.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Serializes a {@link ox#Signature.Signature} to {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toBytes({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * // @log: Uint8Array [102, 16, 10, ...]\n * ```\n *\n * @param signature - The signature to serialize.\n * @returns The serialized signature.\n */\nexport function toBytes(signature: Signature<boolean>): Bytes.Bytes {\n  return Bytes.fromHex(toHex(signature))\n}\n\nexport declare namespace toBytes {\n  type ErrorType =\n    | toHex.ErrorType\n    | Bytes.fromHex.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Serializes a {@link ox#Signature.Signature} to {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toHex({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * // @log: '0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c'\n * ```\n *\n * @param signature - The signature to serialize.\n * @returns The serialized signature.\n */\nexport function toHex(signature: Signature<boolean>): Hex.Hex {\n  assert(signature)\n\n  const r = signature.r\n  const s = signature.s\n\n  const signature_ = Hex.concat(\n    Hex.fromNumber(r, { size: 32 }),\n    Hex.fromNumber(s, { size: 32 }),\n    // If the signature is recovered, add the recovery byte to the signature.\n    typeof signature.yParity === 'number'\n      ? Hex.fromNumber(yParityToV(signature.yParity), { size: 1 })\n      : '0x',\n  )\n\n  return signature_\n}\n\nexport declare namespace toHex {\n  type ErrorType =\n    | Hex.concat.ErrorType\n    | Hex.fromNumber.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Signature} to DER-encoded format.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * })\n *\n * const signature_der = Signature.toDerBytes(signature)\n * // @log: Uint8Array [132, 51, 23, ...]\n * ```\n *\n * @param signature - The signature to convert.\n * @returns The DER-encoded signature.\n */\nexport function toDerBytes(signature: Signature<boolean>): Bytes.Bytes {\n  const sig = new secp256k1.Signature(signature.r, signature.s)\n  return sig.toDERRawBytes()\n}\n\nexport declare namespace toDerBytes {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Signature} to DER-encoded format.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * })\n *\n * const signature_der = Signature.toDerHex(signature)\n * // @log: '0x304402206e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf02204a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8'\n * ```\n *\n * @param signature - The signature to convert.\n * @returns The DER-encoded signature.\n */\nexport function toDerHex(signature: Signature<boolean>): Hex.Hex {\n  const sig = new secp256k1.Signature(signature.r, signature.s)\n  return `0x${sig.toDERHex()}`\n}\n\nexport declare namespace toDerHex {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Signature} into a {@link ox#Signature.Legacy}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const legacy = Signature.toLegacy({ r: 1n, s: 2n, yParity: 1 })\n * // @log: { r: 1n, s: 2n, v: 28 }\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The converted {@link ox#Signature.Legacy}.\n */\nexport function toLegacy(signature: Signature): Legacy {\n  return {\n    r: signature.r,\n    s: signature.s,\n    v: yParityToV(signature.yParity),\n  }\n}\n\nexport declare namespace toLegacy {\n  type ErrorType = yParityToV.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Signature} into a {@link ox#Signature.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toRpc({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The converted {@link ox#Signature.Rpc}.\n */\nexport function toRpc(signature: Signature): Rpc {\n  const { r, s, yParity } = signature\n  return {\n    r: Hex.fromNumber(r, { size: 32 }),\n    s: Hex.fromNumber(s, { size: 32 }),\n    yParity: yParity === 0 ? '0x0' : '0x1',\n  }\n}\n\nexport declare namespace toRpc {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Signature} to a serialized {@link ox#Signature.Tuple} to be used for signatures in Transaction Envelopes, EIP-7702 Authorization Lists, etc.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signatureTuple = Signature.toTuple({\n *   r: 123n,\n *   s: 456n,\n *   yParity: 1,\n * })\n * // @log: [yParity: '0x01', r: '0x7b', s: '0x1c8']\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The {@link ox#Signature.Tuple}.\n */\nexport function toTuple(signature: Signature): Tuple {\n  const { r, s, yParity } = signature\n\n  return [\n    yParity ? '0x01' : '0x',\n    r === 0n ? '0x' : Hex.trimLeft(Hex.fromNumber(r!)),\n    s === 0n ? '0x' : Hex.trimLeft(Hex.fromNumber(s!)),\n  ] as const\n}\n\nexport declare namespace toTuple {\n  type ErrorType =\n    | Hex.trimLeft.ErrorType\n    | Hex.fromNumber.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Validates a Signature. Returns `true` if the signature is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const valid = Signature.validate({\n *   r: -49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @log: false\n * ```\n *\n * @param signature - The signature object to assert.\n */\nexport function validate(\n  signature: ExactPartial<Signature>,\n  options: validate.Options = {},\n): boolean {\n  try {\n    assert(signature, options)\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport declare namespace validate {\n  type Options = {\n    /** Whether or not the signature should be recovered (contain `yParity`). */\n    recovered?: boolean\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a ECDSA `v` value to a `yParity` value.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const yParity = Signature.vToYParity(28)\n * // @log: 1\n * ```\n *\n * @param v - The ECDSA `v` value to convert.\n * @returns The `yParity` value.\n */\nexport function vToYParity(v: number): Signature['yParity'] {\n  if (v === 0 || v === 27) return 0\n  if (v === 1 || v === 28) return 1\n  if (v >= 35) return v % 2 === 0 ? 1 : 0\n  throw new InvalidVError({ value: v })\n}\n\nexport declare namespace vToYParity {\n  type ErrorType = InvalidVError | Errors.GlobalErrorType\n}\n\n/**\n * Converts a ECDSA `v` value to a `yParity` value.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const v = Signature.yParityToV(1)\n * // @log: 28\n * ```\n *\n * @param yParity - The ECDSA `yParity` value to convert.\n * @returns The `v` value.\n */\nexport function yParityToV(yParity: number): number {\n  if (yParity === 0) return 27\n  if (yParity === 1) return 28\n  throw new InvalidYParityError({ value: yParity })\n}\n\nexport declare namespace yParityToV {\n  type ErrorType = InvalidVError | Errors.GlobalErrorType\n}\n\n/** Thrown when the serialized signature is of an invalid size. */\nexport class InvalidSerializedSizeError extends Errors.BaseError {\n  override readonly name = 'Signature.InvalidSerializedSizeError'\n\n  constructor({ signature }: { signature: Hex.Hex | Bytes.Bytes }) {\n    super(`Value \\`${signature}\\` is an invalid signature size.`, {\n      metaMessages: [\n        'Expected: 64 bytes or 65 bytes.',\n        `Received ${Hex.size(Hex.from(signature))} bytes.`,\n      ],\n    })\n  }\n}\n\n/** Thrown when the signature is missing either an `r`, `s`, or `yParity` property. */\nexport class MissingPropertiesError extends Errors.BaseError {\n  override readonly name = 'Signature.MissingPropertiesError'\n\n  constructor({ signature }: { signature: unknown }) {\n    super(\n      `Signature \\`${Json.stringify(signature)}\\` is missing either an \\`r\\`, \\`s\\`, or \\`yParity\\` property.`,\n    )\n  }\n}\n\n/** Thrown when the signature has an invalid `r` value. */\nexport class InvalidRError extends Errors.BaseError {\n  override readonly name = 'Signature.InvalidRError'\n\n  constructor({ value }: { value: unknown }) {\n    super(\n      `Value \\`${value}\\` is an invalid r value. r must be a positive integer less than 2^256.`,\n    )\n  }\n}\n\n/** Thrown when the signature has an invalid `s` value. */\nexport class InvalidSError extends Errors.BaseError {\n  override readonly name = 'Signature.InvalidSError'\n\n  constructor({ value }: { value: unknown }) {\n    super(\n      `Value \\`${value}\\` is an invalid s value. s must be a positive integer less than 2^256.`,\n    )\n  }\n}\n\n/** Thrown when the signature has an invalid `yParity` value. */\nexport class InvalidYParityError extends Errors.BaseError {\n  override readonly name = 'Signature.InvalidYParityError'\n\n  constructor({ value }: { value: unknown }) {\n    super(\n      `Value \\`${value}\\` is an invalid y-parity value. Y-parity must be 0 or 1.`,\n    )\n  }\n}\n\n/** Thrown when the signature has an invalid `v` value. */\nexport class InvalidVError extends Errors.BaseError {\n  override readonly name = 'Signature.InvalidVError'\n\n  constructor({ value }: { value: number }) {\n    super(`Value \\`${value}\\` is an invalid v value. v must be 27, 28 or >=35.`)\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}