{"ast":null,"code":"import _objectSpread from \"/Users/mac/Desktop/topl1/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/Users/mac/Desktop/topl1/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"accessList\", \"authorizationList\", \"blobs\", \"blobVersionedHashes\", \"blockNumber\", \"blockTag\", \"data\", \"gas\", \"gasPrice\", \"maxFeePerBlobGas\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"value\", \"stateOverride\"];\nimport { parseAccount } from '../../accounts/utils/parseAccount.js';\nimport { BaseError } from '../../errors/base.js';\nimport { recoverAuthorizationAddress } from '../../utils/authorization/recoverAuthorizationAddress.js';\nimport { numberToHex } from '../../utils/encoding/toHex.js';\nimport { getEstimateGasError } from '../../utils/errors/getEstimateGasError.js';\nimport { extract } from '../../utils/formatters/extract.js';\nimport { formatTransactionRequest } from '../../utils/formatters/transactionRequest.js';\nimport { serializeStateOverride } from '../../utils/stateOverride.js';\nimport { assertRequest } from '../../utils/transaction/assertRequest.js';\nimport { prepareTransactionRequest } from '../wallet/prepareTransactionRequest.js';\n/**\n * Estimates the gas necessary to complete a transaction without submitting it to the network.\n *\n * - Docs: https://viem.sh/docs/actions/public/estimateGas\n * - JSON-RPC Methods: [`eth_estimateGas`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_estimategas)\n *\n * @param client - Client to use\n * @param parameters - {@link EstimateGasParameters}\n * @returns The gas estimate (in gas units). {@link EstimateGasReturnType}\n *\n * @example\n * import { createPublicClient, http, parseEther } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { estimateGas } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const gasEstimate = await estimateGas(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: parseEther('1'),\n * })\n */\nexport async function estimateGas(client, args) {\n  const {\n    account: account_ = client.account,\n    prepare = true\n  } = args;\n  const account = account_ ? parseAccount(account_) : undefined;\n  const parameters = (() => {\n    if (Array.isArray(prepare)) return prepare;\n    // Some RPC Providers do not compute versioned hashes from blobs. We will need\n    // to compute them.\n    if ((account === null || account === void 0 ? void 0 : account.type) !== 'local') return ['blobVersionedHashes'];\n    return undefined;\n  })();\n  try {\n    var _client$chain, _ref2;\n    const to = await (async () => {\n      // If `to` exists on the parameters, use that.\n      if (args.to) return args.to;\n      // If no `to` exists, and we are sending a EIP-7702 transaction, use the\n      // address of the first authorization in the list.\n      if (args.authorizationList && args.authorizationList.length > 0) return await recoverAuthorizationAddress({\n        authorization: args.authorizationList[0]\n      }).catch(() => {\n        throw new BaseError('`to` is required. Could not infer from `authorizationList`');\n      });\n      // Otherwise, we are sending a deployment transaction.\n      return undefined;\n    })();\n    const _ref = prepare ? await prepareTransactionRequest(client, _objectSpread(_objectSpread({}, args), {}, {\n        parameters,\n        to\n      })) : args,\n      {\n        accessList,\n        authorizationList,\n        blobs,\n        blobVersionedHashes,\n        blockNumber,\n        blockTag,\n        data,\n        gas,\n        gasPrice,\n        maxFeePerBlobGas,\n        maxFeePerGas,\n        maxPriorityFeePerGas,\n        nonce,\n        value,\n        stateOverride\n      } = _ref,\n      rest = _objectWithoutProperties(_ref, _excluded);\n    // If we get `gas` back from the prepared transaction request, which is\n    // different from the `gas` we provided, it was likely filled by other means\n    // during request preparation (e.g. `eth_fillTransaction` or `chain.transactionRequest.prepare`).\n    // (e.g. `eth_fillTransaction` or `chain.transactionRequest.prepare`).\n    if (gas && args.gas !== gas) return gas;\n    const blockNumberHex = typeof blockNumber === 'bigint' ? numberToHex(blockNumber) : undefined;\n    const block = blockNumberHex || blockTag;\n    const rpcStateOverride = serializeStateOverride(stateOverride);\n    assertRequest(args);\n    const chainFormat = (_client$chain = client.chain) === null || _client$chain === void 0 || (_client$chain = _client$chain.formatters) === null || _client$chain === void 0 || (_client$chain = _client$chain.transactionRequest) === null || _client$chain === void 0 ? void 0 : _client$chain.format;\n    const format = chainFormat || formatTransactionRequest;\n    const request = format(_objectSpread(_objectSpread({}, extract(rest, {\n      format: chainFormat\n    })), {}, {\n      account,\n      accessList,\n      authorizationList,\n      blobs,\n      blobVersionedHashes,\n      data,\n      gasPrice,\n      maxFeePerBlobGas,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      to,\n      value\n    }), 'estimateGas');\n    return BigInt(await client.request({\n      method: 'eth_estimateGas',\n      params: rpcStateOverride ? [request, (_ref2 = block !== null && block !== void 0 ? block : client.experimental_blockTag) !== null && _ref2 !== void 0 ? _ref2 : 'latest', rpcStateOverride] : block ? [request, block] : [request]\n    }));\n  } catch (err) {\n    throw getEstimateGasError(err, _objectSpread(_objectSpread({}, args), {}, {\n      account,\n      chain: client.chain\n    }));\n  }\n}","map":{"version":3,"names":["parseAccount","BaseError","recoverAuthorizationAddress","numberToHex","getEstimateGasError","extract","formatTransactionRequest","serializeStateOverride","assertRequest","prepareTransactionRequest","estimateGas","client","args","account","account_","prepare","undefined","parameters","Array","isArray","type","_client$chain","_ref2","to","authorizationList","length","authorization","catch","_ref","_objectSpread","accessList","blobs","blobVersionedHashes","blockNumber","blockTag","data","gas","gasPrice","maxFeePerBlobGas","maxFeePerGas","maxPriorityFeePerGas","nonce","value","stateOverride","rest","_objectWithoutProperties","_excluded","blockNumberHex","block","rpcStateOverride","chainFormat","chain","formatters","transactionRequest","format","request","BigInt","method","params","experimental_blockTag","err"],"sources":["/Users/mac/Desktop/topl1/frontend/node_modules/viem/actions/public/estimateGas.ts"],"sourcesContent":["import type { Address } from 'abitype'\nimport type { Account } from '../../accounts/types.js'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { BaseError } from '../../errors/base.js'\nimport type { BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { StateOverride } from '../../types/stateOverride.js'\nimport type { TransactionRequest } from '../../types/transaction.js'\nimport type { UnionOmit } from '../../types/utils.js'\nimport {\n  type RecoverAuthorizationAddressErrorType,\n  recoverAuthorizationAddress,\n} from '../../utils/authorization/recoverAuthorizationAddress.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\nimport {\n  type GetEstimateGasErrorReturnType,\n  getEstimateGasError,\n} from '../../utils/errors/getEstimateGasError.js'\nimport { extract } from '../../utils/formatters/extract.js'\nimport {\n  type FormattedTransactionRequest,\n  formatTransactionRequest,\n} from '../../utils/formatters/transactionRequest.js'\nimport { serializeStateOverride } from '../../utils/stateOverride.js'\nimport {\n  type AssertRequestErrorType,\n  type AssertRequestParameters,\n  assertRequest,\n} from '../../utils/transaction/assertRequest.js'\nimport {\n  type PrepareTransactionRequestParameters,\n  type PrepareTransactionRequestParameterType,\n  prepareTransactionRequest,\n} from '../wallet/prepareTransactionRequest.js'\n\nexport type EstimateGasParameters<\n  chain extends Chain | undefined = Chain | undefined,\n> = UnionOmit<FormattedEstimateGas<chain>, 'from'> & {\n  account?: Account | Address | undefined\n  prepare?:\n    | boolean\n    | readonly PrepareTransactionRequestParameterType[]\n    | undefined\n  stateOverride?: StateOverride | undefined\n} & (\n    | {\n        /** The balance of the account at a block number. */\n        blockNumber?: bigint | undefined\n        blockTag?: undefined\n      }\n    | {\n        blockNumber?: undefined\n        /**\n         * The balance of the account at a block tag.\n         * @default 'latest'\n         */\n        blockTag?: BlockTag | undefined\n      }\n  )\ntype FormattedEstimateGas<chain extends Chain | undefined = Chain | undefined> =\n  FormattedTransactionRequest<chain>\n\nexport type EstimateGasReturnType = bigint\n\nexport type EstimateGasErrorType = GetEstimateGasErrorReturnType<\n  | ParseAccountErrorType\n  | NumberToHexErrorType\n  | RequestErrorType\n  | RecoverAuthorizationAddressErrorType\n  | AssertRequestErrorType\n>\n\n/**\n * Estimates the gas necessary to complete a transaction without submitting it to the network.\n *\n * - Docs: https://viem.sh/docs/actions/public/estimateGas\n * - JSON-RPC Methods: [`eth_estimateGas`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_estimategas)\n *\n * @param client - Client to use\n * @param parameters - {@link EstimateGasParameters}\n * @returns The gas estimate (in gas units). {@link EstimateGasReturnType}\n *\n * @example\n * import { createPublicClient, http, parseEther } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { estimateGas } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const gasEstimate = await estimateGas(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: parseEther('1'),\n * })\n */\nexport async function estimateGas<\n  chain extends Chain | undefined,\n  account extends Account | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  args: EstimateGasParameters<chain>,\n): Promise<EstimateGasReturnType> {\n  const { account: account_ = client.account, prepare = true } = args\n  const account = account_ ? parseAccount(account_) : undefined\n\n  const parameters = (() => {\n    if (Array.isArray(prepare)) return prepare\n    // Some RPC Providers do not compute versioned hashes from blobs. We will need\n    // to compute them.\n    if (account?.type !== 'local') return ['blobVersionedHashes']\n    return undefined\n  })()\n\n  try {\n    const to = await (async () => {\n      // If `to` exists on the parameters, use that.\n      if (args.to) return args.to\n\n      // If no `to` exists, and we are sending a EIP-7702 transaction, use the\n      // address of the first authorization in the list.\n      if (args.authorizationList && args.authorizationList.length > 0)\n        return await recoverAuthorizationAddress({\n          authorization: args.authorizationList[0],\n        }).catch(() => {\n          throw new BaseError(\n            '`to` is required. Could not infer from `authorizationList`',\n          )\n        })\n\n      // Otherwise, we are sending a deployment transaction.\n      return undefined\n    })()\n\n    const {\n      accessList,\n      authorizationList,\n      blobs,\n      blobVersionedHashes,\n      blockNumber,\n      blockTag,\n      data,\n      gas,\n      gasPrice,\n      maxFeePerBlobGas,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      value,\n      stateOverride,\n      ...rest\n    } = prepare\n      ? ((await prepareTransactionRequest(client, {\n          ...args,\n          parameters,\n          to,\n        } as PrepareTransactionRequestParameters)) as EstimateGasParameters)\n      : args\n\n    // If we get `gas` back from the prepared transaction request, which is\n    // different from the `gas` we provided, it was likely filled by other means\n    // during request preparation (e.g. `eth_fillTransaction` or `chain.transactionRequest.prepare`).\n    // (e.g. `eth_fillTransaction` or `chain.transactionRequest.prepare`).\n    if (gas && args.gas !== gas) return gas\n\n    const blockNumberHex =\n      typeof blockNumber === 'bigint' ? numberToHex(blockNumber) : undefined\n    const block = blockNumberHex || blockTag\n\n    const rpcStateOverride = serializeStateOverride(stateOverride)\n\n    assertRequest(args as AssertRequestParameters)\n\n    const chainFormat = client.chain?.formatters?.transactionRequest?.format\n    const format = chainFormat || formatTransactionRequest\n\n    const request = format(\n      {\n        // Pick out extra data that might exist on the chain's transaction request type.\n        ...extract(rest, { format: chainFormat }),\n        account,\n        accessList,\n        authorizationList,\n        blobs,\n        blobVersionedHashes,\n        data,\n        gasPrice,\n        maxFeePerBlobGas,\n        maxFeePerGas,\n        maxPriorityFeePerGas,\n        nonce,\n        to,\n        value,\n      } as TransactionRequest,\n      'estimateGas',\n    )\n\n    return BigInt(\n      await client.request({\n        method: 'eth_estimateGas',\n        params: rpcStateOverride\n          ? [\n              request,\n              block ?? client.experimental_blockTag ?? 'latest',\n              rpcStateOverride,\n            ]\n          : block\n            ? [request, block]\n            : [request],\n      }),\n    )\n  } catch (err) {\n    throw getEstimateGasError(err as BaseError, {\n      ...args,\n      account,\n      chain: client.chain,\n    })\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}