{"ast":null,"code":"import _objectSpread from \"/Users/mac/Desktop/topl1/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/Users/mac/Desktop/topl1/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"abi\", \"account\", \"address\", \"args\", \"dataSuffix\", \"functionName\"];\nimport { parseAccount } from '../../accounts/utils/parseAccount.js';\nimport { AccountNotFoundError } from '../../errors/account.js';\nimport { encodeFunctionData } from '../../utils/abi/encodeFunctionData.js';\nimport { getContractError } from '../../utils/errors/getContractError.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { sendTransaction } from './sendTransaction.js';\n/**\n * Executes a write function on a contract.\n *\n * - Docs: https://viem.sh/docs/contract/writeContract\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts_writing-to-contracts\n *\n * A \"write\" function on a Solidity contract modifies the state of the blockchain. These types of functions require gas to be executed, and hence a [Transaction](https://viem.sh/docs/glossary/terms) is needed to be broadcast in order to change the state.\n *\n * Internally, uses a [Wallet Client](https://viem.sh/docs/clients/wallet) to call the [`sendTransaction` action](https://viem.sh/docs/actions/wallet/sendTransaction) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData).\n *\n * __Warning: The `write` internally sends a transaction – it does not validate if the contract write will succeed (the contract may throw an error). It is highly recommended to [simulate the contract write with `contract.simulate`](https://viem.sh/docs/contract/writeContract#usage) before you execute it.__\n *\n * @param client - Client to use\n * @param parameters - {@link WriteContractParameters}\n * @returns A [Transaction Hash](https://viem.sh/docs/glossary/terms#hash). {@link WriteContractReturnType}\n *\n * @example\n * import { createWalletClient, custom, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { writeContract } from 'viem/contract'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const hash = await writeContract(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['function mint(uint32 tokenId) nonpayable']),\n *   functionName: 'mint',\n *   args: [69420],\n * })\n *\n * @example\n * // With Validation\n * import { createWalletClient, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { simulateContract, writeContract } from 'viem/contract'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const { request } = await simulateContract(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['function mint(uint32 tokenId) nonpayable']),\n *   functionName: 'mint',\n *   args: [69420],\n * }\n * const hash = await writeContract(client, request)\n */\nexport async function writeContract(client, parameters) {\n  return writeContract.internal(client, sendTransaction, 'sendTransaction', parameters);\n}\n(function (writeContract) {\n  async function internal(client, actionFn, name, parameters) {\n    const {\n        abi,\n        account: account_ = client.account,\n        address,\n        args,\n        dataSuffix,\n        functionName\n      } = parameters,\n      request = _objectWithoutProperties(parameters, _excluded);\n    if (typeof account_ === 'undefined') throw new AccountNotFoundError({\n      docsPath: '/docs/contract/writeContract'\n    });\n    const account = account_ ? parseAccount(account_) : null;\n    const data = encodeFunctionData({\n      abi,\n      args,\n      functionName\n    });\n    try {\n      return await getAction(client, actionFn, name)(_objectSpread({\n        data: \"\".concat(data).concat(dataSuffix ? dataSuffix.replace('0x', '') : ''),\n        to: address,\n        account\n      }, request));\n    } catch (error) {\n      throw getContractError(error, {\n        abi,\n        address,\n        args,\n        docsPath: '/docs/contract/writeContract',\n        functionName,\n        sender: account === null || account === void 0 ? void 0 : account.address\n      });\n    }\n  }\n  writeContract.internal = internal;\n})(writeContract || (writeContract = {}));","map":{"version":3,"names":["parseAccount","AccountNotFoundError","encodeFunctionData","getContractError","getAction","sendTransaction","writeContract","client","parameters","internal","actionFn","name","abi","account","account_","address","args","dataSuffix","functionName","request","_objectWithoutProperties","_excluded","docsPath","data","_objectSpread","concat","replace","to","error","sender"],"sources":["/Users/mac/Desktop/topl1/frontend/node_modules/viem/actions/wallet/writeContract.ts"],"sourcesContent":["import type { Abi, Address } from 'abitype'\n\nimport type { Account } from '../../accounts/types.js'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  AccountNotFoundError,\n  type AccountNotFoundErrorType,\n} from '../../errors/account.js'\nimport type { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { GetAccountParameter } from '../../types/account.js'\nimport type {\n  Chain,\n  DeriveChain,\n  GetChainParameter,\n} from '../../types/chain.js'\nimport type {\n  ContractFunctionArgs,\n  ContractFunctionName,\n  ContractFunctionParameters,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { Prettify, UnionEvaluate, UnionOmit } from '../../types/utils.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  type EncodeFunctionDataParameters,\n  encodeFunctionData,\n} from '../../utils/abi/encodeFunctionData.js'\nimport {\n  type GetContractErrorReturnType,\n  getContractError,\n} from '../../utils/errors/getContractError.js'\nimport type { FormattedTransactionRequest } from '../../utils/formatters/transactionRequest.js'\nimport { getAction } from '../../utils/getAction.js'\nimport type { GetMutabilityAwareValue } from '../public/simulateContract.js'\nimport {\n  type SendTransactionErrorType,\n  type SendTransactionReturnType,\n  sendTransaction,\n} from './sendTransaction.js'\nimport type { sendTransactionSync } from './sendTransactionSync.js'\n\nexport type WriteContractParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends ContractFunctionName<\n    abi,\n    'nonpayable' | 'payable'\n  > = ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  > = ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>,\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  ///\n  allFunctionNames = ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = ContractFunctionParameters<\n  abi,\n  'nonpayable' | 'payable',\n  functionName,\n  args,\n  false,\n  allFunctionNames\n> &\n  GetChainParameter<chain, chainOverride> &\n  Prettify<\n    GetAccountParameter<account, Account | Address, true, true> &\n      GetMutabilityAwareValue<\n        abi,\n        'nonpayable' | 'payable',\n        functionName,\n        FormattedTransactionRequest<derivedChain>['value'],\n        args\n      > & {\n        /** Data to append to the end of the calldata. Useful for adding a [\"domain\" tag](https://opensea.notion.site/opensea/Seaport-Order-Attributions-ec2d69bf455041a5baa490941aad307f). */\n        dataSuffix?: Hex | undefined\n      }\n  > &\n  UnionEvaluate<\n    UnionOmit<\n      FormattedTransactionRequest<derivedChain>,\n      'data' | 'from' | 'to' | 'value'\n    >\n  >\n\nexport type WriteContractReturnType = SendTransactionReturnType\n\nexport type WriteContractErrorType =\n  | EncodeFunctionDataErrorType\n  | AccountNotFoundErrorType\n  | ParseAccountErrorType\n  | GetContractErrorReturnType<SendTransactionErrorType>\n  | ErrorType\n\n/**\n * Executes a write function on a contract.\n *\n * - Docs: https://viem.sh/docs/contract/writeContract\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts_writing-to-contracts\n *\n * A \"write\" function on a Solidity contract modifies the state of the blockchain. These types of functions require gas to be executed, and hence a [Transaction](https://viem.sh/docs/glossary/terms) is needed to be broadcast in order to change the state.\n *\n * Internally, uses a [Wallet Client](https://viem.sh/docs/clients/wallet) to call the [`sendTransaction` action](https://viem.sh/docs/actions/wallet/sendTransaction) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData).\n *\n * __Warning: The `write` internally sends a transaction – it does not validate if the contract write will succeed (the contract may throw an error). It is highly recommended to [simulate the contract write with `contract.simulate`](https://viem.sh/docs/contract/writeContract#usage) before you execute it.__\n *\n * @param client - Client to use\n * @param parameters - {@link WriteContractParameters}\n * @returns A [Transaction Hash](https://viem.sh/docs/glossary/terms#hash). {@link WriteContractReturnType}\n *\n * @example\n * import { createWalletClient, custom, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { writeContract } from 'viem/contract'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const hash = await writeContract(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['function mint(uint32 tokenId) nonpayable']),\n *   functionName: 'mint',\n *   args: [69420],\n * })\n *\n * @example\n * // With Validation\n * import { createWalletClient, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { simulateContract, writeContract } from 'viem/contract'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const { request } = await simulateContract(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['function mint(uint32 tokenId) nonpayable']),\n *   functionName: 'mint',\n *   args: [69420],\n * }\n * const hash = await writeContract(client, request)\n */\nexport async function writeContract<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  >,\n  chainOverride extends Chain | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: WriteContractParameters<\n    abi,\n    functionName,\n    args,\n    chain,\n    account,\n    chainOverride\n  >,\n): Promise<WriteContractReturnType> {\n  return writeContract.internal(\n    client,\n    sendTransaction,\n    'sendTransaction',\n    parameters,\n  ) as never\n}\n\nexport namespace writeContract {\n  export async function internal<\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n    const abi extends Abi | readonly unknown[],\n    functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n    args extends ContractFunctionArgs<\n      abi,\n      'nonpayable' | 'payable',\n      functionName\n    >,\n    chainOverride extends Chain | undefined,\n  >(\n    client: Client<Transport, chain, account>,\n    actionFn: typeof sendTransaction | typeof sendTransactionSync,\n    name: 'sendTransaction' | 'sendTransactionSync',\n    parameters: WriteContractParameters<\n      abi,\n      functionName,\n      args,\n      chain,\n      account,\n      chainOverride\n    >,\n  ) {\n    const {\n      abi,\n      account: account_ = client.account,\n      address,\n      args,\n      dataSuffix,\n      functionName,\n      ...request\n    } = parameters as WriteContractParameters\n\n    if (typeof account_ === 'undefined')\n      throw new AccountNotFoundError({\n        docsPath: '/docs/contract/writeContract',\n      })\n    const account = account_ ? parseAccount(account_) : null\n\n    const data = encodeFunctionData({\n      abi,\n      args,\n      functionName,\n    } as EncodeFunctionDataParameters)\n\n    try {\n      return await getAction(\n        client,\n        actionFn as never,\n        name,\n      )({\n        data: `${data}${dataSuffix ? dataSuffix.replace('0x', '') : ''}`,\n        to: address,\n        account,\n        ...request,\n      })\n    } catch (error) {\n      throw getContractError(error as BaseError, {\n        abi,\n        address,\n        args,\n        docsPath: '/docs/contract/writeContract',\n        functionName,\n        sender: account?.address,\n      })\n    }\n  }\n}\n"],"mappings":";;;AAGA,SAEEA,YAAY,QACP,sCAAsC;AAG7C,SACEC,oBAAoB,QAEf,yBAAyB;AAgBhC,SAGEC,kBAAkB,QACb,uCAAuC;AAC9C,SAEEC,gBAAgB,QACX,wCAAwC;AAE/C,SAASC,SAAS,QAAQ,0BAA0B;AAEpD,SAGEC,eAAe,QACV,sBAAsB;AA0D7B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkDA,OAAO,eAAeC,aAAaA,CAYjCC,MAAyC,EACzCC,UAOC;EAED,OAAOF,aAAa,CAACG,QAAQ,CAC3BF,MAAM,EACNF,eAAe,EACf,iBAAiB,EACjBG,UAAU,CACF;AACZ;AAEA,WAAiBF,aAAa;EACrB,eAAeG,QAAQA,CAY5BF,MAAyC,EACzCG,QAA6D,EAC7DC,IAA+C,EAC/CH,UAOC;IAED,MAAM;QACJI,GAAG;QACHC,OAAO,EAAEC,QAAQ,GAAGP,MAAM,CAACM,OAAO;QAClCE,OAAO;QACPC,IAAI;QACJC,UAAU;QACVC;MACU,CACX,GAAGV,UAAqC;MADpCW,OAAO,GAAAC,wBAAA,CACRZ,UAAqC,EAAAa,SAAA;IAEzC,IAAI,OAAOP,QAAQ,KAAK,WAAW,EACjC,MAAM,IAAIb,oBAAoB,CAAC;MAC7BqB,QAAQ,EAAE;KACX,CAAC;IACJ,MAAMT,OAAO,GAAGC,QAAQ,GAAGd,YAAY,CAACc,QAAQ,CAAC,GAAG,IAAI;IAExD,MAAMS,IAAI,GAAGrB,kBAAkB,CAAC;MAC9BU,GAAG;MACHI,IAAI;MACJE;KAC+B,CAAC;IAElC,IAAI;MACF,OAAO,MAAMd,SAAS,CACpBG,MAAM,EACNG,QAAiB,EACjBC,IAAI,CACL,CAAAa,aAAA;QACCD,IAAI,KAAAE,MAAA,CAAKF,IAAI,EAAAE,MAAA,CAAGR,UAAU,GAAGA,UAAU,CAACS,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC,GAAG,EAAE,CAAE;QAChEC,EAAE,EAAEZ,OAAO;QACXF;MAAO,GACJM,OAAO,CACX,CAAC;IACJ,CAAC,CAAC,OAAOS,KAAK,EAAE;MACd,MAAMzB,gBAAgB,CAACyB,KAAkB,EAAE;QACzChB,GAAG;QACHG,OAAO;QACPC,IAAI;QACJM,QAAQ,EAAE,8BAA8B;QACxCJ,YAAY;QACZW,MAAM,EAAEhB,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEE;OAClB,CAAC;IACJ;EACF;EAnEsBT,aAAA,CAAAG,QAAQ,GAAAA,QAmE7B;AACH,CAAC,EArEgBH,aAAa,KAAbA,aAAa","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}