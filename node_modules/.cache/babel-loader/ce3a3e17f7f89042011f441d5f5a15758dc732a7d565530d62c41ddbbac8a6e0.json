{"ast":null,"code":"import { RpcRequestError } from '../../errors/request.js';\nimport { UrlRequiredError } from '../../errors/transport.js';\nimport { getSocket } from '../../utils/rpc/compat.js';\nimport { getWebSocketRpcClient } from '../../utils/rpc/webSocket.js';\nimport { createTransport } from './createTransport.js';\n/**\n * @description Creates a WebSocket transport that connects to a JSON-RPC API.\n */\nexport function webSocket(/** URL of the JSON-RPC API. Defaults to the chain's public RPC URL. */\nurl) {\n  let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    keepAlive,\n    key = 'webSocket',\n    methods,\n    name = 'WebSocket JSON-RPC',\n    reconnect,\n    retryDelay\n  } = config;\n  return _ref => {\n    var _config$retryCount, _ref2, _chain$rpcUrls$defaul;\n    let {\n      chain,\n      retryCount: retryCount_,\n      timeout: timeout_\n    } = _ref;\n    const retryCount = (_config$retryCount = config.retryCount) !== null && _config$retryCount !== void 0 ? _config$retryCount : retryCount_;\n    const timeout = (_ref2 = timeout_ !== null && timeout_ !== void 0 ? timeout_ : config.timeout) !== null && _ref2 !== void 0 ? _ref2 : 10000;\n    const url_ = url || (chain === null || chain === void 0 || (_chain$rpcUrls$defaul = chain.rpcUrls.default.webSocket) === null || _chain$rpcUrls$defaul === void 0 ? void 0 : _chain$rpcUrls$defaul[0]);\n    const wsRpcClientOpts = {\n      keepAlive,\n      reconnect\n    };\n    if (!url_) throw new UrlRequiredError();\n    return createTransport({\n      key,\n      methods,\n      name,\n      async request(_ref3) {\n        let {\n          method,\n          params\n        } = _ref3;\n        const body = {\n          method,\n          params\n        };\n        const rpcClient = await getWebSocketRpcClient(url_, wsRpcClientOpts);\n        const {\n          error,\n          result\n        } = await rpcClient.requestAsync({\n          body,\n          timeout\n        });\n        if (error) throw new RpcRequestError({\n          body,\n          error,\n          url: url_\n        });\n        return result;\n      },\n      retryCount,\n      retryDelay,\n      timeout,\n      type: 'webSocket'\n    }, {\n      getSocket() {\n        return getSocket(url_);\n      },\n      getRpcClient() {\n        return getWebSocketRpcClient(url_, wsRpcClientOpts);\n      },\n      async subscribe(_ref4) {\n        let {\n          params,\n          onData,\n          onError\n        } = _ref4;\n        const rpcClient = await getWebSocketRpcClient(url_, wsRpcClientOpts);\n        const {\n          result: subscriptionId\n        } = await new Promise((resolve, reject) => rpcClient.request({\n          body: {\n            method: 'eth_subscribe',\n            params\n          },\n          onError(error) {\n            reject(error);\n            onError === null || onError === void 0 || onError(error);\n            return;\n          },\n          onResponse(response) {\n            if (response.error) {\n              reject(response.error);\n              onError === null || onError === void 0 || onError(response.error);\n              return;\n            }\n            if (typeof response.id === 'number') {\n              resolve(response);\n              return;\n            }\n            if (response.method !== 'eth_subscription') return;\n            onData(response.params);\n          }\n        }));\n        return {\n          subscriptionId,\n          async unsubscribe() {\n            return new Promise(resolve => rpcClient.request({\n              body: {\n                method: 'eth_unsubscribe',\n                params: [subscriptionId]\n              },\n              onResponse: resolve\n            }));\n          }\n        };\n      }\n    });\n  };\n}","map":{"version":3,"names":["RpcRequestError","UrlRequiredError","getSocket","getWebSocketRpcClient","createTransport","webSocket","url","config","arguments","length","undefined","keepAlive","key","methods","name","reconnect","retryDelay","_ref","_config$retryCount","_ref2","_chain$rpcUrls$defaul","chain","retryCount","retryCount_","timeout","timeout_","url_","rpcUrls","default","wsRpcClientOpts","request","_ref3","method","params","body","rpcClient","error","result","requestAsync","type","getRpcClient","subscribe","_ref4","onData","onError","subscriptionId","Promise","resolve","reject","onResponse","response","id","unsubscribe"],"sources":["/Users/mac/Desktop/topl1/frontend/node_modules/viem/clients/transports/webSocket.ts"],"sourcesContent":["import type { Address } from 'abitype'\nimport { RpcRequestError } from '../../errors/request.js'\nimport {\n  UrlRequiredError,\n  type UrlRequiredErrorType,\n} from '../../errors/transport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hash, LogTopic } from '../../types/misc.js'\nimport type { RpcResponse } from '../../types/rpc.js'\nimport { getSocket } from '../../utils/rpc/compat.js'\nimport type { SocketRpcClient } from '../../utils/rpc/socket.js'\nimport {\n  type GetWebSocketRpcClientOptions,\n  getWebSocketRpcClient,\n} from '../../utils/rpc/webSocket.js'\nimport {\n  type CreateTransportErrorType,\n  createTransport,\n  type Transport,\n  type TransportConfig,\n} from './createTransport.js'\n\ntype WebSocketTransportSubscribeParameters = {\n  onData: (data: RpcResponse) => void\n  onError?: ((error: any) => void) | undefined\n}\n\ntype WebSocketTransportSubscribeReturnType = {\n  subscriptionId: Hash\n  unsubscribe: () => Promise<RpcResponse<boolean>>\n}\n\ntype WebSocketTransportSubscribe = {\n  subscribe(\n    args: WebSocketTransportSubscribeParameters &\n      (\n        | {\n            params: ['newHeads']\n          }\n        | {\n            params: ['newPendingTransactions']\n          }\n        | {\n            params: [\n              'logs',\n              {\n                address?: Address | Address[]\n                topics?: LogTopic[]\n              },\n            ]\n          }\n        | {\n            params: ['syncing']\n          }\n      ),\n  ): Promise<WebSocketTransportSubscribeReturnType>\n}\n\nexport type WebSocketTransportConfig = {\n  /**\n   * Whether or not to send keep-alive ping messages.\n   * @default true\n   */\n  keepAlive?: GetWebSocketRpcClientOptions['keepAlive'] | undefined\n  /** The key of the WebSocket transport. */\n  key?: TransportConfig['key'] | undefined\n  /** Methods to include or exclude from executing RPC requests. */\n  methods?: TransportConfig['methods'] | undefined\n  /** The name of the WebSocket transport. */\n  name?: TransportConfig['name'] | undefined\n  /**\n   * Whether or not to attempt to reconnect on socket failure.\n   * @default true\n   */\n  reconnect?: GetWebSocketRpcClientOptions['reconnect'] | undefined\n  /** The max number of times to retry. */\n  retryCount?: TransportConfig['retryCount'] | undefined\n  /** The base delay (in ms) between retries. */\n  retryDelay?: TransportConfig['retryDelay'] | undefined\n  /** The timeout (in ms) for async WebSocket requests. Default: 10_000 */\n  timeout?: TransportConfig['timeout'] | undefined\n}\n\nexport type WebSocketTransport = Transport<\n  'webSocket',\n  {\n    /**\n     * @deprecated use `getRpcClient` instead.\n     */\n    getSocket(): Promise<WebSocket>\n    getRpcClient(): Promise<SocketRpcClient<WebSocket>>\n    subscribe: WebSocketTransportSubscribe['subscribe']\n  }\n>\n\nexport type WebSocketTransportErrorType =\n  | CreateTransportErrorType\n  | UrlRequiredErrorType\n  | ErrorType\n\n/**\n * @description Creates a WebSocket transport that connects to a JSON-RPC API.\n */\nexport function webSocket(\n  /** URL of the JSON-RPC API. Defaults to the chain's public RPC URL. */\n  url?: string,\n  config: WebSocketTransportConfig = {},\n): WebSocketTransport {\n  const {\n    keepAlive,\n    key = 'webSocket',\n    methods,\n    name = 'WebSocket JSON-RPC',\n    reconnect,\n    retryDelay,\n  } = config\n  return ({ chain, retryCount: retryCount_, timeout: timeout_ }) => {\n    const retryCount = config.retryCount ?? retryCount_\n    const timeout = timeout_ ?? config.timeout ?? 10_000\n    const url_ = url || chain?.rpcUrls.default.webSocket?.[0]\n    const wsRpcClientOpts = { keepAlive, reconnect }\n    if (!url_) throw new UrlRequiredError()\n    return createTransport(\n      {\n        key,\n        methods,\n        name,\n        async request({ method, params }) {\n          const body = { method, params }\n          const rpcClient = await getWebSocketRpcClient(url_, wsRpcClientOpts)\n          const { error, result } = await rpcClient.requestAsync({\n            body,\n            timeout,\n          })\n          if (error)\n            throw new RpcRequestError({\n              body,\n              error,\n              url: url_,\n            })\n          return result\n        },\n        retryCount,\n        retryDelay,\n        timeout,\n        type: 'webSocket',\n      },\n      {\n        getSocket() {\n          return getSocket(url_)\n        },\n        getRpcClient() {\n          return getWebSocketRpcClient(url_, wsRpcClientOpts)\n        },\n        async subscribe({ params, onData, onError }: any) {\n          const rpcClient = await getWebSocketRpcClient(url_, wsRpcClientOpts)\n          const { result: subscriptionId } = await new Promise<any>(\n            (resolve, reject) =>\n              rpcClient.request({\n                body: {\n                  method: 'eth_subscribe',\n                  params,\n                },\n                onError(error) {\n                  reject(error)\n                  onError?.(error)\n                  return\n                },\n                onResponse(response) {\n                  if (response.error) {\n                    reject(response.error)\n                    onError?.(response.error)\n                    return\n                  }\n\n                  if (typeof response.id === 'number') {\n                    resolve(response)\n                    return\n                  }\n                  if (response.method !== 'eth_subscription') return\n                  onData(response.params)\n                },\n              }),\n          )\n          return {\n            subscriptionId,\n            async unsubscribe() {\n              return new Promise<any>((resolve) =>\n                rpcClient.request({\n                  body: {\n                    method: 'eth_unsubscribe',\n                    params: [subscriptionId],\n                  },\n                  onResponse: resolve,\n                }),\n              )\n            },\n          }\n        },\n      },\n    )\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}