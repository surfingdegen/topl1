{"ast":null,"code":"import _objectSpread from \"/Users/mac/Desktop/topl1/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\n// Implementation forked and adapted from https://github.com/MetaMask/eth-sig-util/blob/main/src/sign-typed-data.ts\nimport { encodeAbiParameters } from '../abi/encodeAbiParameters.js';\nimport { concat } from '../data/concat.js';\nimport { toHex } from '../encoding/toHex.js';\nimport { keccak256 } from '../hash/keccak256.js';\nimport { getTypesForEIP712Domain, validateTypedData } from '../typedData.js';\nexport function hashTypedData(parameters) {\n  const {\n    domain = {},\n    message,\n    primaryType\n  } = parameters;\n  const types = _objectSpread({\n    EIP712Domain: getTypesForEIP712Domain({\n      domain\n    })\n  }, parameters.types);\n  // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n  // as we can't statically check this with TypeScript.\n  validateTypedData({\n    domain,\n    message,\n    primaryType,\n    types\n  });\n  const parts = ['0x1901'];\n  if (domain) parts.push(hashDomain({\n    domain,\n    types: types\n  }));\n  if (primaryType !== 'EIP712Domain') parts.push(hashStruct({\n    data: message,\n    primaryType,\n    types: types\n  }));\n  return keccak256(concat(parts));\n}\nexport function hashDomain(_ref) {\n  let {\n    domain,\n    types\n  } = _ref;\n  return hashStruct({\n    data: domain,\n    primaryType: 'EIP712Domain',\n    types: types\n  });\n}\nexport function hashStruct(_ref2) {\n  let {\n    data,\n    primaryType,\n    types\n  } = _ref2;\n  const encoded = encodeData({\n    data: data,\n    primaryType,\n    types: types\n  });\n  return keccak256(encoded);\n}\nfunction encodeData(_ref3) {\n  let {\n    data,\n    primaryType,\n    types\n  } = _ref3;\n  const encodedTypes = [{\n    type: 'bytes32'\n  }];\n  const encodedValues = [hashType({\n    primaryType,\n    types\n  })];\n  for (const field of types[primaryType]) {\n    const [type, value] = encodeField({\n      types,\n      name: field.name,\n      type: field.type,\n      value: data[field.name]\n    });\n    encodedTypes.push(type);\n    encodedValues.push(value);\n  }\n  return encodeAbiParameters(encodedTypes, encodedValues);\n}\nfunction hashType(_ref4) {\n  let {\n    primaryType,\n    types\n  } = _ref4;\n  const encodedHashType = toHex(encodeType({\n    primaryType,\n    types\n  }));\n  return keccak256(encodedHashType);\n}\nexport function encodeType(_ref5) {\n  let {\n    primaryType,\n    types\n  } = _ref5;\n  let result = '';\n  const unsortedDeps = findTypeDependencies({\n    primaryType,\n    types\n  });\n  unsortedDeps.delete(primaryType);\n  const deps = [primaryType, ...Array.from(unsortedDeps).sort()];\n  for (const type of deps) {\n    result += \"\".concat(type, \"(\").concat(types[type].map(_ref6 => {\n      let {\n        name,\n        type: t\n      } = _ref6;\n      return \"\".concat(t, \" \").concat(name);\n    }).join(','), \")\");\n  }\n  return result;\n}\nfunction findTypeDependencies(_ref7) {\n  let {\n    primaryType: primaryType_,\n    types\n  } = _ref7;\n  let results = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();\n  const match = primaryType_.match(/^[0-9A-Z_a-z]*/);\n  const primaryType = match === null || match === void 0 ? void 0 : match[0];\n  if (results.has(primaryType) || types[primaryType] === undefined) {\n    return results;\n  }\n  results.add(primaryType);\n  for (const field of types[primaryType]) {\n    findTypeDependencies({\n      primaryType: field.type,\n      types\n    }, results);\n  }\n  return results;\n}\nfunction encodeField(_ref8) {\n  let {\n    types,\n    name,\n    type,\n    value\n  } = _ref8;\n  if (types[type] !== undefined) {\n    return [{\n      type: 'bytes32'\n    }, keccak256(encodeData({\n      data: value,\n      primaryType: type,\n      types\n    }))];\n  }\n  if (type === 'bytes') return [{\n    type: 'bytes32'\n  }, keccak256(value)];\n  if (type === 'string') return [{\n    type: 'bytes32'\n  }, keccak256(toHex(value))];\n  if (type.lastIndexOf(']') === type.length - 1) {\n    const parsedType = type.slice(0, type.lastIndexOf('['));\n    const typeValuePairs = value.map(item => encodeField({\n      name,\n      type: parsedType,\n      types,\n      value: item\n    }));\n    return [{\n      type: 'bytes32'\n    }, keccak256(encodeAbiParameters(typeValuePairs.map(_ref9 => {\n      let [t] = _ref9;\n      return t;\n    }), typeValuePairs.map(_ref0 => {\n      let [, v] = _ref0;\n      return v;\n    })))];\n  }\n  return [{\n    type\n  }, value];\n}","map":{"version":3,"names":["encodeAbiParameters","concat","toHex","keccak256","getTypesForEIP712Domain","validateTypedData","hashTypedData","parameters","domain","message","primaryType","types","_objectSpread","EIP712Domain","parts","push","hashDomain","hashStruct","data","_ref","_ref2","encoded","encodeData","_ref3","encodedTypes","type","encodedValues","hashType","field","value","encodeField","name","_ref4","encodedHashType","encodeType","_ref5","result","unsortedDeps","findTypeDependencies","delete","deps","Array","from","sort","map","_ref6","t","join","_ref7","primaryType_","results","arguments","length","undefined","Set","match","has","add","_ref8","lastIndexOf","parsedType","slice","typeValuePairs","item","_ref9","_ref0","v"],"sources":["/Users/mac/Desktop/topl1/frontend/node_modules/viem/utils/signature/hashTypedData.ts"],"sourcesContent":["// Implementation forked and adapted from https://github.com/MetaMask/eth-sig-util/blob/main/src/sign-typed-data.ts\n\nimport type { AbiParameter, TypedData } from 'abitype'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport type {\n  EIP712DomainDefinition,\n  MessageDefinition,\n  TypedDataDefinition,\n} from '../../types/typedData.js'\nimport type { UnionOmit } from '../../types/utils.js'\nimport {\n  type EncodeAbiParametersErrorType,\n  encodeAbiParameters,\n} from '../abi/encodeAbiParameters.js'\nimport { concat } from '../data/concat.js'\nimport { type ToHexErrorType, toHex } from '../encoding/toHex.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\nimport {\n  type GetTypesForEIP712DomainErrorType,\n  getTypesForEIP712Domain,\n  type ValidateTypedDataErrorType,\n  validateTypedData,\n} from '../typedData.js'\n\ntype MessageTypeProperty = {\n  name: string\n  type: string\n}\n\nexport type HashTypedDataParameters<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n> = TypedDataDefinition<typedData, primaryType>\n\nexport type HashTypedDataReturnType = Hex\n\nexport type HashTypedDataErrorType =\n  | GetTypesForEIP712DomainErrorType\n  | HashDomainErrorType\n  | HashStructErrorType\n  | ValidateTypedDataErrorType\n  | ErrorType\n\nexport function hashTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(\n  parameters: HashTypedDataParameters<typedData, primaryType>,\n): HashTypedDataReturnType {\n  const {\n    domain = {},\n    message,\n    primaryType,\n  } = parameters as HashTypedDataParameters\n  const types = {\n    EIP712Domain: getTypesForEIP712Domain({ domain }),\n    ...parameters.types,\n  }\n\n  // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n  // as we can't statically check this with TypeScript.\n  validateTypedData({\n    domain,\n    message,\n    primaryType,\n    types,\n  })\n\n  const parts: Hex[] = ['0x1901']\n  if (domain)\n    parts.push(\n      hashDomain({\n        domain,\n        types: types as Record<string, MessageTypeProperty[]>,\n      }),\n    )\n\n  if (primaryType !== 'EIP712Domain')\n    parts.push(\n      hashStruct({\n        data: message,\n        primaryType,\n        types: types as Record<string, MessageTypeProperty[]>,\n      }),\n    )\n\n  return keccak256(concat(parts))\n}\n\nexport type HashDomainErrorType = HashStructErrorType | ErrorType\n\nexport function hashDomain<\n  const typedData extends TypedData | Record<string, unknown> = TypedData,\n>({\n  domain,\n  types,\n}: UnionOmit<EIP712DomainDefinition<typedData>, 'primaryType'>) {\n  return hashStruct({\n    data: domain as Record<string, unknown>,\n    primaryType: 'EIP712Domain',\n    types: types as Record<string, readonly MessageTypeProperty[]>,\n  })\n}\n\nexport type HashStructErrorType =\n  | EncodeDataErrorType\n  | Keccak256ErrorType\n  | ErrorType\n\nexport function hashStruct<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>({\n  data,\n  primaryType,\n  types,\n}: MessageDefinition<typedData, primaryType, 'data'>) {\n  const encoded = encodeData({\n    data: data as Record<string, unknown>,\n    primaryType,\n    types: types as Record<string, readonly MessageTypeProperty[]>,\n  })\n  return keccak256(encoded)\n}\n\ntype EncodeDataErrorType =\n  | EncodeAbiParametersErrorType\n  | EncodeFieldErrorType\n  | HashTypeErrorType\n  | ErrorType\n\nfunction encodeData({\n  data,\n  primaryType,\n  types,\n}: {\n  data: Record<string, unknown>\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  const encodedTypes: AbiParameter[] = [{ type: 'bytes32' }]\n  const encodedValues: unknown[] = [hashType({ primaryType, types })]\n\n  for (const field of types[primaryType]) {\n    const [type, value] = encodeField({\n      types,\n      name: field.name,\n      type: field.type,\n      value: data[field.name],\n    })\n    encodedTypes.push(type)\n    encodedValues.push(value)\n  }\n\n  return encodeAbiParameters(encodedTypes, encodedValues)\n}\n\ntype HashTypeErrorType =\n  | ToHexErrorType\n  | EncodeTypeErrorType\n  | Keccak256ErrorType\n  | ErrorType\n\nfunction hashType({\n  primaryType,\n  types,\n}: {\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  const encodedHashType = toHex(encodeType({ primaryType, types }))\n  return keccak256(encodedHashType)\n}\n\ntype EncodeTypeErrorType = FindTypeDependenciesErrorType\n\nexport function encodeType({\n  primaryType,\n  types,\n}: {\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  let result = ''\n  const unsortedDeps = findTypeDependencies({ primaryType, types })\n  unsortedDeps.delete(primaryType)\n\n  const deps = [primaryType, ...Array.from(unsortedDeps).sort()]\n  for (const type of deps) {\n    result += `${type}(${types[type]\n      .map(({ name, type: t }) => `${t} ${name}`)\n      .join(',')})`\n  }\n\n  return result\n}\n\ntype FindTypeDependenciesErrorType = ErrorType\n\nfunction findTypeDependencies(\n  {\n    primaryType: primaryType_,\n    types,\n  }: {\n    primaryType: string\n    types: Record<string, readonly MessageTypeProperty[]>\n  },\n  results: Set<string> = new Set(),\n): Set<string> {\n  const match = primaryType_.match(/^\\w*/u)\n  const primaryType = match?.[0]!\n  if (results.has(primaryType) || types[primaryType] === undefined) {\n    return results\n  }\n\n  results.add(primaryType)\n\n  for (const field of types[primaryType]) {\n    findTypeDependencies({ primaryType: field.type, types }, results)\n  }\n  return results\n}\n\ntype EncodeFieldErrorType =\n  | Keccak256ErrorType\n  | EncodeAbiParametersErrorType\n  | ToHexErrorType\n  | ErrorType\n\nfunction encodeField({\n  types,\n  name,\n  type,\n  value,\n}: {\n  types: Record<string, readonly MessageTypeProperty[]>\n  name: string\n  type: string\n  value: any\n}): [type: AbiParameter, value: any] {\n  if (types[type] !== undefined) {\n    return [\n      { type: 'bytes32' },\n      keccak256(encodeData({ data: value, primaryType: type, types })),\n    ]\n  }\n\n  if (type === 'bytes') return [{ type: 'bytes32' }, keccak256(value)]\n\n  if (type === 'string') return [{ type: 'bytes32' }, keccak256(toHex(value))]\n\n  if (type.lastIndexOf(']') === type.length - 1) {\n    const parsedType = type.slice(0, type.lastIndexOf('['))\n    const typeValuePairs = (value as [AbiParameter, any][]).map((item) =>\n      encodeField({\n        name,\n        type: parsedType,\n        types,\n        value: item,\n      }),\n    )\n    return [\n      { type: 'bytes32' },\n      keccak256(\n        encodeAbiParameters(\n          typeValuePairs.map(([t]) => t),\n          typeValuePairs.map(([, v]) => v),\n        ),\n      ),\n    ]\n  }\n\n  return [{ type }, value]\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}