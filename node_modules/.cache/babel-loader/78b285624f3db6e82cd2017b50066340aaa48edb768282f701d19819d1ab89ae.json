{"ast":null,"code":"import _objectSpread from \"/Users/mac/Desktop/topl1/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/Users/mac/Desktop/topl1/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"chain\", \"pollingInterval\", \"timeout\"];\nimport { ExecutionRevertedError } from '../../errors/node.js';\nimport { TransactionRejectedRpcError, UserRejectedRequestError } from '../../errors/rpc.js';\nimport { wait } from '../../utils/wait.js';\nimport { createTransport } from './createTransport.js';\nexport function fallback(transports_) {\n  let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    key = 'fallback',\n    name = 'Fallback',\n    rank = false,\n    shouldThrow: shouldThrow_ = shouldThrow,\n    retryCount,\n    retryDelay\n  } = config;\n  return _ref => {\n    let {\n        chain,\n        pollingInterval = 4000,\n        timeout\n      } = _ref,\n      rest = _objectWithoutProperties(_ref, _excluded);\n    let transports = transports_;\n    let onResponse = () => {};\n    const transport = createTransport({\n      key,\n      name,\n      async request(_ref2) {\n        let {\n          method,\n          params\n        } = _ref2;\n        let includes;\n        const fetch = async function () {\n          let i = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n          const transport = transports[i](_objectSpread(_objectSpread({}, rest), {}, {\n            chain,\n            retryCount: 0,\n            timeout\n          }));\n          try {\n            const response = await transport.request({\n              method,\n              params\n            });\n            onResponse({\n              method,\n              params: params,\n              response,\n              transport,\n              status: 'success'\n            });\n            return response;\n          } catch (err) {\n            onResponse({\n              error: err,\n              method,\n              params: params,\n              transport,\n              status: 'error'\n            });\n            if (shouldThrow_(err)) throw err;\n            // If we've reached the end of the fallbacks, throw the error.\n            if (i === transports.length - 1) throw err;\n            // Check if at least one other transport includes the method\n            includes !== null && includes !== void 0 ? includes : includes = transports.slice(i + 1).some(transport => {\n              const {\n                include,\n                exclude\n              } = transport({\n                chain\n              }).config.methods || {};\n              if (include) return include.includes(method);\n              if (exclude) return !exclude.includes(method);\n              return true;\n            });\n            if (!includes) throw err;\n            // Otherwise, try the next fallback.\n            return fetch(i + 1);\n          }\n        };\n        return fetch();\n      },\n      retryCount,\n      retryDelay,\n      type: 'fallback'\n    }, {\n      onResponse: fn => onResponse = fn,\n      transports: transports.map(fn => fn({\n        chain,\n        retryCount: 0\n      }))\n    });\n    if (rank) {\n      var _rankOptions$interval;\n      const rankOptions = typeof rank === 'object' ? rank : {};\n      rankTransports({\n        chain,\n        interval: (_rankOptions$interval = rankOptions.interval) !== null && _rankOptions$interval !== void 0 ? _rankOptions$interval : pollingInterval,\n        onTransports: transports_ => transports = transports_,\n        ping: rankOptions.ping,\n        sampleCount: rankOptions.sampleCount,\n        timeout: rankOptions.timeout,\n        transports,\n        weights: rankOptions.weights\n      });\n    }\n    return transport;\n  };\n}\nexport function shouldThrow(error) {\n  if ('code' in error && typeof error.code === 'number') {\n    if (error.code === TransactionRejectedRpcError.code || error.code === UserRejectedRequestError.code || ExecutionRevertedError.nodeMessage.test(error.message) || error.code === 5000 // CAIP UserRejectedRequestError\n    ) return true;\n  }\n  return false;\n}\n/** @internal */\nexport function rankTransports(_ref3) {\n  let {\n    chain,\n    interval = 4000,\n    onTransports,\n    ping,\n    sampleCount = 10,\n    timeout = 1000,\n    transports,\n    weights = {}\n  } = _ref3;\n  const {\n    stability: stabilityWeight = 0.7,\n    latency: latencyWeight = 0.3\n  } = weights;\n  const samples = [];\n  const rankTransports_ = async () => {\n    // 1. Take a sample from each Transport.\n    const sample = await Promise.all(transports.map(async transport => {\n      const transport_ = transport({\n        chain,\n        retryCount: 0,\n        timeout\n      });\n      const start = Date.now();\n      let end;\n      let success;\n      try {\n        await (ping ? ping({\n          transport: transport_\n        }) : transport_.request({\n          method: 'net_listening'\n        }));\n        success = 1;\n      } catch (_unused) {\n        success = 0;\n      } finally {\n        end = Date.now();\n      }\n      const latency = end - start;\n      return {\n        latency,\n        success\n      };\n    }));\n    // 2. Store the sample. If we have more than `sampleCount` samples, remove\n    // the oldest sample.\n    samples.push(sample);\n    if (samples.length > sampleCount) samples.shift();\n    // 3. Calculate the max latency from samples.\n    const maxLatency = Math.max(...samples.map(sample => Math.max(...sample.map(_ref4 => {\n      let {\n        latency\n      } = _ref4;\n      return latency;\n    }))));\n    // 4. Calculate the score for each Transport.\n    const scores = transports.map((_, i) => {\n      const latencies = samples.map(sample => sample[i].latency);\n      const meanLatency = latencies.reduce((acc, latency) => acc + latency, 0) / latencies.length;\n      const latencyScore = 1 - meanLatency / maxLatency;\n      const successes = samples.map(sample => sample[i].success);\n      const stabilityScore = successes.reduce((acc, success) => acc + success, 0) / successes.length;\n      if (stabilityScore === 0) return [0, i];\n      return [latencyWeight * latencyScore + stabilityWeight * stabilityScore, i];\n    }).sort((a, b) => b[0] - a[0]);\n    // 5. Sort the Transports by score.\n    onTransports(scores.map(_ref5 => {\n      let [, i] = _ref5;\n      return transports[i];\n    }));\n    // 6. Wait, and then rank again.\n    await wait(interval);\n    rankTransports_();\n  };\n  rankTransports_();\n}","map":{"version":3,"names":["ExecutionRevertedError","TransactionRejectedRpcError","UserRejectedRequestError","wait","createTransport","fallback","transports_","config","arguments","length","undefined","key","name","rank","shouldThrow","shouldThrow_","retryCount","retryDelay","_ref","chain","pollingInterval","timeout","rest","_objectWithoutProperties","_excluded","transports","onResponse","transport","request","_ref2","method","params","includes","fetch","i","_objectSpread","response","status","err","error","slice","some","include","exclude","methods","type","fn","map","_rankOptions$interval","rankOptions","rankTransports","interval","onTransports","ping","sampleCount","weights","code","nodeMessage","test","message","_ref3","stability","stabilityWeight","latency","latencyWeight","samples","rankTransports_","sample","Promise","all","transport_","start","Date","now","end","success","_unused","push","shift","maxLatency","Math","max","_ref4","scores","_","latencies","meanLatency","reduce","acc","latencyScore","successes","stabilityScore","sort","a","b","_ref5"],"sources":["/Users/mac/Desktop/topl1/frontend/node_modules/viem/clients/transports/fallback.ts"],"sourcesContent":["import { ExecutionRevertedError } from '../../errors/node.js'\nimport {\n  TransactionRejectedRpcError,\n  UserRejectedRequestError,\n} from '../../errors/rpc.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport { wait } from '../../utils/wait.js'\n\nimport {\n  type CreateTransportErrorType,\n  createTransport,\n  type Transport,\n  type TransportConfig,\n} from './createTransport.js'\n// TODO: Narrow `method` & `params` types.\nexport type OnResponseFn = (\n  args: {\n    method: string\n    params: unknown[]\n    transport: ReturnType<Transport>\n  } & (\n    | {\n        error?: undefined\n        response: unknown\n        status: 'success'\n      }\n    | {\n        error: Error\n        response?: undefined\n        status: 'error'\n      }\n  ),\n) => void\n\ntype RankOptions = {\n  /**\n   * The polling interval (in ms) at which the ranker should ping the RPC URL.\n   * @default client.pollingInterval\n   */\n  interval?: number | undefined\n  /**\n   * Ping method to determine latency.\n   */\n  ping?: (parameters: {\n    transport: ReturnType<Transport>\n  }) => Promise<unknown> | undefined\n  /**\n   * The number of previous samples to perform ranking on.\n   * @default 10\n   */\n  sampleCount?: number | undefined\n  /**\n   * Timeout when sampling transports.\n   * @default 1_000\n   */\n  timeout?: number | undefined\n  /**\n   * Weights to apply to the scores. Weight values are proportional.\n   */\n  weights?:\n    | {\n        /**\n         * The weight to apply to the latency score.\n         * @default 0.3\n         */\n        latency?: number | undefined\n        /**\n         * The weight to apply to the stability score.\n         * @default 0.7\n         */\n        stability?: number | undefined\n      }\n    | undefined\n}\n\nexport type FallbackTransportConfig = {\n  /** The key of the Fallback transport. */\n  key?: TransportConfig['key'] | undefined\n  /** The name of the Fallback transport. */\n  name?: TransportConfig['name'] | undefined\n  /** Toggle to enable ranking, or rank options. */\n  rank?: boolean | RankOptions | undefined\n  /** The max number of times to retry. */\n  retryCount?: TransportConfig['retryCount'] | undefined\n  /** The base delay (in ms) between retries. */\n  retryDelay?: TransportConfig['retryDelay'] | undefined\n  /** Callback on whether an error should throw or try the next transport in the fallback. */\n  shouldThrow?: (error: Error) => boolean | undefined\n}\n\nexport type FallbackTransport<\n  transports extends readonly Transport[] = readonly Transport[],\n> = Transport<\n  'fallback',\n  {\n    onResponse: (fn: OnResponseFn) => void\n    transports: {\n      [key in keyof transports]: ReturnType<transports[key]>\n    }\n  }\n>\n\nexport type FallbackTransportErrorType = CreateTransportErrorType | ErrorType\n\nexport function fallback<const transports extends readonly Transport[]>(\n  transports_: transports,\n  config: FallbackTransportConfig = {},\n): FallbackTransport<transports> {\n  const {\n    key = 'fallback',\n    name = 'Fallback',\n    rank = false,\n    shouldThrow: shouldThrow_ = shouldThrow,\n    retryCount,\n    retryDelay,\n  } = config\n  return (({ chain, pollingInterval = 4_000, timeout, ...rest }) => {\n    let transports = transports_\n\n    let onResponse: OnResponseFn = () => {}\n\n    const transport = createTransport(\n      {\n        key,\n        name,\n        async request({ method, params }) {\n          let includes: boolean | undefined\n\n          const fetch = async (i = 0): Promise<any> => {\n            const transport = transports[i]({\n              ...rest,\n              chain,\n              retryCount: 0,\n              timeout,\n            })\n            try {\n              const response = await transport.request({\n                method,\n                params,\n              } as any)\n\n              onResponse({\n                method,\n                params: params as unknown[],\n                response,\n                transport,\n                status: 'success',\n              })\n\n              return response\n            } catch (err) {\n              onResponse({\n                error: err as Error,\n                method,\n                params: params as unknown[],\n                transport,\n                status: 'error',\n              })\n\n              if (shouldThrow_(err as Error)) throw err\n\n              // If we've reached the end of the fallbacks, throw the error.\n              if (i === transports.length - 1) throw err\n\n              // Check if at least one other transport includes the method\n              includes ??= transports.slice(i + 1).some((transport) => {\n                const { include, exclude } =\n                  transport({ chain }).config.methods || {}\n                if (include) return include.includes(method)\n                if (exclude) return !exclude.includes(method)\n                return true\n              })\n              if (!includes) throw err\n\n              // Otherwise, try the next fallback.\n              return fetch(i + 1)\n            }\n          }\n          return fetch()\n        },\n        retryCount,\n        retryDelay,\n        type: 'fallback',\n      },\n      {\n        onResponse: (fn: OnResponseFn) => (onResponse = fn),\n        transports: transports.map((fn) => fn({ chain, retryCount: 0 })),\n      },\n    )\n\n    if (rank) {\n      const rankOptions = (typeof rank === 'object' ? rank : {}) as RankOptions\n      rankTransports({\n        chain,\n        interval: rankOptions.interval ?? pollingInterval,\n        onTransports: (transports_) => (transports = transports_ as transports),\n        ping: rankOptions.ping,\n        sampleCount: rankOptions.sampleCount,\n        timeout: rankOptions.timeout,\n        transports,\n        weights: rankOptions.weights,\n      })\n    }\n    return transport\n  }) as FallbackTransport<transports>\n}\n\nexport function shouldThrow(error: Error) {\n  if ('code' in error && typeof error.code === 'number') {\n    if (\n      error.code === TransactionRejectedRpcError.code ||\n      error.code === UserRejectedRequestError.code ||\n      ExecutionRevertedError.nodeMessage.test(error.message) ||\n      error.code === 5000 // CAIP UserRejectedRequestError\n    )\n      return true\n  }\n  return false\n}\n\n/** @internal */\nexport function rankTransports({\n  chain,\n  interval = 4_000,\n  onTransports,\n  ping,\n  sampleCount = 10,\n  timeout = 1_000,\n  transports,\n  weights = {},\n}: {\n  chain?: Chain | undefined\n  interval: RankOptions['interval']\n  onTransports: (transports: readonly Transport[]) => void\n  ping?: RankOptions['ping'] | undefined\n  sampleCount?: RankOptions['sampleCount'] | undefined\n  timeout?: RankOptions['timeout'] | undefined\n  transports: readonly Transport[]\n  weights?: RankOptions['weights'] | undefined\n}) {\n  const { stability: stabilityWeight = 0.7, latency: latencyWeight = 0.3 } =\n    weights\n\n  type SampleData = { latency: number; success: number }\n  type Sample = SampleData[]\n  const samples: Sample[] = []\n\n  const rankTransports_ = async () => {\n    // 1. Take a sample from each Transport.\n    const sample: Sample = await Promise.all(\n      transports.map(async (transport) => {\n        const transport_ = transport({ chain, retryCount: 0, timeout })\n\n        const start = Date.now()\n        let end: number\n        let success: number\n        try {\n          await (ping\n            ? ping({ transport: transport_ })\n            : transport_.request({ method: 'net_listening' }))\n          success = 1\n        } catch {\n          success = 0\n        } finally {\n          end = Date.now()\n        }\n        const latency = end - start\n        return { latency, success }\n      }),\n    )\n\n    // 2. Store the sample. If we have more than `sampleCount` samples, remove\n    // the oldest sample.\n    samples.push(sample)\n    if (samples.length > sampleCount) samples.shift()\n\n    // 3. Calculate the max latency from samples.\n    const maxLatency = Math.max(\n      ...samples.map((sample) =>\n        Math.max(...sample.map(({ latency }) => latency)),\n      ),\n    )\n\n    // 4. Calculate the score for each Transport.\n    const scores = transports\n      .map((_, i) => {\n        const latencies = samples.map((sample) => sample[i].latency)\n        const meanLatency =\n          latencies.reduce((acc, latency) => acc + latency, 0) /\n          latencies.length\n        const latencyScore = 1 - meanLatency / maxLatency\n\n        const successes = samples.map((sample) => sample[i].success)\n        const stabilityScore =\n          successes.reduce((acc, success) => acc + success, 0) /\n          successes.length\n\n        if (stabilityScore === 0) return [0, i]\n        return [\n          latencyWeight * latencyScore + stabilityWeight * stabilityScore,\n          i,\n        ]\n      })\n      .sort((a, b) => b[0] - a[0])\n\n    // 5. Sort the Transports by score.\n    onTransports(scores.map(([, i]) => transports[i]))\n\n    // 6. Wait, and then rank again.\n    await wait(interval)\n    rankTransports_()\n  }\n  rankTransports_()\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}