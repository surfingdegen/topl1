{"ast":null,"code":"import _objectSpread from \"/Users/mac/Desktop/topl1/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/Users/mac/Desktop/topl1/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"account\", \"authorizationList\", \"batch\", \"blockNumber\", \"blockTag\", \"accessList\", \"blobs\", \"blockOverrides\", \"code\", \"data\", \"factory\", \"factoryData\", \"gas\", \"gasPrice\", \"maxFeePerBlobGas\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"to\", \"value\", \"stateOverride\"],\n  _excluded2 = [\"data\", \"to\"];\nimport { parseAbi } from 'abitype';\nimport * as BlockOverrides from 'ox/BlockOverrides';\nimport { parseAccount } from '../../accounts/utils/parseAccount.js';\nimport { multicall3Abi } from '../../constants/abis.js';\nimport { aggregate3Signature } from '../../constants/contract.js';\nimport { deploylessCallViaBytecodeBytecode, deploylessCallViaFactoryBytecode, multicall3Bytecode } from '../../constants/contracts.js';\nimport { BaseError } from '../../errors/base.js';\nimport { ChainDoesNotSupportContract, ClientChainNotConfiguredError } from '../../errors/chain.js';\nimport { CounterfactualDeploymentFailedError, RawContractError } from '../../errors/contract.js';\nimport { decodeFunctionResult } from '../../utils/abi/decodeFunctionResult.js';\nimport { encodeDeployData } from '../../utils/abi/encodeDeployData.js';\nimport { encodeFunctionData } from '../../utils/abi/encodeFunctionData.js';\nimport { getChainContractAddress } from '../../utils/chain/getChainContractAddress.js';\nimport { numberToHex } from '../../utils/encoding/toHex.js';\nimport { getCallError } from '../../utils/errors/getCallError.js';\nimport { extract } from '../../utils/formatters/extract.js';\nimport { formatTransactionRequest } from '../../utils/formatters/transactionRequest.js';\nimport { createBatchScheduler } from '../../utils/promise/createBatchScheduler.js';\nimport { serializeStateOverride } from '../../utils/stateOverride.js';\nimport { assertRequest } from '../../utils/transaction/assertRequest.js';\n/**\n * Executes a new message call immediately without submitting a transaction to the network.\n *\n * - Docs: https://viem.sh/docs/actions/public/call\n * - JSON-RPC Methods: [`eth_call`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_call)\n *\n * @param client - Client to use\n * @param parameters - {@link CallParameters}\n * @returns The call data. {@link CallReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { call } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const data = await call(client, {\n *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n *   data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * })\n */\nexport async function call(client, args) {\n  var _client$batch, _client$experimental_;\n  const {\n      account: account_ = client.account,\n      authorizationList,\n      batch = Boolean((_client$batch = client.batch) === null || _client$batch === void 0 ? void 0 : _client$batch.multicall),\n      blockNumber,\n      blockTag = (_client$experimental_ = client.experimental_blockTag) !== null && _client$experimental_ !== void 0 ? _client$experimental_ : 'latest',\n      accessList,\n      blobs,\n      blockOverrides,\n      code,\n      data: data_,\n      factory,\n      factoryData,\n      gas,\n      gasPrice,\n      maxFeePerBlobGas,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      to,\n      value,\n      stateOverride\n    } = args,\n    rest = _objectWithoutProperties(args, _excluded);\n  const account = account_ ? parseAccount(account_) : undefined;\n  if (code && (factory || factoryData)) throw new BaseError('Cannot provide both `code` & `factory`/`factoryData` as parameters.');\n  if (code && to) throw new BaseError('Cannot provide both `code` & `to` as parameters.');\n  // Check if the call is deployless via bytecode.\n  const deploylessCallViaBytecode = code && data_;\n  // Check if the call is deployless via a factory.\n  const deploylessCallViaFactory = factory && factoryData && to && data_;\n  const deploylessCall = deploylessCallViaBytecode || deploylessCallViaFactory;\n  const data = (() => {\n    if (deploylessCallViaBytecode) return toDeploylessCallViaBytecodeData({\n      code,\n      data: data_\n    });\n    if (deploylessCallViaFactory) return toDeploylessCallViaFactoryData({\n      data: data_,\n      factory,\n      factoryData,\n      to\n    });\n    return data_;\n  })();\n  try {\n    var _client$chain;\n    assertRequest(args);\n    const blockNumberHex = typeof blockNumber === 'bigint' ? numberToHex(blockNumber) : undefined;\n    const block = blockNumberHex || blockTag;\n    const rpcBlockOverrides = blockOverrides ? BlockOverrides.toRpc(blockOverrides) : undefined;\n    const rpcStateOverride = serializeStateOverride(stateOverride);\n    const chainFormat = (_client$chain = client.chain) === null || _client$chain === void 0 || (_client$chain = _client$chain.formatters) === null || _client$chain === void 0 || (_client$chain = _client$chain.transactionRequest) === null || _client$chain === void 0 ? void 0 : _client$chain.format;\n    const format = chainFormat || formatTransactionRequest;\n    const request = format(_objectSpread(_objectSpread({}, extract(rest, {\n      format: chainFormat\n    })), {}, {\n      accessList,\n      account,\n      authorizationList,\n      blobs,\n      data,\n      gas,\n      gasPrice,\n      maxFeePerBlobGas,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      to: deploylessCall ? undefined : to,\n      value\n    }), 'call');\n    if (batch && shouldPerformMulticall({\n      request\n    }) && !rpcStateOverride && !rpcBlockOverrides) {\n      try {\n        return await scheduleMulticall(client, _objectSpread(_objectSpread({}, request), {}, {\n          blockNumber,\n          blockTag\n        }));\n      } catch (err) {\n        if (!(err instanceof ClientChainNotConfiguredError) && !(err instanceof ChainDoesNotSupportContract)) throw err;\n      }\n    }\n    const params = (() => {\n      const base = [request, block];\n      if (rpcStateOverride && rpcBlockOverrides) return [...base, rpcStateOverride, rpcBlockOverrides];\n      if (rpcStateOverride) return [...base, rpcStateOverride];\n      if (rpcBlockOverrides) return [...base, {}, rpcBlockOverrides];\n      return base;\n    })();\n    const response = await client.request({\n      method: 'eth_call',\n      params\n    });\n    if (response === '0x') return {\n      data: undefined\n    };\n    return {\n      data: response\n    };\n  } catch (err) {\n    const data = getRevertErrorData(err);\n    // Check for CCIP-Read offchain lookup signature.\n    const {\n      offchainLookup,\n      offchainLookupSignature\n    } = await import('../../utils/ccip.js');\n    if (client.ccipRead !== false && (data === null || data === void 0 ? void 0 : data.slice(0, 10)) === offchainLookupSignature && to) return {\n      data: await offchainLookup(client, {\n        data,\n        to\n      })\n    };\n    // Check for counterfactual deployment error.\n    if (deploylessCall && (data === null || data === void 0 ? void 0 : data.slice(0, 10)) === '0x101bb98d') throw new CounterfactualDeploymentFailedError({\n      factory\n    });\n    throw getCallError(err, _objectSpread(_objectSpread({}, args), {}, {\n      account,\n      chain: client.chain\n    }));\n  }\n}\n// We only want to perform a scheduled multicall if:\n// - The request has calldata,\n// - The request has a target address,\n// - The target address is not already the aggregate3 signature,\n// - The request has no other properties (`nonce`, `gas`, etc cannot be sent with a multicall).\nfunction shouldPerformMulticall(_ref) {\n  let {\n    request\n  } = _ref;\n  const {\n      data,\n      to\n    } = request,\n    request_ = _objectWithoutProperties(request, _excluded2);\n  if (!data) return false;\n  if (data.startsWith(aggregate3Signature)) return false;\n  if (!to) return false;\n  if (Object.values(request_).filter(x => typeof x !== 'undefined').length > 0) return false;\n  return true;\n}\nasync function scheduleMulticall(client, args) {\n  var _client$batch2, _client$experimental_2;\n  const {\n    batchSize = 1024,\n    deployless = false,\n    wait = 0\n  } = typeof ((_client$batch2 = client.batch) === null || _client$batch2 === void 0 ? void 0 : _client$batch2.multicall) === 'object' ? client.batch.multicall : {};\n  const {\n    blockNumber,\n    blockTag = (_client$experimental_2 = client.experimental_blockTag) !== null && _client$experimental_2 !== void 0 ? _client$experimental_2 : 'latest',\n    data,\n    to\n  } = args;\n  const multicallAddress = (() => {\n    if (deployless) return null;\n    if (args.multicallAddress) return args.multicallAddress;\n    if (client.chain) {\n      return getChainContractAddress({\n        blockNumber,\n        chain: client.chain,\n        contract: 'multicall3'\n      });\n    }\n    throw new ClientChainNotConfiguredError();\n  })();\n  const blockNumberHex = typeof blockNumber === 'bigint' ? numberToHex(blockNumber) : undefined;\n  const block = blockNumberHex || blockTag;\n  const {\n    schedule\n  } = createBatchScheduler({\n    id: \"\".concat(client.uid, \".\").concat(block),\n    wait,\n    shouldSplitBatch(args) {\n      const size = args.reduce((size, _ref2) => {\n        let {\n          data\n        } = _ref2;\n        return size + (data.length - 2);\n      }, 0);\n      return size > batchSize * 2;\n    },\n    fn: async requests => {\n      const calls = requests.map(request => ({\n        allowFailure: true,\n        callData: request.data,\n        target: request.to\n      }));\n      const calldata = encodeFunctionData({\n        abi: multicall3Abi,\n        args: [calls],\n        functionName: 'aggregate3'\n      });\n      const data = await client.request({\n        method: 'eth_call',\n        params: [_objectSpread({}, multicallAddress === null ? {\n          data: toDeploylessCallViaBytecodeData({\n            code: multicall3Bytecode,\n            data: calldata\n          })\n        } : {\n          to: multicallAddress,\n          data: calldata\n        }), block]\n      });\n      return decodeFunctionResult({\n        abi: multicall3Abi,\n        args: [calls],\n        functionName: 'aggregate3',\n        data: data || '0x'\n      });\n    }\n  });\n  const [{\n    returnData,\n    success\n  }] = await schedule({\n    data,\n    to\n  });\n  if (!success) throw new RawContractError({\n    data: returnData\n  });\n  if (returnData === '0x') return {\n    data: undefined\n  };\n  return {\n    data: returnData\n  };\n}\nfunction toDeploylessCallViaBytecodeData(parameters) {\n  const {\n    code,\n    data\n  } = parameters;\n  return encodeDeployData({\n    abi: parseAbi(['constructor(bytes, bytes)']),\n    bytecode: deploylessCallViaBytecodeBytecode,\n    args: [code, data]\n  });\n}\nfunction toDeploylessCallViaFactoryData(parameters) {\n  const {\n    data,\n    factory,\n    factoryData,\n    to\n  } = parameters;\n  return encodeDeployData({\n    abi: parseAbi(['constructor(address, bytes, address, bytes)']),\n    bytecode: deploylessCallViaFactoryBytecode,\n    args: [to, data, factory, factoryData]\n  });\n}\n/** @internal */\nexport function getRevertErrorData(err) {\n  var _error$data;\n  if (!(err instanceof BaseError)) return undefined;\n  const error = err.walk();\n  return typeof (error === null || error === void 0 ? void 0 : error.data) === 'object' ? (_error$data = error.data) === null || _error$data === void 0 ? void 0 : _error$data.data : error.data;\n}","map":{"version":3,"names":["parseAbi","BlockOverrides","parseAccount","multicall3Abi","aggregate3Signature","deploylessCallViaBytecodeBytecode","deploylessCallViaFactoryBytecode","multicall3Bytecode","BaseError","ChainDoesNotSupportContract","ClientChainNotConfiguredError","CounterfactualDeploymentFailedError","RawContractError","decodeFunctionResult","encodeDeployData","encodeFunctionData","getChainContractAddress","numberToHex","getCallError","extract","formatTransactionRequest","createBatchScheduler","serializeStateOverride","assertRequest","call","client","args","_client$batch","_client$experimental_","account","account_","authorizationList","batch","Boolean","multicall","blockNumber","blockTag","experimental_blockTag","accessList","blobs","blockOverrides","code","data","data_","factory","factoryData","gas","gasPrice","maxFeePerBlobGas","maxFeePerGas","maxPriorityFeePerGas","nonce","to","value","stateOverride","rest","_objectWithoutProperties","_excluded","undefined","deploylessCallViaBytecode","deploylessCallViaFactory","deploylessCall","toDeploylessCallViaBytecodeData","toDeploylessCallViaFactoryData","_client$chain","blockNumberHex","block","rpcBlockOverrides","toRpc","rpcStateOverride","chainFormat","chain","formatters","transactionRequest","format","request","_objectSpread","shouldPerformMulticall","scheduleMulticall","err","params","base","response","method","getRevertErrorData","offchainLookup","offchainLookupSignature","ccipRead","slice","_ref","request_","_excluded2","startsWith","Object","values","filter","x","length","_client$batch2","_client$experimental_2","batchSize","deployless","wait","multicallAddress","contract","schedule","id","concat","uid","shouldSplitBatch","size","reduce","_ref2","fn","requests","calls","map","allowFailure","callData","target","calldata","abi","functionName","returnData","success","parameters","bytecode","_error$data","error","walk"],"sources":["/Users/mac/Desktop/topl1/frontend/node_modules/viem/actions/public/call.ts"],"sourcesContent":["import { type Address, parseAbi } from 'abitype'\nimport * as BlockOverrides from 'ox/BlockOverrides'\n\nimport type { Account } from '../../accounts/types.js'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { multicall3Abi } from '../../constants/abis.js'\nimport { aggregate3Signature } from '../../constants/contract.js'\nimport {\n  deploylessCallViaBytecodeBytecode,\n  deploylessCallViaFactoryBytecode,\n  multicall3Bytecode,\n} from '../../constants/contracts.js'\nimport { BaseError } from '../../errors/base.js'\nimport {\n  ChainDoesNotSupportContract,\n  ClientChainNotConfiguredError,\n} from '../../errors/chain.js'\nimport {\n  CounterfactualDeploymentFailedError,\n  RawContractError,\n  type RawContractErrorType,\n} from '../../errors/contract.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { RpcTransactionRequest } from '../../types/rpc.js'\nimport type { StateOverride } from '../../types/stateOverride.js'\nimport type { TransactionRequest } from '../../types/transaction.js'\nimport type { ExactPartial, UnionOmit } from '../../types/utils.js'\nimport {\n  type DecodeFunctionResultErrorType,\n  decodeFunctionResult,\n} from '../../utils/abi/decodeFunctionResult.js'\nimport {\n  type EncodeDeployDataErrorType,\n  encodeDeployData,\n} from '../../utils/abi/encodeDeployData.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  encodeFunctionData,\n} from '../../utils/abi/encodeFunctionData.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type GetChainContractAddressErrorType,\n  getChainContractAddress,\n} from '../../utils/chain/getChainContractAddress.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\nimport {\n  type GetCallErrorReturnType,\n  getCallError,\n} from '../../utils/errors/getCallError.js'\nimport { extract } from '../../utils/formatters/extract.js'\nimport {\n  type FormatTransactionRequestErrorType,\n  type FormattedTransactionRequest,\n  formatTransactionRequest,\n} from '../../utils/formatters/transactionRequest.js'\nimport {\n  type CreateBatchSchedulerErrorType,\n  createBatchScheduler,\n} from '../../utils/promise/createBatchScheduler.js'\nimport {\n  type SerializeStateOverrideErrorType,\n  serializeStateOverride,\n} from '../../utils/stateOverride.js'\nimport type {\n  AssertRequestErrorType,\n  AssertRequestParameters,\n} from '../../utils/transaction/assertRequest.js'\nimport { assertRequest } from '../../utils/transaction/assertRequest.js'\n\nexport type CallParameters<\n  chain extends Chain | undefined = Chain | undefined,\n> = UnionOmit<FormattedCall<chain>, 'from'> & {\n  /** Account attached to the call (msg.sender). */\n  account?: Account | Address | undefined\n  /** Whether or not to enable multicall batching on this call. */\n  batch?: boolean | undefined\n  /** Block overrides for the call. */\n  blockOverrides?: BlockOverrides.BlockOverrides | undefined\n  /** Bytecode to perform the call on. */\n  code?: Hex | undefined\n  /** Contract deployment factory address (ie. Create2 factory, Smart Account factory, etc). */\n  factory?: Address | undefined\n  /** Calldata to execute on the factory to deploy the contract. */\n  factoryData?: Hex | undefined\n  /** State overrides for the call. */\n  stateOverride?: StateOverride | undefined\n} & (\n    | {\n        /** The balance of the account at a block number. */\n        blockNumber?: bigint | undefined\n        blockTag?: undefined\n      }\n    | {\n        blockNumber?: undefined\n        /**\n         * The balance of the account at a block tag.\n         * @default 'latest'\n         */\n        blockTag?: BlockTag | undefined\n      }\n  )\ntype FormattedCall<chain extends Chain | undefined = Chain | undefined> =\n  FormattedTransactionRequest<chain>\n\nexport type CallReturnType = { data: Hex | undefined }\n\nexport type CallErrorType = GetCallErrorReturnType<\n  | ParseAccountErrorType\n  | SerializeStateOverrideErrorType\n  | AssertRequestErrorType\n  | NumberToHexErrorType\n  | FormatTransactionRequestErrorType\n  | ScheduleMulticallErrorType\n  | RequestErrorType\n  | ToDeploylessCallViaBytecodeDataErrorType\n  | ToDeploylessCallViaFactoryDataErrorType\n>\n\n/**\n * Executes a new message call immediately without submitting a transaction to the network.\n *\n * - Docs: https://viem.sh/docs/actions/public/call\n * - JSON-RPC Methods: [`eth_call`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_call)\n *\n * @param client - Client to use\n * @param parameters - {@link CallParameters}\n * @returns The call data. {@link CallReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { call } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const data = await call(client, {\n *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n *   data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * })\n */\nexport async function call<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  args: CallParameters<chain>,\n): Promise<CallReturnType> {\n  const {\n    account: account_ = client.account,\n    authorizationList,\n    batch = Boolean(client.batch?.multicall),\n    blockNumber,\n    blockTag = client.experimental_blockTag ?? 'latest',\n    accessList,\n    blobs,\n    blockOverrides,\n    code,\n    data: data_,\n    factory,\n    factoryData,\n    gas,\n    gasPrice,\n    maxFeePerBlobGas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    to,\n    value,\n    stateOverride,\n    ...rest\n  } = args\n  const account = account_ ? parseAccount(account_) : undefined\n\n  if (code && (factory || factoryData))\n    throw new BaseError(\n      'Cannot provide both `code` & `factory`/`factoryData` as parameters.',\n    )\n  if (code && to)\n    throw new BaseError('Cannot provide both `code` & `to` as parameters.')\n\n  // Check if the call is deployless via bytecode.\n  const deploylessCallViaBytecode = code && data_\n  // Check if the call is deployless via a factory.\n  const deploylessCallViaFactory = factory && factoryData && to && data_\n  const deploylessCall = deploylessCallViaBytecode || deploylessCallViaFactory\n\n  const data = (() => {\n    if (deploylessCallViaBytecode)\n      return toDeploylessCallViaBytecodeData({\n        code,\n        data: data_,\n      })\n    if (deploylessCallViaFactory)\n      return toDeploylessCallViaFactoryData({\n        data: data_,\n        factory,\n        factoryData,\n        to,\n      })\n    return data_\n  })()\n\n  try {\n    assertRequest(args as AssertRequestParameters)\n\n    const blockNumberHex =\n      typeof blockNumber === 'bigint' ? numberToHex(blockNumber) : undefined\n    const block = blockNumberHex || blockTag\n\n    const rpcBlockOverrides = blockOverrides\n      ? BlockOverrides.toRpc(blockOverrides)\n      : undefined\n    const rpcStateOverride = serializeStateOverride(stateOverride)\n\n    const chainFormat = client.chain?.formatters?.transactionRequest?.format\n    const format = chainFormat || formatTransactionRequest\n\n    const request = format(\n      {\n        // Pick out extra data that might exist on the chain's transaction request type.\n        ...extract(rest, { format: chainFormat }),\n        accessList,\n        account,\n        authorizationList,\n        blobs,\n        data,\n        gas,\n        gasPrice,\n        maxFeePerBlobGas,\n        maxFeePerGas,\n        maxPriorityFeePerGas,\n        nonce,\n        to: deploylessCall ? undefined : to,\n        value,\n      } as TransactionRequest,\n      'call',\n    ) as TransactionRequest\n\n    if (\n      batch &&\n      shouldPerformMulticall({ request }) &&\n      !rpcStateOverride &&\n      !rpcBlockOverrides\n    ) {\n      try {\n        return await scheduleMulticall(client, {\n          ...request,\n          blockNumber,\n          blockTag,\n        } as unknown as ScheduleMulticallParameters<chain>)\n      } catch (err) {\n        if (\n          !(err instanceof ClientChainNotConfiguredError) &&\n          !(err instanceof ChainDoesNotSupportContract)\n        )\n          throw err\n      }\n    }\n\n    const params = (() => {\n      const base = [\n        request as ExactPartial<RpcTransactionRequest>,\n        block,\n      ] as const\n      if (rpcStateOverride && rpcBlockOverrides)\n        return [...base, rpcStateOverride, rpcBlockOverrides] as const\n      if (rpcStateOverride) return [...base, rpcStateOverride] as const\n      if (rpcBlockOverrides) return [...base, {}, rpcBlockOverrides] as const\n      return base\n    })()\n\n    const response = await client.request({\n      method: 'eth_call',\n      params,\n    })\n    if (response === '0x') return { data: undefined }\n    return { data: response }\n  } catch (err) {\n    const data = getRevertErrorData(err)\n\n    // Check for CCIP-Read offchain lookup signature.\n    const { offchainLookup, offchainLookupSignature } = await import(\n      '../../utils/ccip.js'\n    )\n    if (\n      client.ccipRead !== false &&\n      data?.slice(0, 10) === offchainLookupSignature &&\n      to\n    )\n      return { data: await offchainLookup(client, { data, to }) }\n\n    // Check for counterfactual deployment error.\n    if (deploylessCall && data?.slice(0, 10) === '0x101bb98d')\n      throw new CounterfactualDeploymentFailedError({ factory })\n\n    throw getCallError(err as ErrorType, {\n      ...args,\n      account,\n      chain: client.chain,\n    })\n  }\n}\n\n// We only want to perform a scheduled multicall if:\n// - The request has calldata,\n// - The request has a target address,\n// - The target address is not already the aggregate3 signature,\n// - The request has no other properties (`nonce`, `gas`, etc cannot be sent with a multicall).\nfunction shouldPerformMulticall({ request }: { request: TransactionRequest }) {\n  const { data, to, ...request_ } = request\n  if (!data) return false\n  if (data.startsWith(aggregate3Signature)) return false\n  if (!to) return false\n  if (\n    Object.values(request_).filter((x) => typeof x !== 'undefined').length > 0\n  )\n    return false\n  return true\n}\n\ntype ScheduleMulticallParameters<chain extends Chain | undefined> = Pick<\n  CallParameters<chain>,\n  'blockNumber' | 'blockTag'\n> & {\n  data: Hex\n  multicallAddress?: Address | undefined\n  to: Address\n}\n\ntype ScheduleMulticallErrorType =\n  | GetChainContractAddressErrorType\n  | NumberToHexErrorType\n  | CreateBatchSchedulerErrorType\n  | EncodeFunctionDataErrorType\n  | DecodeFunctionResultErrorType\n  | RawContractErrorType\n  | ErrorType\n\nasync function scheduleMulticall<chain extends Chain | undefined>(\n  client: Client<Transport>,\n  args: ScheduleMulticallParameters<chain>,\n) {\n  const {\n    batchSize = 1024,\n    deployless = false,\n    wait = 0,\n  } = typeof client.batch?.multicall === 'object' ? client.batch.multicall : {}\n  const {\n    blockNumber,\n    blockTag = client.experimental_blockTag ?? 'latest',\n    data,\n    to,\n  } = args\n\n  const multicallAddress = (() => {\n    if (deployless) return null\n    if (args.multicallAddress) return args.multicallAddress\n    if (client.chain) {\n      return getChainContractAddress({\n        blockNumber,\n        chain: client.chain,\n        contract: 'multicall3',\n      })\n    }\n    throw new ClientChainNotConfiguredError()\n  })()\n\n  const blockNumberHex =\n    typeof blockNumber === 'bigint' ? numberToHex(blockNumber) : undefined\n  const block = blockNumberHex || blockTag\n\n  const { schedule } = createBatchScheduler({\n    id: `${client.uid}.${block}`,\n    wait,\n    shouldSplitBatch(args) {\n      const size = args.reduce((size, { data }) => size + (data.length - 2), 0)\n      return size > batchSize * 2\n    },\n    fn: async (\n      requests: {\n        data: Hex\n        to: Address\n      }[],\n    ) => {\n      const calls = requests.map((request) => ({\n        allowFailure: true,\n        callData: request.data,\n        target: request.to,\n      }))\n\n      const calldata = encodeFunctionData({\n        abi: multicall3Abi,\n        args: [calls],\n        functionName: 'aggregate3',\n      })\n\n      const data = await client.request({\n        method: 'eth_call',\n        params: [\n          {\n            ...(multicallAddress === null\n              ? {\n                  data: toDeploylessCallViaBytecodeData({\n                    code: multicall3Bytecode,\n                    data: calldata,\n                  }),\n                }\n              : { to: multicallAddress, data: calldata }),\n          },\n          block,\n        ],\n      })\n\n      return decodeFunctionResult({\n        abi: multicall3Abi,\n        args: [calls],\n        functionName: 'aggregate3',\n        data: data || '0x',\n      })\n    },\n  })\n\n  const [{ returnData, success }] = await schedule({ data, to })\n\n  if (!success) throw new RawContractError({ data: returnData })\n  if (returnData === '0x') return { data: undefined }\n  return { data: returnData }\n}\n\ntype ToDeploylessCallViaBytecodeDataErrorType =\n  | EncodeDeployDataErrorType\n  | ErrorType\n\nfunction toDeploylessCallViaBytecodeData(parameters: { code: Hex; data: Hex }) {\n  const { code, data } = parameters\n  return encodeDeployData({\n    abi: parseAbi(['constructor(bytes, bytes)']),\n    bytecode: deploylessCallViaBytecodeBytecode,\n    args: [code, data],\n  })\n}\n\ntype ToDeploylessCallViaFactoryDataErrorType =\n  | EncodeDeployDataErrorType\n  | ErrorType\n\nfunction toDeploylessCallViaFactoryData(parameters: {\n  data: Hex\n  factory: Address\n  factoryData: Hex\n  to: Address\n}) {\n  const { data, factory, factoryData, to } = parameters\n  return encodeDeployData({\n    abi: parseAbi(['constructor(address, bytes, address, bytes)']),\n    bytecode: deploylessCallViaFactoryBytecode,\n    args: [to, data, factory, factoryData],\n  })\n}\n\n/** @internal */\nexport type GetRevertErrorDataErrorType = ErrorType\n\n/** @internal */\nexport function getRevertErrorData(err: unknown) {\n  if (!(err instanceof BaseError)) return undefined\n  const error = err.walk() as RawContractError\n  return typeof error?.data === 'object' ? error.data?.data : error.data\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}