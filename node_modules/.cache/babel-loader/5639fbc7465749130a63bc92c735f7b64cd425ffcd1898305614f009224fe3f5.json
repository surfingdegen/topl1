{"ast":null,"code":"import { AbiEventNotFoundError } from '../../errors/abi.js';\nimport { FilterTypeNotSupportedError } from '../../errors/log.js';\nimport { toBytes } from '../encoding/toBytes.js';\nimport { keccak256 } from '../hash/keccak256.js';\nimport { toEventSelector } from '../hash/toEventSelector.js';\nimport { encodeAbiParameters } from './encodeAbiParameters.js';\nimport { formatAbiItem } from './formatAbiItem.js';\nimport { getAbiItem } from './getAbiItem.js';\nconst docsPath = '/docs/contract/encodeEventTopics';\nexport function encodeEventTopics(parameters) {\n  const {\n    abi,\n    eventName,\n    args\n  } = parameters;\n  let abiItem = abi[0];\n  if (eventName) {\n    const item = getAbiItem({\n      abi,\n      name: eventName\n    });\n    if (!item) throw new AbiEventNotFoundError(eventName, {\n      docsPath\n    });\n    abiItem = item;\n  }\n  if (abiItem.type !== 'event') throw new AbiEventNotFoundError(undefined, {\n    docsPath\n  });\n  const definition = formatAbiItem(abiItem);\n  const signature = toEventSelector(definition);\n  let topics = [];\n  if (args && 'inputs' in abiItem) {\n    var _abiItem$inputs, _indexedInputs$map;\n    const indexedInputs = (_abiItem$inputs = abiItem.inputs) === null || _abiItem$inputs === void 0 ? void 0 : _abiItem$inputs.filter(param => 'indexed' in param && param.indexed);\n    const args_ = Array.isArray(args) ? args : Object.values(args).length > 0 ? (_indexedInputs$map = indexedInputs === null || indexedInputs === void 0 ? void 0 : indexedInputs.map(x => args[x.name])) !== null && _indexedInputs$map !== void 0 ? _indexedInputs$map : [] : [];\n    if (args_.length > 0) {\n      var _indexedInputs$map2;\n      topics = (_indexedInputs$map2 = indexedInputs === null || indexedInputs === void 0 ? void 0 : indexedInputs.map((param, i) => {\n        if (Array.isArray(args_[i])) return args_[i].map((_, j) => encodeArg({\n          param,\n          value: args_[i][j]\n        }));\n        return typeof args_[i] !== 'undefined' && args_[i] !== null ? encodeArg({\n          param,\n          value: args_[i]\n        }) : null;\n      })) !== null && _indexedInputs$map2 !== void 0 ? _indexedInputs$map2 : [];\n    }\n  }\n  return [signature, ...topics];\n}\nfunction encodeArg(_ref) {\n  let {\n    param,\n    value\n  } = _ref;\n  if (param.type === 'string' || param.type === 'bytes') return keccak256(toBytes(value));\n  if (param.type === 'tuple' || param.type.match(/^(.*)\\[(\\d+)?\\]$/)) throw new FilterTypeNotSupportedError(param.type);\n  return encodeAbiParameters([param], [value]);\n}","map":{"version":3,"names":["AbiEventNotFoundError","FilterTypeNotSupportedError","toBytes","keccak256","toEventSelector","encodeAbiParameters","formatAbiItem","getAbiItem","docsPath","encodeEventTopics","parameters","abi","eventName","args","abiItem","item","name","type","undefined","definition","signature","topics","_abiItem$inputs","_indexedInputs$map","indexedInputs","inputs","filter","param","indexed","args_","Array","isArray","Object","values","length","map","x","_indexedInputs$map2","i","_","j","encodeArg","value","_ref","match"],"sources":["/Users/mac/Desktop/topl1/frontend/node_modules/viem/utils/abi/encodeEventTopics.ts"],"sourcesContent":["import type {\n  Abi,\n  AbiParameter,\n  AbiParameterToPrimitiveType,\n  ExtractAbiEvents,\n} from 'abitype'\n\nimport {\n  AbiEventNotFoundError,\n  type AbiEventNotFoundErrorType,\n} from '../../errors/abi.js'\nimport {\n  FilterTypeNotSupportedError,\n  type FilterTypeNotSupportedErrorType,\n} from '../../errors/log.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  ContractEventArgs,\n  ContractEventName,\n  EventDefinition,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { IsNarrowable, UnionEvaluate } from '../../types/utils.js'\nimport { type ToBytesErrorType, toBytes } from '../encoding/toBytes.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\nimport {\n  type ToEventSelectorErrorType,\n  toEventSelector,\n} from '../hash/toEventSelector.js'\nimport {\n  type EncodeAbiParametersErrorType,\n  encodeAbiParameters,\n} from './encodeAbiParameters.js'\nimport { type FormatAbiItemErrorType, formatAbiItem } from './formatAbiItem.js'\nimport { type GetAbiItemErrorType, getAbiItem } from './getAbiItem.js'\n\nconst docsPath = '/docs/contract/encodeEventTopics'\n\nexport type EncodeEventTopicsParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends ContractEventName<abi> | undefined = ContractEventName<abi>,\n  ///\n  hasEvents = abi extends Abi\n    ? Abi extends abi\n      ? true\n      : [ExtractAbiEvents<abi>] extends [never]\n        ? false\n        : true\n    : true,\n  allArgs = ContractEventArgs<\n    abi,\n    eventName extends ContractEventName<abi>\n      ? eventName\n      : ContractEventName<abi>\n  >,\n  allErrorNames = ContractEventName<abi>,\n> = {\n  abi: abi\n  args?: allArgs | undefined\n} & UnionEvaluate<\n  IsNarrowable<abi, Abi> extends true\n    ? abi['length'] extends 1\n      ? { eventName?: eventName | allErrorNames | undefined }\n      : { eventName: eventName | allErrorNames }\n    : { eventName?: eventName | allErrorNames | undefined }\n> &\n  (hasEvents extends true ? unknown : never)\n\nexport type EncodeEventTopicsReturnType = [Hex, ...(Hex | Hex[] | null)[]]\n\nexport type EncodeEventTopicsErrorType =\n  | AbiEventNotFoundErrorType\n  | EncodeArgErrorType\n  | FormatAbiItemErrorType\n  | GetAbiItemErrorType\n  | ToEventSelectorErrorType\n  | ErrorType\n\nexport function encodeEventTopics<\n  const abi extends Abi | readonly unknown[],\n  eventName extends ContractEventName<abi> | undefined = undefined,\n>(\n  parameters: EncodeEventTopicsParameters<abi, eventName>,\n): EncodeEventTopicsReturnType {\n  const { abi, eventName, args } = parameters as EncodeEventTopicsParameters\n\n  let abiItem = abi[0]\n  if (eventName) {\n    const item = getAbiItem({ abi, name: eventName })\n    if (!item) throw new AbiEventNotFoundError(eventName, { docsPath })\n    abiItem = item\n  }\n\n  if (abiItem.type !== 'event')\n    throw new AbiEventNotFoundError(undefined, { docsPath })\n\n  const definition = formatAbiItem(abiItem)\n  const signature = toEventSelector(definition as EventDefinition)\n\n  let topics: (Hex | Hex[] | null)[] = []\n  if (args && 'inputs' in abiItem) {\n    const indexedInputs = abiItem.inputs?.filter(\n      (param) => 'indexed' in param && param.indexed,\n    )\n    const args_ = Array.isArray(args)\n      ? args\n      : Object.values(args).length > 0\n        ? (indexedInputs?.map((x: any) => (args as any)[x.name]) ?? [])\n        : []\n\n    if (args_.length > 0) {\n      topics =\n        indexedInputs?.map((param, i) => {\n          if (Array.isArray(args_[i]))\n            return args_[i].map((_: any, j: number) =>\n              encodeArg({ param, value: args_[i][j] }),\n            )\n          return typeof args_[i] !== 'undefined' && args_[i] !== null\n            ? encodeArg({ param, value: args_[i] })\n            : null\n        }) ?? []\n    }\n  }\n  return [signature, ...topics]\n}\n\nexport type EncodeArgErrorType =\n  | Keccak256ErrorType\n  | ToBytesErrorType\n  | EncodeAbiParametersErrorType\n  | FilterTypeNotSupportedErrorType\n  | ErrorType\n\nfunction encodeArg({\n  param,\n  value,\n}: {\n  param: AbiParameter\n  value: AbiParameterToPrimitiveType<AbiParameter>\n}) {\n  if (param.type === 'string' || param.type === 'bytes')\n    return keccak256(toBytes(value as string))\n  if (param.type === 'tuple' || param.type.match(/^(.*)\\[(\\d+)?\\]$/))\n    throw new FilterTypeNotSupportedError(param.type)\n  return encodeAbiParameters([param], [value])\n}\n"],"mappings":"AAOA,SACEA,qBAAqB,QAEhB,qBAAqB;AAC5B,SACEC,2BAA2B,QAEtB,qBAAqB;AAS5B,SAAgCC,OAAO,QAAQ,wBAAwB;AACvE,SAAkCC,SAAS,QAAQ,sBAAsB;AACzE,SAEEC,eAAe,QACV,4BAA4B;AACnC,SAEEC,mBAAmB,QACd,0BAA0B;AACjC,SAAsCC,aAAa,QAAQ,oBAAoB;AAC/E,SAAmCC,UAAU,QAAQ,iBAAiB;AAEtE,MAAMC,QAAQ,GAAG,kCAAkC;AA0CnD,OAAM,SAAUC,iBAAiBA,CAI/BC,UAAuD;EAEvD,MAAM;IAAEC,GAAG;IAAEC,SAAS;IAAEC;EAAI,CAAE,GAAGH,UAAyC;EAE1E,IAAII,OAAO,GAAGH,GAAG,CAAC,CAAC,CAAC;EACpB,IAAIC,SAAS,EAAE;IACb,MAAMG,IAAI,GAAGR,UAAU,CAAC;MAAEI,GAAG;MAAEK,IAAI,EAAEJ;IAAS,CAAE,CAAC;IACjD,IAAI,CAACG,IAAI,EAAE,MAAM,IAAIf,qBAAqB,CAACY,SAAS,EAAE;MAAEJ;IAAQ,CAAE,CAAC;IACnEM,OAAO,GAAGC,IAAI;EAChB;EAEA,IAAID,OAAO,CAACG,IAAI,KAAK,OAAO,EAC1B,MAAM,IAAIjB,qBAAqB,CAACkB,SAAS,EAAE;IAAEV;EAAQ,CAAE,CAAC;EAE1D,MAAMW,UAAU,GAAGb,aAAa,CAACQ,OAAO,CAAC;EACzC,MAAMM,SAAS,GAAGhB,eAAe,CAACe,UAA6B,CAAC;EAEhE,IAAIE,MAAM,GAA2B,EAAE;EACvC,IAAIR,IAAI,IAAI,QAAQ,IAAIC,OAAO,EAAE;IAAA,IAAAQ,eAAA,EAAAC,kBAAA;IAC/B,MAAMC,aAAa,IAAAF,eAAA,GAAGR,OAAO,CAACW,MAAM,cAAAH,eAAA,uBAAdA,eAAA,CAAgBI,MAAM,CACzCC,KAAK,IAAK,SAAS,IAAIA,KAAK,IAAIA,KAAK,CAACC,OAAO,CAC/C;IACD,MAAMC,KAAK,GAAGC,KAAK,CAACC,OAAO,CAAClB,IAAI,CAAC,GAC7BA,IAAI,GACJmB,MAAM,CAACC,MAAM,CAACpB,IAAI,CAAC,CAACqB,MAAM,GAAG,CAAC,IAAAX,kBAAA,GAC3BC,aAAa,aAAbA,aAAa,uBAAbA,aAAa,CAAEW,GAAG,CAAEC,CAAM,IAAMvB,IAAY,CAACuB,CAAC,CAACpB,IAAI,CAAC,CAAC,cAAAO,kBAAA,cAAAA,kBAAA,GAAI,EAAE,GAC5D,EAAE;IAER,IAAIM,KAAK,CAACK,MAAM,GAAG,CAAC,EAAE;MAAA,IAAAG,mBAAA;MACpBhB,MAAM,IAAAgB,mBAAA,GACJb,aAAa,aAAbA,aAAa,uBAAbA,aAAa,CAAEW,GAAG,CAAC,CAACR,KAAK,EAAEW,CAAC,KAAI;QAC9B,IAAIR,KAAK,CAACC,OAAO,CAACF,KAAK,CAACS,CAAC,CAAC,CAAC,EACzB,OAAOT,KAAK,CAACS,CAAC,CAAC,CAACH,GAAG,CAAC,CAACI,CAAM,EAAEC,CAAS,KACpCC,SAAS,CAAC;UAAEd,KAAK;UAAEe,KAAK,EAAEb,KAAK,CAACS,CAAC,CAAC,CAACE,CAAC;QAAC,CAAE,CAAC,CACzC;QACH,OAAO,OAAOX,KAAK,CAACS,CAAC,CAAC,KAAK,WAAW,IAAIT,KAAK,CAACS,CAAC,CAAC,KAAK,IAAI,GACvDG,SAAS,CAAC;UAAEd,KAAK;UAAEe,KAAK,EAAEb,KAAK,CAACS,CAAC;QAAC,CAAE,CAAC,GACrC,IAAI;MACV,CAAC,CAAC,cAAAD,mBAAA,cAAAA,mBAAA,GAAI,EAAE;IACZ;EACF;EACA,OAAO,CAACjB,SAAS,EAAE,GAAGC,MAAM,CAAC;AAC/B;AASA,SAASoB,SAASA,CAAAE,IAAA,EAMjB;EAAA,IANkB;IACjBhB,KAAK;IACLe;EAAK,CAIN,GAAAC,IAAA;EACC,IAAIhB,KAAK,CAACV,IAAI,KAAK,QAAQ,IAAIU,KAAK,CAACV,IAAI,KAAK,OAAO,EACnD,OAAOd,SAAS,CAACD,OAAO,CAACwC,KAAe,CAAC,CAAC;EAC5C,IAAIf,KAAK,CAACV,IAAI,KAAK,OAAO,IAAIU,KAAK,CAACV,IAAI,CAAC2B,KAAK,CAAC,kBAAkB,CAAC,EAChE,MAAM,IAAI3C,2BAA2B,CAAC0B,KAAK,CAACV,IAAI,CAAC;EACnD,OAAOZ,mBAAmB,CAAC,CAACsB,KAAK,CAAC,EAAE,CAACe,KAAK,CAAC,CAAC;AAC9C","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}