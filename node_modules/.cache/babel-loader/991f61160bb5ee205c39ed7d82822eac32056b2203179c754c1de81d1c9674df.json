{"ast":null,"code":"import _objectSpread from \"/Users/mac/Desktop/topl1/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/Users/mac/Desktop/topl1/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"account\", \"accessList\", \"authorizationList\", \"chain\", \"blobVersionedHashes\", \"blobs\", \"data\", \"gas\", \"gasPrice\", \"maxFeePerBlobGas\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"nonceManager\", \"to\", \"type\", \"value\"];\nimport { parseAccount } from '../../accounts/utils/parseAccount.js';\nimport { BaseFeeScalarError } from '../../errors/fee.js';\nimport { getTransactionError } from '../../utils/errors/getTransactionError.js';\nimport { extract } from '../../utils/formatters/extract.js';\nimport { formatTransaction } from '../../utils/formatters/transaction.js';\nimport { formatTransactionRequest } from '../../utils/formatters/transactionRequest.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { assertRequest } from '../../utils/transaction/assertRequest.js';\nimport { getBlock } from './getBlock.js';\nimport { getChainId as getChainId_ } from './getChainId.js';\n/**\n * Fills a transaction request with the necessary fields to be signed over.\n *\n * - Docs: https://viem.sh/docs/actions/public/fillTransaction\n *\n * @param client - Client to use\n * @param parameters - {@link FillTransactionParameters}\n * @returns The filled transaction. {@link FillTransactionReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { fillTransaction } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const result = await fillTransaction(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: parseEther('1'),\n * })\n */\nexport async function fillTransaction(client, parameters) {\n  var _chain$formatters;\n  const {\n      account = client.account,\n      accessList,\n      authorizationList,\n      chain = client.chain,\n      blobVersionedHashes,\n      blobs,\n      data,\n      gas,\n      gasPrice,\n      maxFeePerBlobGas,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce: nonce_,\n      nonceManager,\n      to,\n      type,\n      value\n    } = parameters,\n    rest = _objectWithoutProperties(parameters, _excluded);\n  const nonce = await (async () => {\n    if (!account) return nonce_;\n    if (!nonceManager) return nonce_;\n    if (typeof nonce_ !== 'undefined') return nonce_;\n    const account_ = parseAccount(account);\n    const chainId = chain ? chain.id : await getAction(client, getChainId_, 'getChainId')({});\n    return await nonceManager.consume({\n      address: account_.address,\n      chainId,\n      client\n    });\n  })();\n  assertRequest(parameters);\n  const chainFormat = chain === null || chain === void 0 || (_chain$formatters = chain.formatters) === null || _chain$formatters === void 0 || (_chain$formatters = _chain$formatters.transactionRequest) === null || _chain$formatters === void 0 ? void 0 : _chain$formatters.format;\n  const format = chainFormat || formatTransactionRequest;\n  const request = format(_objectSpread(_objectSpread({}, extract(rest, {\n    format: chainFormat\n  })), {}, {\n    account: account ? parseAccount(account) : undefined,\n    accessList,\n    authorizationList,\n    blobs,\n    blobVersionedHashes,\n    data,\n    gas,\n    gasPrice,\n    maxFeePerBlobGas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    to,\n    type,\n    value\n  }), 'fillTransaction');\n  try {\n    var _chain$formatters2, _parameters$gas, _parameters$gasPrice, _parameters$maxFeePer, _parameters$maxFeePer2, _parameters$maxPriori, _parameters$nonce, _feeMultiplier$toStri, _feeMultiplier$toStri2;\n    const response = await client.request({\n      method: 'eth_fillTransaction',\n      params: [request]\n    });\n    const format = (chain === null || chain === void 0 || (_chain$formatters2 = chain.formatters) === null || _chain$formatters2 === void 0 || (_chain$formatters2 = _chain$formatters2.transaction) === null || _chain$formatters2 === void 0 ? void 0 : _chain$formatters2.format) || formatTransaction;\n    const transaction = format(response.tx);\n    // Remove unnecessary fields.\n    delete transaction.blockHash;\n    delete transaction.blockNumber;\n    delete transaction.r;\n    delete transaction.s;\n    delete transaction.transactionIndex;\n    delete transaction.v;\n    delete transaction.yParity;\n    // Rewrite fields.\n    transaction.data = transaction.input;\n    // Preference supplied fees (some nodes do not take these preferences).\n    if (transaction.gas) transaction.gas = (_parameters$gas = parameters.gas) !== null && _parameters$gas !== void 0 ? _parameters$gas : transaction.gas;\n    if (transaction.gasPrice) transaction.gasPrice = (_parameters$gasPrice = parameters.gasPrice) !== null && _parameters$gasPrice !== void 0 ? _parameters$gasPrice : transaction.gasPrice;\n    if (transaction.maxFeePerBlobGas) transaction.maxFeePerBlobGas = (_parameters$maxFeePer = parameters.maxFeePerBlobGas) !== null && _parameters$maxFeePer !== void 0 ? _parameters$maxFeePer : transaction.maxFeePerBlobGas;\n    if (transaction.maxFeePerGas) transaction.maxFeePerGas = (_parameters$maxFeePer2 = parameters.maxFeePerGas) !== null && _parameters$maxFeePer2 !== void 0 ? _parameters$maxFeePer2 : transaction.maxFeePerGas;\n    if (transaction.maxPriorityFeePerGas) transaction.maxPriorityFeePerGas = (_parameters$maxPriori = parameters.maxPriorityFeePerGas) !== null && _parameters$maxPriori !== void 0 ? _parameters$maxPriori : transaction.maxPriorityFeePerGas;\n    if (transaction.nonce) transaction.nonce = (_parameters$nonce = parameters.nonce) !== null && _parameters$nonce !== void 0 ? _parameters$nonce : transaction.nonce;\n    // Build fee multiplier function.\n    const feeMultiplier = await (async (_chain$fees, _chain$fees$baseFeeMu, _chain$fees2) => {\n      if (typeof (chain === null || chain === void 0 || (_chain$fees = chain.fees) === null || _chain$fees === void 0 ? void 0 : _chain$fees.baseFeeMultiplier) === 'function') {\n        const block = await getAction(client, getBlock, 'getBlock')({});\n        return chain.fees.baseFeeMultiplier({\n          block,\n          client,\n          request: parameters\n        });\n      }\n      return (_chain$fees$baseFeeMu = chain === null || chain === void 0 || (_chain$fees2 = chain.fees) === null || _chain$fees2 === void 0 ? void 0 : _chain$fees2.baseFeeMultiplier) !== null && _chain$fees$baseFeeMu !== void 0 ? _chain$fees$baseFeeMu : 1.2;\n    })();\n    if (feeMultiplier < 1) throw new BaseFeeScalarError();\n    const decimals = (_feeMultiplier$toStri = (_feeMultiplier$toStri2 = feeMultiplier.toString().split('.')[1]) === null || _feeMultiplier$toStri2 === void 0 ? void 0 : _feeMultiplier$toStri2.length) !== null && _feeMultiplier$toStri !== void 0 ? _feeMultiplier$toStri : 0;\n    const denominator = 10 ** decimals;\n    const multiplyFee = base => base * BigInt(Math.ceil(feeMultiplier * denominator)) / BigInt(denominator);\n    // Apply fee multiplier.\n    if (transaction.maxFeePerGas && !parameters.maxFeePerGas) transaction.maxFeePerGas = multiplyFee(transaction.maxFeePerGas);\n    if (transaction.gasPrice && !parameters.gasPrice) transaction.gasPrice = multiplyFee(transaction.gasPrice);\n    return {\n      raw: response.raw,\n      transaction: _objectSpread({\n        from: request.from\n      }, transaction)\n    };\n  } catch (err) {\n    throw getTransactionError(err, _objectSpread(_objectSpread({}, parameters), {}, {\n      chain: client.chain\n    }));\n  }\n}","map":{"version":3,"names":["parseAccount","BaseFeeScalarError","getTransactionError","extract","formatTransaction","formatTransactionRequest","getAction","assertRequest","getBlock","getChainId","getChainId_","fillTransaction","client","parameters","_chain$formatters","account","accessList","authorizationList","chain","blobVersionedHashes","blobs","data","gas","gasPrice","maxFeePerBlobGas","maxFeePerGas","maxPriorityFeePerGas","nonce","nonce_","nonceManager","to","type","value","rest","_objectWithoutProperties","_excluded","account_","chainId","id","consume","address","chainFormat","formatters","transactionRequest","format","request","_objectSpread","undefined","_chain$formatters2","_parameters$gas","_parameters$gasPrice","_parameters$maxFeePer","_parameters$maxFeePer2","_parameters$maxPriori","_parameters$nonce","_feeMultiplier$toStri","_feeMultiplier$toStri2","response","method","params","transaction","tx","blockHash","blockNumber","r","s","transactionIndex","v","yParity","input","feeMultiplier","_chain$fees","_chain$fees$baseFeeMu","_chain$fees2","fees","baseFeeMultiplier","block","decimals","toString","split","length","denominator","multiplyFee","base","BigInt","Math","ceil","raw","from","err"],"sources":["/Users/mac/Desktop/topl1/frontend/node_modules/viem/actions/public/fillTransaction.ts"],"sourcesContent":["import type { Address } from 'abitype'\nimport { parseAccount } from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { BaseError } from '../../errors/base.js'\nimport { BaseFeeScalarError } from '../../errors/fee.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account, GetAccountParameter } from '../../types/account.js'\nimport type {\n  Chain,\n  ChainFeesFnParameters,\n  DeriveChain,\n  GetChainParameter,\n} from '../../types/chain.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { TransactionRequest } from '../../types/transaction.js'\nimport type { UnionOmit } from '../../types/utils.js'\nimport {\n  type GetTransactionErrorReturnType,\n  getTransactionError,\n} from '../../utils/errors/getTransactionError.js'\nimport { extract } from '../../utils/formatters/extract.js'\nimport {\n  type FormattedTransaction,\n  formatTransaction,\n} from '../../utils/formatters/transaction.js'\nimport {\n  type FormattedTransactionRequest,\n  formatTransactionRequest,\n} from '../../utils/formatters/transactionRequest.js'\nimport { getAction } from '../../utils/getAction.js'\nimport type { NonceManager } from '../../utils/nonceManager.js'\nimport { assertRequest } from '../../utils/transaction/assertRequest.js'\nimport { getBlock } from './getBlock.js'\nimport { getChainId as getChainId_ } from './getChainId.js'\n\nexport type FillTransactionParameters<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  accountOverride extends Account | Address | undefined =\n    | Account\n    | Address\n    | undefined,\n  ///\n  _derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = UnionOmit<FormattedTransactionRequest<_derivedChain>, 'from'> &\n  GetAccountParameter<account, accountOverride, false, true> &\n  GetChainParameter<chain, chainOverride> & {\n    /**\n     * Nonce manager to use for the transaction request.\n     */\n    nonceManager?: NonceManager | undefined\n  }\n\nexport type FillTransactionReturnType<\n  chain extends Chain | undefined = Chain | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  ///\n  _derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = {\n  raw: Hex\n  transaction: FormattedTransaction<_derivedChain>\n}\n\nexport type FillTransactionErrorType =\n  | GetTransactionErrorReturnType<ErrorType>\n  | ErrorType\n\n/**\n * Fills a transaction request with the necessary fields to be signed over.\n *\n * - Docs: https://viem.sh/docs/actions/public/fillTransaction\n *\n * @param client - Client to use\n * @param parameters - {@link FillTransactionParameters}\n * @returns The filled transaction. {@link FillTransactionReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { fillTransaction } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const result = await fillTransaction(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: parseEther('1'),\n * })\n */\nexport async function fillTransaction<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  chainOverride extends Chain | undefined = undefined,\n  accountOverride extends Account | Address | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: FillTransactionParameters<\n    chain,\n    account,\n    chainOverride,\n    accountOverride\n  >,\n): Promise<FillTransactionReturnType<chain, chainOverride>> {\n  const {\n    account = client.account,\n    accessList,\n    authorizationList,\n    chain = client.chain,\n    blobVersionedHashes,\n    blobs,\n    data,\n    gas,\n    gasPrice,\n    maxFeePerBlobGas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce: nonce_,\n    nonceManager,\n    to,\n    type,\n    value,\n    ...rest\n  } = parameters\n\n  const nonce = await (async () => {\n    if (!account) return nonce_\n    if (!nonceManager) return nonce_\n    if (typeof nonce_ !== 'undefined') return nonce_\n    const account_ = parseAccount(account)\n    const chainId = chain\n      ? chain.id\n      : await getAction(client, getChainId_, 'getChainId')({})\n    return await nonceManager.consume({\n      address: account_.address,\n      chainId,\n      client,\n    })\n  })()\n\n  assertRequest(parameters)\n\n  const chainFormat = chain?.formatters?.transactionRequest?.format\n  const format = chainFormat || formatTransactionRequest\n\n  const request = format(\n    {\n      // Pick out extra data that might exist on the chain's transaction request type.\n      ...extract(rest, { format: chainFormat }),\n      account: account ? parseAccount(account) : undefined,\n      accessList,\n      authorizationList,\n      blobs,\n      blobVersionedHashes,\n      data,\n      gas,\n      gasPrice,\n      maxFeePerBlobGas,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      to,\n      type,\n      value,\n    } as TransactionRequest,\n    'fillTransaction',\n  )\n\n  try {\n    const response = await client.request({\n      method: 'eth_fillTransaction',\n      params: [request],\n    })\n    const format = chain?.formatters?.transaction?.format || formatTransaction\n\n    const transaction = format(response.tx)\n\n    // Remove unnecessary fields.\n    delete transaction.blockHash\n    delete transaction.blockNumber\n    delete transaction.r\n    delete transaction.s\n    delete transaction.transactionIndex\n    delete transaction.v\n    delete transaction.yParity\n\n    // Rewrite fields.\n    transaction.data = transaction.input\n\n    // Preference supplied fees (some nodes do not take these preferences).\n    if (transaction.gas) transaction.gas = parameters.gas ?? transaction.gas\n    if (transaction.gasPrice)\n      transaction.gasPrice = parameters.gasPrice ?? transaction.gasPrice\n    if (transaction.maxFeePerBlobGas)\n      transaction.maxFeePerBlobGas =\n        parameters.maxFeePerBlobGas ?? transaction.maxFeePerBlobGas\n    if (transaction.maxFeePerGas)\n      transaction.maxFeePerGas =\n        parameters.maxFeePerGas ?? transaction.maxFeePerGas\n    if (transaction.maxPriorityFeePerGas)\n      transaction.maxPriorityFeePerGas =\n        parameters.maxPriorityFeePerGas ?? transaction.maxPriorityFeePerGas\n    if (transaction.nonce)\n      transaction.nonce = parameters.nonce ?? transaction.nonce\n\n    // Build fee multiplier function.\n    const feeMultiplier = await (async () => {\n      if (typeof chain?.fees?.baseFeeMultiplier === 'function') {\n        const block = await getAction(client, getBlock, 'getBlock')({})\n        return chain.fees.baseFeeMultiplier({\n          block,\n          client,\n          request: parameters,\n        } as ChainFeesFnParameters)\n      }\n      return chain?.fees?.baseFeeMultiplier ?? 1.2\n    })()\n    if (feeMultiplier < 1) throw new BaseFeeScalarError()\n\n    const decimals = feeMultiplier.toString().split('.')[1]?.length ?? 0\n    const denominator = 10 ** decimals\n    const multiplyFee = (base: bigint) =>\n      (base * BigInt(Math.ceil(feeMultiplier * denominator))) /\n      BigInt(denominator)\n\n    // Apply fee multiplier.\n    if (transaction.maxFeePerGas && !parameters.maxFeePerGas)\n      transaction.maxFeePerGas = multiplyFee(transaction.maxFeePerGas)\n    if (transaction.gasPrice && !parameters.gasPrice)\n      transaction.gasPrice = multiplyFee(transaction.gasPrice)\n\n    return {\n      raw: response.raw,\n      transaction: {\n        from: request.from,\n        ...transaction,\n      },\n    }\n  } catch (err) {\n    throw getTransactionError(\n      err as BaseError,\n      {\n        ...parameters,\n        chain: client.chain,\n      } as never,\n    )\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}