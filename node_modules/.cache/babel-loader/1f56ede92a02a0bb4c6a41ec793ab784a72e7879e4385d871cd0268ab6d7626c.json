{"ast":null,"code":"import { formatAbiItem, formatAbiParams } from '../utils/abi/formatAbiItem.js';\nimport { size } from '../utils/data/size.js';\nimport { BaseError } from './base.js';\nexport class AbiConstructorNotFoundError extends BaseError {\n  constructor(_ref) {\n    let {\n      docsPath\n    } = _ref;\n    super(['A constructor was not found on the ABI.', 'Make sure you are using the correct ABI and that the constructor exists on it.'].join('\\n'), {\n      docsPath,\n      name: 'AbiConstructorNotFoundError'\n    });\n  }\n}\nexport class AbiConstructorParamsNotFoundError extends BaseError {\n  constructor(_ref2) {\n    let {\n      docsPath\n    } = _ref2;\n    super(['Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.', 'Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists.'].join('\\n'), {\n      docsPath,\n      name: 'AbiConstructorParamsNotFoundError'\n    });\n  }\n}\nexport class AbiDecodingDataSizeInvalidError extends BaseError {\n  constructor(_ref3) {\n    let {\n      data,\n      size\n    } = _ref3;\n    super([\"Data size of \".concat(size, \" bytes is invalid.\"), 'Size must be in increments of 32 bytes (size % 32 === 0).'].join('\\n'), {\n      metaMessages: [\"Data: \".concat(data, \" (\").concat(size, \" bytes)\")],\n      name: 'AbiDecodingDataSizeInvalidError'\n    });\n  }\n}\nexport class AbiDecodingDataSizeTooSmallError extends BaseError {\n  constructor(_ref4) {\n    let {\n      data,\n      params,\n      size\n    } = _ref4;\n    super([\"Data size of \".concat(size, \" bytes is too small for given parameters.\")].join('\\n'), {\n      metaMessages: [\"Params: (\".concat(formatAbiParams(params, {\n        includeName: true\n      }), \")\"), \"Data:   \".concat(data, \" (\").concat(size, \" bytes)\")],\n      name: 'AbiDecodingDataSizeTooSmallError'\n    });\n    Object.defineProperty(this, \"data\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"params\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"size\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.data = data;\n    this.params = params;\n    this.size = size;\n  }\n}\nexport class AbiDecodingZeroDataError extends BaseError {\n  constructor() {\n    super('Cannot decode zero data (\"0x\") with ABI parameters.', {\n      name: 'AbiDecodingZeroDataError'\n    });\n  }\n}\nexport class AbiEncodingArrayLengthMismatchError extends BaseError {\n  constructor(_ref5) {\n    let {\n      expectedLength,\n      givenLength,\n      type\n    } = _ref5;\n    super([\"ABI encoding array length mismatch for type \".concat(type, \".\"), \"Expected length: \".concat(expectedLength), \"Given length: \".concat(givenLength)].join('\\n'), {\n      name: 'AbiEncodingArrayLengthMismatchError'\n    });\n  }\n}\nexport class AbiEncodingBytesSizeMismatchError extends BaseError {\n  constructor(_ref6) {\n    let {\n      expectedSize,\n      value\n    } = _ref6;\n    super(\"Size of bytes \\\"\".concat(value, \"\\\" (bytes\").concat(size(value), \") does not match expected size (bytes\").concat(expectedSize, \").\"), {\n      name: 'AbiEncodingBytesSizeMismatchError'\n    });\n  }\n}\nexport class AbiEncodingLengthMismatchError extends BaseError {\n  constructor(_ref7) {\n    let {\n      expectedLength,\n      givenLength\n    } = _ref7;\n    super(['ABI encoding params/values length mismatch.', \"Expected length (params): \".concat(expectedLength), \"Given length (values): \".concat(givenLength)].join('\\n'), {\n      name: 'AbiEncodingLengthMismatchError'\n    });\n  }\n}\nexport class AbiErrorInputsNotFoundError extends BaseError {\n  constructor(errorName, _ref8) {\n    let {\n      docsPath\n    } = _ref8;\n    super([\"Arguments (`args`) were provided to \\\"\".concat(errorName, \"\\\", but \\\"\").concat(errorName, \"\\\" on the ABI does not contain any parameters (`inputs`).\"), 'Cannot encode error result without knowing what the parameter types are.', 'Make sure you are using the correct ABI and that the inputs exist on it.'].join('\\n'), {\n      docsPath,\n      name: 'AbiErrorInputsNotFoundError'\n    });\n  }\n}\nexport class AbiErrorNotFoundError extends BaseError {\n  constructor(errorName) {\n    let {\n      docsPath\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super([\"Error \".concat(errorName ? \"\\\"\".concat(errorName, \"\\\" \") : '', \"not found on ABI.\"), 'Make sure you are using the correct ABI and that the error exists on it.'].join('\\n'), {\n      docsPath,\n      name: 'AbiErrorNotFoundError'\n    });\n  }\n}\nexport class AbiErrorSignatureNotFoundError extends BaseError {\n  constructor(signature, _ref9) {\n    let {\n      docsPath\n    } = _ref9;\n    super([\"Encoded error signature \\\"\".concat(signature, \"\\\" not found on ABI.\"), 'Make sure you are using the correct ABI and that the error exists on it.', \"You can look up the decoded signature here: https://openchain.xyz/signatures?query=\".concat(signature, \".\")].join('\\n'), {\n      docsPath,\n      name: 'AbiErrorSignatureNotFoundError'\n    });\n    Object.defineProperty(this, \"signature\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.signature = signature;\n  }\n}\nexport class AbiEventSignatureEmptyTopicsError extends BaseError {\n  constructor(_ref0) {\n    let {\n      docsPath\n    } = _ref0;\n    super('Cannot extract event signature from empty topics.', {\n      docsPath,\n      name: 'AbiEventSignatureEmptyTopicsError'\n    });\n  }\n}\nexport class AbiEventSignatureNotFoundError extends BaseError {\n  constructor(signature, _ref1) {\n    let {\n      docsPath\n    } = _ref1;\n    super([\"Encoded event signature \\\"\".concat(signature, \"\\\" not found on ABI.\"), 'Make sure you are using the correct ABI and that the event exists on it.', \"You can look up the signature here: https://openchain.xyz/signatures?query=\".concat(signature, \".\")].join('\\n'), {\n      docsPath,\n      name: 'AbiEventSignatureNotFoundError'\n    });\n  }\n}\nexport class AbiEventNotFoundError extends BaseError {\n  constructor(eventName) {\n    let {\n      docsPath\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super([\"Event \".concat(eventName ? \"\\\"\".concat(eventName, \"\\\" \") : '', \"not found on ABI.\"), 'Make sure you are using the correct ABI and that the event exists on it.'].join('\\n'), {\n      docsPath,\n      name: 'AbiEventNotFoundError'\n    });\n  }\n}\nexport class AbiFunctionNotFoundError extends BaseError {\n  constructor(functionName) {\n    let {\n      docsPath\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super([\"Function \".concat(functionName ? \"\\\"\".concat(functionName, \"\\\" \") : '', \"not found on ABI.\"), 'Make sure you are using the correct ABI and that the function exists on it.'].join('\\n'), {\n      docsPath,\n      name: 'AbiFunctionNotFoundError'\n    });\n  }\n}\nexport class AbiFunctionOutputsNotFoundError extends BaseError {\n  constructor(functionName, _ref10) {\n    let {\n      docsPath\n    } = _ref10;\n    super([\"Function \\\"\".concat(functionName, \"\\\" does not contain any `outputs` on ABI.\"), 'Cannot decode function result without knowing what the parameter types are.', 'Make sure you are using the correct ABI and that the function exists on it.'].join('\\n'), {\n      docsPath,\n      name: 'AbiFunctionOutputsNotFoundError'\n    });\n  }\n}\nexport class AbiFunctionSignatureNotFoundError extends BaseError {\n  constructor(signature, _ref11) {\n    let {\n      docsPath\n    } = _ref11;\n    super([\"Encoded function signature \\\"\".concat(signature, \"\\\" not found on ABI.\"), 'Make sure you are using the correct ABI and that the function exists on it.', \"You can look up the signature here: https://openchain.xyz/signatures?query=\".concat(signature, \".\")].join('\\n'), {\n      docsPath,\n      name: 'AbiFunctionSignatureNotFoundError'\n    });\n  }\n}\nexport class AbiItemAmbiguityError extends BaseError {\n  constructor(x, y) {\n    super('Found ambiguous types in overloaded ABI items.', {\n      metaMessages: [\"`\".concat(x.type, \"` in `\").concat(formatAbiItem(x.abiItem), \"`, and\"), \"`\".concat(y.type, \"` in `\").concat(formatAbiItem(y.abiItem), \"`\"), '', 'These types encode differently and cannot be distinguished at runtime.', 'Remove one of the ambiguous items in the ABI.'],\n      name: 'AbiItemAmbiguityError'\n    });\n  }\n}\nexport class BytesSizeMismatchError extends BaseError {\n  constructor(_ref12) {\n    let {\n      expectedSize,\n      givenSize\n    } = _ref12;\n    super(\"Expected bytes\".concat(expectedSize, \", got bytes\").concat(givenSize, \".\"), {\n      name: 'BytesSizeMismatchError'\n    });\n  }\n}\nexport class DecodeLogDataMismatch extends BaseError {\n  constructor(_ref13) {\n    let {\n      abiItem,\n      data,\n      params,\n      size\n    } = _ref13;\n    super([\"Data size of \".concat(size, \" bytes is too small for non-indexed event parameters.\")].join('\\n'), {\n      metaMessages: [\"Params: (\".concat(formatAbiParams(params, {\n        includeName: true\n      }), \")\"), \"Data:   \".concat(data, \" (\").concat(size, \" bytes)\")],\n      name: 'DecodeLogDataMismatch'\n    });\n    Object.defineProperty(this, \"abiItem\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"data\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"params\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"size\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.abiItem = abiItem;\n    this.data = data;\n    this.params = params;\n    this.size = size;\n  }\n}\nexport class DecodeLogTopicsMismatch extends BaseError {\n  constructor(_ref14) {\n    let {\n      abiItem,\n      param\n    } = _ref14;\n    super([\"Expected a topic for indexed event parameter\".concat(param.name ? \" \\\"\".concat(param.name, \"\\\"\") : '', \" on event \\\"\").concat(formatAbiItem(abiItem, {\n      includeName: true\n    }), \"\\\".\")].join('\\n'), {\n      name: 'DecodeLogTopicsMismatch'\n    });\n    Object.defineProperty(this, \"abiItem\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.abiItem = abiItem;\n  }\n}\nexport class InvalidAbiEncodingTypeError extends BaseError {\n  constructor(type, _ref15) {\n    let {\n      docsPath\n    } = _ref15;\n    super([\"Type \\\"\".concat(type, \"\\\" is not a valid encoding type.\"), 'Please provide a valid ABI type.'].join('\\n'), {\n      docsPath,\n      name: 'InvalidAbiEncodingType'\n    });\n  }\n}\nexport class InvalidAbiDecodingTypeError extends BaseError {\n  constructor(type, _ref16) {\n    let {\n      docsPath\n    } = _ref16;\n    super([\"Type \\\"\".concat(type, \"\\\" is not a valid decoding type.\"), 'Please provide a valid ABI type.'].join('\\n'), {\n      docsPath,\n      name: 'InvalidAbiDecodingType'\n    });\n  }\n}\nexport class InvalidArrayError extends BaseError {\n  constructor(value) {\n    super([\"Value \\\"\".concat(value, \"\\\" is not a valid array.\")].join('\\n'), {\n      name: 'InvalidArrayError'\n    });\n  }\n}\nexport class InvalidDefinitionTypeError extends BaseError {\n  constructor(type) {\n    super([\"\\\"\".concat(type, \"\\\" is not a valid definition type.\"), 'Valid types: \"function\", \"event\", \"error\"'].join('\\n'), {\n      name: 'InvalidDefinitionTypeError'\n    });\n  }\n}\nexport class UnsupportedPackedAbiType extends BaseError {\n  constructor(type) {\n    super(\"Type \\\"\".concat(type, \"\\\" is not supported for packed encoding.\"), {\n      name: 'UnsupportedPackedAbiType'\n    });\n  }\n}","map":{"version":3,"names":["formatAbiItem","formatAbiParams","size","BaseError","AbiConstructorNotFoundError","constructor","_ref","docsPath","join","name","AbiConstructorParamsNotFoundError","_ref2","AbiDecodingDataSizeInvalidError","_ref3","data","concat","metaMessages","AbiDecodingDataSizeTooSmallError","_ref4","params","includeName","Object","defineProperty","AbiDecodingZeroDataError","AbiEncodingArrayLengthMismatchError","_ref5","expectedLength","givenLength","type","AbiEncodingBytesSizeMismatchError","_ref6","expectedSize","value","AbiEncodingLengthMismatchError","_ref7","AbiErrorInputsNotFoundError","errorName","_ref8","AbiErrorNotFoundError","arguments","length","undefined","AbiErrorSignatureNotFoundError","signature","_ref9","AbiEventSignatureEmptyTopicsError","_ref0","AbiEventSignatureNotFoundError","_ref1","AbiEventNotFoundError","eventName","AbiFunctionNotFoundError","functionName","AbiFunctionOutputsNotFoundError","_ref10","AbiFunctionSignatureNotFoundError","_ref11","AbiItemAmbiguityError","x","y","abiItem","BytesSizeMismatchError","_ref12","givenSize","DecodeLogDataMismatch","_ref13","DecodeLogTopicsMismatch","_ref14","param","InvalidAbiEncodingTypeError","_ref15","InvalidAbiDecodingTypeError","_ref16","InvalidArrayError","InvalidDefinitionTypeError","UnsupportedPackedAbiType"],"sources":["/Users/mac/Desktop/topl1/frontend/node_modules/viem/errors/abi.ts"],"sourcesContent":["import type { Abi, AbiEvent, AbiParameter } from 'abitype'\n\nimport type { Hex } from '../types/misc.js'\nimport { formatAbiItem, formatAbiParams } from '../utils/abi/formatAbiItem.js'\nimport { size } from '../utils/data/size.js'\n\nimport { BaseError } from './base.js'\n\nexport type AbiConstructorNotFoundErrorType = AbiConstructorNotFoundError & {\n  name: 'AbiConstructorNotFoundError'\n}\nexport class AbiConstructorNotFoundError extends BaseError {\n  constructor({ docsPath }: { docsPath: string }) {\n    super(\n      [\n        'A constructor was not found on the ABI.',\n        'Make sure you are using the correct ABI and that the constructor exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiConstructorNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiConstructorParamsNotFoundErrorType =\n  AbiConstructorParamsNotFoundError & {\n    name: 'AbiConstructorParamsNotFoundError'\n  }\n\nexport class AbiConstructorParamsNotFoundError extends BaseError {\n  constructor({ docsPath }: { docsPath: string }) {\n    super(\n      [\n        'Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.',\n        'Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiConstructorParamsNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiDecodingDataSizeInvalidErrorType =\n  AbiDecodingDataSizeInvalidError & {\n    name: 'AbiDecodingDataSizeInvalidError'\n  }\nexport class AbiDecodingDataSizeInvalidError extends BaseError {\n  constructor({ data, size }: { data: Hex; size: number }) {\n    super(\n      [\n        `Data size of ${size} bytes is invalid.`,\n        'Size must be in increments of 32 bytes (size % 32 === 0).',\n      ].join('\\n'),\n      {\n        metaMessages: [`Data: ${data} (${size} bytes)`],\n        name: 'AbiDecodingDataSizeInvalidError',\n      },\n    )\n  }\n}\n\nexport type AbiDecodingDataSizeTooSmallErrorType =\n  AbiDecodingDataSizeTooSmallError & {\n    name: 'AbiDecodingDataSizeTooSmallError'\n  }\nexport class AbiDecodingDataSizeTooSmallError extends BaseError {\n  data: Hex\n  params: readonly AbiParameter[]\n  size: number\n\n  constructor({\n    data,\n    params,\n    size,\n  }: { data: Hex; params: readonly AbiParameter[]; size: number }) {\n    super(\n      [`Data size of ${size} bytes is too small for given parameters.`].join(\n        '\\n',\n      ),\n      {\n        metaMessages: [\n          `Params: (${formatAbiParams(params, { includeName: true })})`,\n          `Data:   ${data} (${size} bytes)`,\n        ],\n        name: 'AbiDecodingDataSizeTooSmallError',\n      },\n    )\n\n    this.data = data\n    this.params = params\n    this.size = size\n  }\n}\n\nexport type AbiDecodingZeroDataErrorType = AbiDecodingZeroDataError & {\n  name: 'AbiDecodingZeroDataError'\n}\nexport class AbiDecodingZeroDataError extends BaseError {\n  constructor() {\n    super('Cannot decode zero data (\"0x\") with ABI parameters.', {\n      name: 'AbiDecodingZeroDataError',\n    })\n  }\n}\n\nexport type AbiEncodingArrayLengthMismatchErrorType =\n  AbiEncodingArrayLengthMismatchError & {\n    name: 'AbiEncodingArrayLengthMismatchError'\n  }\nexport class AbiEncodingArrayLengthMismatchError extends BaseError {\n  constructor({\n    expectedLength,\n    givenLength,\n    type,\n  }: { expectedLength: number; givenLength: number; type: string }) {\n    super(\n      [\n        `ABI encoding array length mismatch for type ${type}.`,\n        `Expected length: ${expectedLength}`,\n        `Given length: ${givenLength}`,\n      ].join('\\n'),\n      { name: 'AbiEncodingArrayLengthMismatchError' },\n    )\n  }\n}\n\nexport type AbiEncodingBytesSizeMismatchErrorType =\n  AbiEncodingBytesSizeMismatchError & {\n    name: 'AbiEncodingBytesSizeMismatchError'\n  }\nexport class AbiEncodingBytesSizeMismatchError extends BaseError {\n  constructor({ expectedSize, value }: { expectedSize: number; value: Hex }) {\n    super(\n      `Size of bytes \"${value}\" (bytes${size(\n        value,\n      )}) does not match expected size (bytes${expectedSize}).`,\n      { name: 'AbiEncodingBytesSizeMismatchError' },\n    )\n  }\n}\n\nexport type AbiEncodingLengthMismatchErrorType =\n  AbiEncodingLengthMismatchError & {\n    name: 'AbiEncodingLengthMismatchError'\n  }\nexport class AbiEncodingLengthMismatchError extends BaseError {\n  constructor({\n    expectedLength,\n    givenLength,\n  }: { expectedLength: number; givenLength: number }) {\n    super(\n      [\n        'ABI encoding params/values length mismatch.',\n        `Expected length (params): ${expectedLength}`,\n        `Given length (values): ${givenLength}`,\n      ].join('\\n'),\n      { name: 'AbiEncodingLengthMismatchError' },\n    )\n  }\n}\n\nexport type AbiErrorInputsNotFoundErrorType = AbiErrorInputsNotFoundError & {\n  name: 'AbiErrorInputsNotFoundError'\n}\nexport class AbiErrorInputsNotFoundError extends BaseError {\n  constructor(errorName: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Arguments (\\`args\\`) were provided to \"${errorName}\", but \"${errorName}\" on the ABI does not contain any parameters (\\`inputs\\`).`,\n        'Cannot encode error result without knowing what the parameter types are.',\n        'Make sure you are using the correct ABI and that the inputs exist on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiErrorInputsNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiErrorNotFoundErrorType = AbiErrorNotFoundError & {\n  name: 'AbiErrorNotFoundError'\n}\nexport class AbiErrorNotFoundError extends BaseError {\n  constructor(\n    errorName?: string | undefined,\n    { docsPath }: { docsPath?: string | undefined } = {},\n  ) {\n    super(\n      [\n        `Error ${errorName ? `\"${errorName}\" ` : ''}not found on ABI.`,\n        'Make sure you are using the correct ABI and that the error exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiErrorNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiErrorSignatureNotFoundErrorType =\n  AbiErrorSignatureNotFoundError & {\n    name: 'AbiErrorSignatureNotFoundError'\n  }\nexport class AbiErrorSignatureNotFoundError extends BaseError {\n  signature: Hex\n\n  constructor(signature: Hex, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Encoded error signature \"${signature}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the error exists on it.',\n        `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`,\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiErrorSignatureNotFoundError',\n      },\n    )\n    this.signature = signature\n  }\n}\n\nexport type AbiEventSignatureEmptyTopicsErrorType =\n  AbiEventSignatureEmptyTopicsError & {\n    name: 'AbiEventSignatureEmptyTopicsError'\n  }\nexport class AbiEventSignatureEmptyTopicsError extends BaseError {\n  constructor({ docsPath }: { docsPath: string }) {\n    super('Cannot extract event signature from empty topics.', {\n      docsPath,\n      name: 'AbiEventSignatureEmptyTopicsError',\n    })\n  }\n}\n\nexport type AbiEventSignatureNotFoundErrorType =\n  AbiEventSignatureNotFoundError & {\n    name: 'AbiEventSignatureNotFoundError'\n  }\nexport class AbiEventSignatureNotFoundError extends BaseError {\n  constructor(signature: Hex, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Encoded event signature \"${signature}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the event exists on it.',\n        `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiEventSignatureNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiEventNotFoundErrorType = AbiEventNotFoundError & {\n  name: 'AbiEventNotFoundError'\n}\nexport class AbiEventNotFoundError extends BaseError {\n  constructor(\n    eventName?: string | undefined,\n    { docsPath }: { docsPath?: string | undefined } = {},\n  ) {\n    super(\n      [\n        `Event ${eventName ? `\"${eventName}\" ` : ''}not found on ABI.`,\n        'Make sure you are using the correct ABI and that the event exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiEventNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiFunctionNotFoundErrorType = AbiFunctionNotFoundError & {\n  name: 'AbiFunctionNotFoundError'\n}\nexport class AbiFunctionNotFoundError extends BaseError {\n  constructor(\n    functionName?: string | undefined,\n    { docsPath }: { docsPath?: string | undefined } = {},\n  ) {\n    super(\n      [\n        `Function ${functionName ? `\"${functionName}\" ` : ''}not found on ABI.`,\n        'Make sure you are using the correct ABI and that the function exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiFunctionNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiFunctionOutputsNotFoundErrorType =\n  AbiFunctionOutputsNotFoundError & {\n    name: 'AbiFunctionOutputsNotFoundError'\n  }\nexport class AbiFunctionOutputsNotFoundError extends BaseError {\n  constructor(functionName: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Function \"${functionName}\" does not contain any \\`outputs\\` on ABI.`,\n        'Cannot decode function result without knowing what the parameter types are.',\n        'Make sure you are using the correct ABI and that the function exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiFunctionOutputsNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiFunctionSignatureNotFoundErrorType =\n  AbiFunctionSignatureNotFoundError & {\n    name: 'AbiFunctionSignatureNotFoundError'\n  }\nexport class AbiFunctionSignatureNotFoundError extends BaseError {\n  constructor(signature: Hex, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Encoded function signature \"${signature}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the function exists on it.',\n        `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiFunctionSignatureNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiItemAmbiguityErrorType = AbiItemAmbiguityError & {\n  name: 'AbiItemAmbiguityError'\n}\nexport class AbiItemAmbiguityError extends BaseError {\n  constructor(\n    x: { abiItem: Abi[number]; type: string },\n    y: { abiItem: Abi[number]; type: string },\n  ) {\n    super('Found ambiguous types in overloaded ABI items.', {\n      metaMessages: [\n        `\\`${x.type}\\` in \\`${formatAbiItem(x.abiItem)}\\`, and`,\n        `\\`${y.type}\\` in \\`${formatAbiItem(y.abiItem)}\\``,\n        '',\n        'These types encode differently and cannot be distinguished at runtime.',\n        'Remove one of the ambiguous items in the ABI.',\n      ],\n      name: 'AbiItemAmbiguityError',\n    })\n  }\n}\n\nexport type BytesSizeMismatchErrorType = BytesSizeMismatchError & {\n  name: 'BytesSizeMismatchError'\n}\nexport class BytesSizeMismatchError extends BaseError {\n  constructor({\n    expectedSize,\n    givenSize,\n  }: { expectedSize: number; givenSize: number }) {\n    super(`Expected bytes${expectedSize}, got bytes${givenSize}.`, {\n      name: 'BytesSizeMismatchError',\n    })\n  }\n}\n\nexport type DecodeLogDataMismatchErrorType = DecodeLogDataMismatch & {\n  name: 'DecodeLogDataMismatch'\n}\nexport class DecodeLogDataMismatch extends BaseError {\n  abiItem: AbiEvent\n  data: Hex\n  params: readonly AbiParameter[]\n  size: number\n\n  constructor({\n    abiItem,\n    data,\n    params,\n    size,\n  }: {\n    abiItem: AbiEvent\n    data: Hex\n    params: readonly AbiParameter[]\n    size: number\n  }) {\n    super(\n      [\n        `Data size of ${size} bytes is too small for non-indexed event parameters.`,\n      ].join('\\n'),\n      {\n        metaMessages: [\n          `Params: (${formatAbiParams(params, { includeName: true })})`,\n          `Data:   ${data} (${size} bytes)`,\n        ],\n        name: 'DecodeLogDataMismatch',\n      },\n    )\n\n    this.abiItem = abiItem\n    this.data = data\n    this.params = params\n    this.size = size\n  }\n}\n\nexport type DecodeLogTopicsMismatchErrorType = DecodeLogTopicsMismatch & {\n  name: 'DecodeLogTopicsMismatch'\n}\nexport class DecodeLogTopicsMismatch extends BaseError {\n  abiItem: AbiEvent\n\n  constructor({\n    abiItem,\n    param,\n  }: {\n    abiItem: AbiEvent\n    param: AbiParameter & { indexed: boolean }\n  }) {\n    super(\n      [\n        `Expected a topic for indexed event parameter${\n          param.name ? ` \"${param.name}\"` : ''\n        } on event \"${formatAbiItem(abiItem, { includeName: true })}\".`,\n      ].join('\\n'),\n      { name: 'DecodeLogTopicsMismatch' },\n    )\n\n    this.abiItem = abiItem\n  }\n}\n\nexport type InvalidAbiEncodingTypeErrorType = InvalidAbiEncodingTypeError & {\n  name: 'InvalidAbiEncodingTypeError'\n}\nexport class InvalidAbiEncodingTypeError extends BaseError {\n  constructor(type: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Type \"${type}\" is not a valid encoding type.`,\n        'Please provide a valid ABI type.',\n      ].join('\\n'),\n      { docsPath, name: 'InvalidAbiEncodingType' },\n    )\n  }\n}\n\nexport type InvalidAbiDecodingTypeErrorType = InvalidAbiDecodingTypeError & {\n  name: 'InvalidAbiDecodingTypeError'\n}\nexport class InvalidAbiDecodingTypeError extends BaseError {\n  constructor(type: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Type \"${type}\" is not a valid decoding type.`,\n        'Please provide a valid ABI type.',\n      ].join('\\n'),\n      { docsPath, name: 'InvalidAbiDecodingType' },\n    )\n  }\n}\n\nexport type InvalidArrayErrorType = InvalidArrayError & {\n  name: 'InvalidArrayError'\n}\nexport class InvalidArrayError extends BaseError {\n  constructor(value: unknown) {\n    super([`Value \"${value}\" is not a valid array.`].join('\\n'), {\n      name: 'InvalidArrayError',\n    })\n  }\n}\n\nexport type InvalidDefinitionTypeErrorType = InvalidDefinitionTypeError & {\n  name: 'InvalidDefinitionTypeError'\n}\nexport class InvalidDefinitionTypeError extends BaseError {\n  constructor(type: string) {\n    super(\n      [\n        `\"${type}\" is not a valid definition type.`,\n        'Valid types: \"function\", \"event\", \"error\"',\n      ].join('\\n'),\n      { name: 'InvalidDefinitionTypeError' },\n    )\n  }\n}\n\nexport type UnsupportedPackedAbiTypeErrorType = UnsupportedPackedAbiType & {\n  name: 'UnsupportedPackedAbiType'\n}\nexport class UnsupportedPackedAbiType extends BaseError {\n  constructor(type: unknown) {\n    super(`Type \"${type}\" is not supported for packed encoding.`, {\n      name: 'UnsupportedPackedAbiType',\n    })\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}