{"ast":null,"code":"// TODO(v3): checksum address.\nimport { isAddressEqual } from '../address/isAddressEqual.js';\nimport { toBytes } from '../encoding/toBytes.js';\nimport { keccak256 } from '../hash/keccak256.js';\nimport { toEventSelector } from '../hash/toEventSelector.js';\nimport { decodeEventLog } from './decodeEventLog.js';\n/**\n * Extracts & decodes logs matching the provided signature(s) (`abi` + optional `eventName`)\n * from a set of opaque logs.\n *\n * @param parameters - {@link ParseEventLogsParameters}\n * @returns The logs. {@link ParseEventLogsReturnType}\n *\n * @example\n * import { createClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { parseEventLogs } from 'viem/op-stack'\n *\n * const client = createClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const receipt = await getTransactionReceipt(client, {\n *   hash: '0xec23b2ba4bc59ba61554507c1b1bc91649e6586eb2dd00c728e8ed0db8bb37ea',\n * })\n *\n * const logs = parseEventLogs({ logs: receipt.logs })\n * // [{ args: { ... }, eventName: 'TransactionDeposited', ... }, ...]\n */\nexport function parseEventLogs(parameters) {\n  const {\n    abi,\n    args,\n    logs,\n    strict = true\n  } = parameters;\n  const eventName = (() => {\n    if (!parameters.eventName) return undefined;\n    if (Array.isArray(parameters.eventName)) return parameters.eventName;\n    return [parameters.eventName];\n  })();\n  return logs.map(log => {\n    // Find all matching ABI items with the same selector.\n    // Multiple events can share the same selector but differ in indexed parameters\n    // (e.g., ERC20 vs ERC721 Transfer events).\n    const abiItems = abi.filter(abiItem => abiItem.type === 'event' && log.topics[0] === toEventSelector(abiItem));\n    if (abiItems.length === 0) return null;\n    // Try each matching ABI item until one successfully decodes.\n    let event;\n    let abiItem;\n    for (const item of abiItems) {\n      try {\n        event = decodeEventLog({\n          ...log,\n          abi: [item],\n          strict: true\n        });\n        abiItem = item;\n        break;\n      } catch {\n        // Try next ABI item\n      }\n    }\n    // If strict decoding failed for all, and we're in non-strict mode,\n    // fall back to the first matching ABI item.\n    if (!event && !strict) {\n      abiItem = abiItems[0];\n      try {\n        event = decodeEventLog({\n          ...log,\n          abi: [abiItem],\n          strict: false\n        });\n      } catch {\n        // If decoding still fails, return partial log in non-strict mode.\n        const isUnnamed = abiItem.inputs?.some(x => !('name' in x && x.name));\n        return {\n          ...log,\n          args: isUnnamed ? [] : {},\n          eventName: abiItem.name\n        };\n      }\n    }\n    // If no event was found, return null.\n    if (!event || !abiItem) return null;\n    // Check that the decoded event name matches the provided event name.\n    if (eventName && !eventName.includes(event.eventName)) return null;\n    // Check that the decoded event args match the provided args.\n    if (!includesArgs({\n      args: event.args,\n      inputs: abiItem.inputs,\n      matchArgs: args\n    })) return null;\n    return {\n      ...event,\n      ...log\n    };\n  }).filter(Boolean);\n}\nfunction includesArgs(parameters) {\n  const {\n    args,\n    inputs,\n    matchArgs\n  } = parameters;\n  if (!matchArgs) return true;\n  if (!args) return false;\n  function isEqual(input, value, arg) {\n    try {\n      if (input.type === 'address') return isAddressEqual(value, arg);\n      if (input.type === 'string' || input.type === 'bytes') return keccak256(toBytes(value)) === arg;\n      return value === arg;\n    } catch {\n      return false;\n    }\n  }\n  if (Array.isArray(args) && Array.isArray(matchArgs)) {\n    return matchArgs.every((value, index) => {\n      if (value === null || value === undefined) return true;\n      const input = inputs[index];\n      if (!input) return false;\n      const value_ = Array.isArray(value) ? value : [value];\n      return value_.some(value => isEqual(input, value, args[index]));\n    });\n  }\n  if (typeof args === 'object' && !Array.isArray(args) && typeof matchArgs === 'object' && !Array.isArray(matchArgs)) return Object.entries(matchArgs).every(([key, value]) => {\n    if (value === null || value === undefined) return true;\n    const input = inputs.find(input => input.name === key);\n    if (!input) return false;\n    const value_ = Array.isArray(value) ? value : [value];\n    return value_.some(value => isEqual(input, value, args[key]));\n  });\n  return false;\n}","map":{"version":3,"names":["isAddressEqual","toBytes","keccak256","toEventSelector","decodeEventLog","parseEventLogs","parameters","abi","args","logs","strict","eventName","undefined","Array","isArray","map","log","abiItems","filter","abiItem","type","topics","length","event","item","isUnnamed","inputs","some","x","name","includes","includesArgs","matchArgs","Boolean","isEqual","input","value","arg","every","index","value_","Object","entries","key","find"],"sources":["/Users/mac/Desktop/topl1/frontend/node_modules/viem/utils/abi/parseEventLogs.ts"],"sourcesContent":["// TODO(v3): checksum address.\n\nimport type { Abi, AbiEvent, AbiEventParameter, Address } from 'abitype'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ContractEventName, GetEventArgs } from '../../types/contract.js'\nimport type { Log } from '../../types/log.js'\nimport type { RpcLog } from '../../types/rpc.js'\nimport { isAddressEqual } from '../address/isAddressEqual.js'\nimport { toBytes } from '../encoding/toBytes.js'\nimport { keccak256 } from '../hash/keccak256.js'\nimport { toEventSelector } from '../hash/toEventSelector.js'\nimport {\n  type DecodeEventLogErrorType,\n  decodeEventLog,\n} from './decodeEventLog.js'\n\nexport type ParseEventLogsParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends\n    | ContractEventName<abi>\n    | ContractEventName<abi>[]\n    | undefined = ContractEventName<abi>,\n  strict extends boolean | undefined = boolean | undefined,\n  ///\n  allArgs = GetEventArgs<\n    abi,\n    eventName extends ContractEventName<abi>\n      ? eventName\n      : ContractEventName<abi>,\n    {\n      EnableUnion: true\n      IndexedOnly: false\n      Required: false\n    }\n  >,\n> = {\n  /** Contract ABI. */\n  abi: abi\n  /** Arguments for the event. */\n  args?: allArgs | undefined\n  /** Contract event. */\n  eventName?:\n    | eventName\n    | ContractEventName<abi>\n    | ContractEventName<abi>[]\n    | undefined\n  /** List of logs. */\n  logs: (Log | RpcLog)[]\n  strict?: strict | boolean | undefined\n}\n\nexport type ParseEventLogsReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends\n    | ContractEventName<abi>\n    | ContractEventName<abi>[]\n    | undefined = ContractEventName<abi>,\n  strict extends boolean | undefined = boolean | undefined,\n  ///\n  derivedEventName extends\n    | ContractEventName<abi>\n    | undefined = eventName extends ContractEventName<abi>[]\n    ? eventName[number]\n    : eventName,\n> = Log<bigint, number, false, undefined, strict, abi, derivedEventName>[]\n\nexport type ParseEventLogsErrorType = DecodeEventLogErrorType | ErrorType\n\n/**\n * Extracts & decodes logs matching the provided signature(s) (`abi` + optional `eventName`)\n * from a set of opaque logs.\n *\n * @param parameters - {@link ParseEventLogsParameters}\n * @returns The logs. {@link ParseEventLogsReturnType}\n *\n * @example\n * import { createClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { parseEventLogs } from 'viem/op-stack'\n *\n * const client = createClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const receipt = await getTransactionReceipt(client, {\n *   hash: '0xec23b2ba4bc59ba61554507c1b1bc91649e6586eb2dd00c728e8ed0db8bb37ea',\n * })\n *\n * const logs = parseEventLogs({ logs: receipt.logs })\n * // [{ args: { ... }, eventName: 'TransactionDeposited', ... }, ...]\n */\nexport function parseEventLogs<\n  abi extends Abi | readonly unknown[],\n  strict extends boolean | undefined = true,\n  eventName extends\n    | ContractEventName<abi>\n    | ContractEventName<abi>[]\n    | undefined = undefined,\n>(\n  parameters: ParseEventLogsParameters<abi, eventName, strict>,\n): ParseEventLogsReturnType<abi, eventName, strict> {\n  const { abi, args, logs, strict = true } = parameters\n\n  const eventName = (() => {\n    if (!parameters.eventName) return undefined\n    if (Array.isArray(parameters.eventName)) return parameters.eventName\n    return [parameters.eventName as string]\n  })()\n\n  return logs\n    .map((log) => {\n      // Find all matching ABI items with the same selector.\n      // Multiple events can share the same selector but differ in indexed parameters\n      // (e.g., ERC20 vs ERC721 Transfer events).\n      const abiItems = (abi as Abi).filter(\n        (abiItem) =>\n          abiItem.type === 'event' &&\n          log.topics[0] === toEventSelector(abiItem),\n      ) as AbiEvent[]\n      if (abiItems.length === 0) return null\n\n      // Try each matching ABI item until one successfully decodes.\n      let event: { eventName: string; args: unknown } | undefined\n      let abiItem: AbiEvent | undefined\n\n      for (const item of abiItems) {\n        try {\n          event = decodeEventLog({\n            ...log,\n            abi: [item],\n            strict: true,\n          })\n          abiItem = item\n          break\n        } catch {\n          // Try next ABI item\n        }\n      }\n\n      // If strict decoding failed for all, and we're in non-strict mode,\n      // fall back to the first matching ABI item.\n      if (!event && !strict) {\n        abiItem = abiItems[0]\n        try {\n          event = decodeEventLog({\n            ...log,\n            abi: [abiItem],\n            strict: false,\n          })\n        } catch {\n          // If decoding still fails, return partial log in non-strict mode.\n          const isUnnamed = abiItem.inputs?.some(\n            (x) => !('name' in x && x.name),\n          )\n          return {\n            ...log,\n            args: isUnnamed ? [] : {},\n            eventName: abiItem.name,\n          }\n        }\n      }\n\n      // If no event was found, return null.\n      if (!event || !abiItem) return null\n\n      // Check that the decoded event name matches the provided event name.\n      if (eventName && !eventName.includes(event.eventName)) return null\n\n      // Check that the decoded event args match the provided args.\n      if (\n        !includesArgs({\n          args: event.args,\n          inputs: abiItem.inputs,\n          matchArgs: args,\n        })\n      )\n        return null\n\n      return { ...event, ...log }\n    })\n    .filter(Boolean) as unknown as ParseEventLogsReturnType<\n    abi,\n    eventName,\n    strict\n  >\n}\n\nfunction includesArgs(parameters: {\n  args: unknown\n  inputs: AbiEvent['inputs']\n  matchArgs: unknown\n}) {\n  const { args, inputs, matchArgs } = parameters\n\n  if (!matchArgs) return true\n  if (!args) return false\n\n  function isEqual(input: AbiEventParameter, value: unknown, arg: unknown) {\n    try {\n      if (input.type === 'address')\n        return isAddressEqual(value as Address, arg as Address)\n      if (input.type === 'string' || input.type === 'bytes')\n        return keccak256(toBytes(value as string)) === arg\n      return value === arg\n    } catch {\n      return false\n    }\n  }\n\n  if (Array.isArray(args) && Array.isArray(matchArgs)) {\n    return matchArgs.every((value, index) => {\n      if (value === null || value === undefined) return true\n      const input = inputs[index]\n      if (!input) return false\n      const value_ = Array.isArray(value) ? value : [value]\n      return value_.some((value) => isEqual(input, value, args[index]))\n    })\n  }\n\n  if (\n    typeof args === 'object' &&\n    !Array.isArray(args) &&\n    typeof matchArgs === 'object' &&\n    !Array.isArray(matchArgs)\n  )\n    return Object.entries(matchArgs).every(([key, value]) => {\n      if (value === null || value === undefined) return true\n      const input = inputs.find((input) => input.name === key)\n      if (!input) return false\n      const value_ = Array.isArray(value) ? value : [value]\n      return value_.some((value) =>\n        isEqual(input, value, (args as Record<string, unknown>)[key]),\n      )\n    })\n\n  return false\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}