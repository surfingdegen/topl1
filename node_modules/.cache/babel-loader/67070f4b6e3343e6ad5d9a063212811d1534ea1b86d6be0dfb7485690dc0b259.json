{"ast":null,"code":"import _objectSpread from \"/Users/mac/Desktop/topl1/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _wrapRegExp from \"/Users/mac/Desktop/topl1/frontend/node_modules/@babel/runtime/helpers/esm/wrapRegExp.js\";\nimport { bytesRegex, execTyped, integerRegex, isTupleRegex } from '../../regex.js';\nimport { UnknownSolidityTypeError } from '../errors/abiItem.js';\nimport { InvalidFunctionModifierError, InvalidModifierError, InvalidParameterError, SolidityProtectedKeywordError } from '../errors/abiParameter.js';\nimport { InvalidSignatureError, UnknownSignatureError } from '../errors/signature.js';\nimport { InvalidParenthesisError } from '../errors/splitParameters.js';\nimport { getParameterCacheKey, parameterCache } from './cache.js';\nimport { eventModifiers, execConstructorSignature, execErrorSignature, execEventSignature, execFallbackSignature, execFunctionSignature, functionModifiers, isConstructorSignature, isErrorSignature, isEventSignature, isFallbackSignature, isFunctionSignature, isReceiveSignature } from './signatures.js';\nexport function parseSignature(signature) {\n  let structs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (isFunctionSignature(signature)) return parseFunctionSignature(signature, structs);\n  if (isEventSignature(signature)) return parseEventSignature(signature, structs);\n  if (isErrorSignature(signature)) return parseErrorSignature(signature, structs);\n  if (isConstructorSignature(signature)) return parseConstructorSignature(signature, structs);\n  if (isFallbackSignature(signature)) return parseFallbackSignature(signature);\n  if (isReceiveSignature(signature)) return {\n    type: 'receive',\n    stateMutability: 'payable'\n  };\n  throw new UnknownSignatureError({\n    signature\n  });\n}\nexport function parseFunctionSignature(signature) {\n  var _match$stateMutabilit;\n  let structs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const match = execFunctionSignature(signature);\n  if (!match) throw new InvalidSignatureError({\n    signature,\n    type: 'function'\n  });\n  const inputParams = splitParameters(match.parameters);\n  const inputs = [];\n  const inputLength = inputParams.length;\n  for (let i = 0; i < inputLength; i++) {\n    inputs.push(parseAbiParameter(inputParams[i], {\n      modifiers: functionModifiers,\n      structs,\n      type: 'function'\n    }));\n  }\n  const outputs = [];\n  if (match.returns) {\n    const outputParams = splitParameters(match.returns);\n    const outputLength = outputParams.length;\n    for (let i = 0; i < outputLength; i++) {\n      outputs.push(parseAbiParameter(outputParams[i], {\n        modifiers: functionModifiers,\n        structs,\n        type: 'function'\n      }));\n    }\n  }\n  return {\n    name: match.name,\n    type: 'function',\n    stateMutability: (_match$stateMutabilit = match.stateMutability) !== null && _match$stateMutabilit !== void 0 ? _match$stateMutabilit : 'nonpayable',\n    inputs,\n    outputs\n  };\n}\nexport function parseEventSignature(signature) {\n  let structs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const match = execEventSignature(signature);\n  if (!match) throw new InvalidSignatureError({\n    signature,\n    type: 'event'\n  });\n  const params = splitParameters(match.parameters);\n  const abiParameters = [];\n  const length = params.length;\n  for (let i = 0; i < length; i++) abiParameters.push(parseAbiParameter(params[i], {\n    modifiers: eventModifiers,\n    structs,\n    type: 'event'\n  }));\n  return {\n    name: match.name,\n    type: 'event',\n    inputs: abiParameters\n  };\n}\nexport function parseErrorSignature(signature) {\n  let structs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const match = execErrorSignature(signature);\n  if (!match) throw new InvalidSignatureError({\n    signature,\n    type: 'error'\n  });\n  const params = splitParameters(match.parameters);\n  const abiParameters = [];\n  const length = params.length;\n  for (let i = 0; i < length; i++) abiParameters.push(parseAbiParameter(params[i], {\n    structs,\n    type: 'error'\n  }));\n  return {\n    name: match.name,\n    type: 'error',\n    inputs: abiParameters\n  };\n}\nexport function parseConstructorSignature(signature) {\n  var _match$stateMutabilit2;\n  let structs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const match = execConstructorSignature(signature);\n  if (!match) throw new InvalidSignatureError({\n    signature,\n    type: 'constructor'\n  });\n  const params = splitParameters(match.parameters);\n  const abiParameters = [];\n  const length = params.length;\n  for (let i = 0; i < length; i++) abiParameters.push(parseAbiParameter(params[i], {\n    structs,\n    type: 'constructor'\n  }));\n  return {\n    type: 'constructor',\n    stateMutability: (_match$stateMutabilit2 = match.stateMutability) !== null && _match$stateMutabilit2 !== void 0 ? _match$stateMutabilit2 : 'nonpayable',\n    inputs: abiParameters\n  };\n}\nexport function parseFallbackSignature(signature) {\n  var _match$stateMutabilit3;\n  const match = execFallbackSignature(signature);\n  if (!match) throw new InvalidSignatureError({\n    signature,\n    type: 'fallback'\n  });\n  return {\n    type: 'fallback',\n    stateMutability: (_match$stateMutabilit3 = match.stateMutability) !== null && _match$stateMutabilit3 !== void 0 ? _match$stateMutabilit3 : 'nonpayable'\n  };\n}\nconst abiParameterWithoutTupleRegex = /*#__PURE__*/_wrapRegExp(/^([a-zA-Z$_][a-zA-Z0-9$_]*(?:\\spayable)?)((?:\\[\\d*?\\])+?)?(?:\\s(calldata|indexed|memory|storage{1}))?(?:\\s([a-zA-Z$_][a-zA-Z0-9$_]*))?$/, {\n  type: 1,\n  array: 2,\n  modifier: 3,\n  name: 4\n});\nconst abiParameterWithTupleRegex = /*#__PURE__*/_wrapRegExp(/^\\((.+?)\\)((?:\\[\\d*?\\])+?)?(?:\\s(calldata|indexed|memory|storage{1}))?(?:\\s([a-zA-Z$_][a-zA-Z0-9$_]*))?$/, {\n  type: 1,\n  array: 2,\n  modifier: 3,\n  name: 4\n});\nconst dynamicIntegerRegex = /^u?int$/;\nexport function parseAbiParameter(param, options) {\n  var _options$structs, _match$array;\n  // optional namespace cache by `type`\n  const parameterCacheKey = getParameterCacheKey(param, options === null || options === void 0 ? void 0 : options.type, options === null || options === void 0 ? void 0 : options.structs);\n  if (parameterCache.has(parameterCacheKey)) return parameterCache.get(parameterCacheKey);\n  const isTuple = isTupleRegex.test(param);\n  const match = execTyped(isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex, param);\n  if (!match) throw new InvalidParameterError({\n    param\n  });\n  if (match.name && isSolidityKeyword(match.name)) throw new SolidityProtectedKeywordError({\n    param,\n    name: match.name\n  });\n  const name = match.name ? {\n    name: match.name\n  } : {};\n  const indexed = match.modifier === 'indexed' ? {\n    indexed: true\n  } : {};\n  const structs = (_options$structs = options === null || options === void 0 ? void 0 : options.structs) !== null && _options$structs !== void 0 ? _options$structs : {};\n  let type;\n  let components = {};\n  if (isTuple) {\n    type = 'tuple';\n    const params = splitParameters(match.type);\n    const components_ = [];\n    const length = params.length;\n    for (let i = 0; i < length; i++) {\n      // remove `modifiers` from `options` to prevent from being added to tuple components\n      components_.push(parseAbiParameter(params[i], {\n        structs\n      }));\n    }\n    components = {\n      components: components_\n    };\n  } else if (match.type in structs) {\n    type = 'tuple';\n    components = {\n      components: structs[match.type]\n    };\n  } else if (dynamicIntegerRegex.test(match.type)) {\n    type = \"\".concat(match.type, \"256\");\n  } else if (match.type === 'address payable') {\n    type = 'address';\n  } else {\n    type = match.type;\n    if (!((options === null || options === void 0 ? void 0 : options.type) === 'struct') && !isSolidityType(type)) throw new UnknownSolidityTypeError({\n      type\n    });\n  }\n  if (match.modifier) {\n    var _options$modifiers, _options$modifiers$ha;\n    // Check if modifier exists, but is not allowed (e.g. `indexed` in `functionModifiers`)\n    if (!(options !== null && options !== void 0 && (_options$modifiers = options.modifiers) !== null && _options$modifiers !== void 0 && (_options$modifiers$ha = _options$modifiers.has) !== null && _options$modifiers$ha !== void 0 && _options$modifiers$ha.call(_options$modifiers, match.modifier))) throw new InvalidModifierError({\n      param,\n      type: options === null || options === void 0 ? void 0 : options.type,\n      modifier: match.modifier\n    });\n    // Check if resolved `type` is valid if there is a function modifier\n    if (functionModifiers.has(match.modifier) && !isValidDataLocation(type, !!match.array)) throw new InvalidFunctionModifierError({\n      param,\n      type: options === null || options === void 0 ? void 0 : options.type,\n      modifier: match.modifier\n    });\n  }\n  const abiParameter = _objectSpread(_objectSpread(_objectSpread({\n    type: \"\".concat(type).concat((_match$array = match.array) !== null && _match$array !== void 0 ? _match$array : '')\n  }, name), indexed), components);\n  parameterCache.set(parameterCacheKey, abiParameter);\n  return abiParameter;\n}\n// s/o latika for this\nexport function splitParameters(params) {\n  let result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let current = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  let depth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  const length = params.trim().length;\n  // biome-ignore lint/correctness/noUnreachable: recursive\n  for (let i = 0; i < length; i++) {\n    const char = params[i];\n    const tail = params.slice(i + 1);\n    switch (char) {\n      case ',':\n        return depth === 0 ? splitParameters(tail, [...result, current.trim()]) : splitParameters(tail, result, \"\".concat(current).concat(char), depth);\n      case '(':\n        return splitParameters(tail, result, \"\".concat(current).concat(char), depth + 1);\n      case ')':\n        return splitParameters(tail, result, \"\".concat(current).concat(char), depth - 1);\n      default:\n        return splitParameters(tail, result, \"\".concat(current).concat(char), depth);\n    }\n  }\n  if (current === '') return result;\n  if (depth !== 0) throw new InvalidParenthesisError({\n    current,\n    depth\n  });\n  result.push(current.trim());\n  return result;\n}\nexport function isSolidityType(type) {\n  return type === 'address' || type === 'bool' || type === 'function' || type === 'string' || bytesRegex.test(type) || integerRegex.test(type);\n}\nconst protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;\n/** @internal */\nexport function isSolidityKeyword(name) {\n  return name === 'address' || name === 'bool' || name === 'function' || name === 'string' || name === 'tuple' || bytesRegex.test(name) || integerRegex.test(name) || protectedKeywordsRegex.test(name);\n}\n/** @internal */\nexport function isValidDataLocation(type, isArray) {\n  return isArray || type === 'bytes' || type === 'string' || type === 'tuple';\n}","map":{"version":3,"names":["bytesRegex","execTyped","integerRegex","isTupleRegex","UnknownSolidityTypeError","InvalidFunctionModifierError","InvalidModifierError","InvalidParameterError","SolidityProtectedKeywordError","InvalidSignatureError","UnknownSignatureError","InvalidParenthesisError","getParameterCacheKey","parameterCache","eventModifiers","execConstructorSignature","execErrorSignature","execEventSignature","execFallbackSignature","execFunctionSignature","functionModifiers","isConstructorSignature","isErrorSignature","isEventSignature","isFallbackSignature","isFunctionSignature","isReceiveSignature","parseSignature","signature","structs","arguments","length","undefined","parseFunctionSignature","parseEventSignature","parseErrorSignature","parseConstructorSignature","parseFallbackSignature","type","stateMutability","_match$stateMutabilit","match","inputParams","splitParameters","parameters","inputs","inputLength","i","push","parseAbiParameter","modifiers","outputs","returns","outputParams","outputLength","name","params","abiParameters","_match$stateMutabilit2","_match$stateMutabilit3","abiParameterWithoutTupleRegex","_wrapRegExp","array","modifier","abiParameterWithTupleRegex","dynamicIntegerRegex","param","options","_options$structs","_match$array","parameterCacheKey","has","get","isTuple","test","isSolidityKeyword","indexed","components","components_","concat","isSolidityType","_options$modifiers","_options$modifiers$ha","call","isValidDataLocation","abiParameter","_objectSpread","set","result","current","depth","trim","char","tail","slice","protectedKeywordsRegex","isArray"],"sources":["/Users/mac/Desktop/topl1/frontend/node_modules/abitype/src/human-readable/runtime/utils.ts"],"sourcesContent":["import type {\n  AbiItemType,\n  AbiType,\n  SolidityArray,\n  SolidityBytes,\n  SolidityString,\n  SolidityTuple,\n} from '../../abi.js'\nimport {\n  bytesRegex,\n  execTyped,\n  integerRegex,\n  isTupleRegex,\n} from '../../regex.js'\nimport { UnknownSolidityTypeError } from '../errors/abiItem.js'\nimport {\n  InvalidFunctionModifierError,\n  InvalidModifierError,\n  InvalidParameterError,\n  SolidityProtectedKeywordError,\n} from '../errors/abiParameter.js'\nimport {\n  InvalidSignatureError,\n  UnknownSignatureError,\n} from '../errors/signature.js'\nimport { InvalidParenthesisError } from '../errors/splitParameters.js'\nimport type { FunctionModifier, Modifier } from '../types/signatures.js'\nimport type { StructLookup } from '../types/structs.js'\nimport { getParameterCacheKey, parameterCache } from './cache.js'\nimport {\n  eventModifiers,\n  execConstructorSignature,\n  execErrorSignature,\n  execEventSignature,\n  execFallbackSignature,\n  execFunctionSignature,\n  functionModifiers,\n  isConstructorSignature,\n  isErrorSignature,\n  isEventSignature,\n  isFallbackSignature,\n  isFunctionSignature,\n  isReceiveSignature,\n} from './signatures.js'\n\nexport function parseSignature(signature: string, structs: StructLookup = {}) {\n  if (isFunctionSignature(signature))\n    return parseFunctionSignature(signature, structs)\n\n  if (isEventSignature(signature))\n    return parseEventSignature(signature, structs)\n\n  if (isErrorSignature(signature))\n    return parseErrorSignature(signature, structs)\n\n  if (isConstructorSignature(signature))\n    return parseConstructorSignature(signature, structs)\n\n  if (isFallbackSignature(signature)) return parseFallbackSignature(signature)\n\n  if (isReceiveSignature(signature))\n    return {\n      type: 'receive',\n      stateMutability: 'payable',\n    }\n\n  throw new UnknownSignatureError({ signature })\n}\n\nexport function parseFunctionSignature(\n  signature: string,\n  structs: StructLookup = {},\n) {\n  const match = execFunctionSignature(signature)\n  if (!match) throw new InvalidSignatureError({ signature, type: 'function' })\n\n  const inputParams = splitParameters(match.parameters)\n  const inputs = []\n  const inputLength = inputParams.length\n  for (let i = 0; i < inputLength; i++) {\n    inputs.push(\n      parseAbiParameter(inputParams[i]!, {\n        modifiers: functionModifiers,\n        structs,\n        type: 'function',\n      }),\n    )\n  }\n\n  const outputs = []\n  if (match.returns) {\n    const outputParams = splitParameters(match.returns)\n    const outputLength = outputParams.length\n    for (let i = 0; i < outputLength; i++) {\n      outputs.push(\n        parseAbiParameter(outputParams[i]!, {\n          modifiers: functionModifiers,\n          structs,\n          type: 'function',\n        }),\n      )\n    }\n  }\n\n  return {\n    name: match.name,\n    type: 'function',\n    stateMutability: match.stateMutability ?? 'nonpayable',\n    inputs,\n    outputs,\n  }\n}\n\nexport function parseEventSignature(\n  signature: string,\n  structs: StructLookup = {},\n) {\n  const match = execEventSignature(signature)\n  if (!match) throw new InvalidSignatureError({ signature, type: 'event' })\n\n  const params = splitParameters(match.parameters)\n  const abiParameters = []\n  const length = params.length\n  for (let i = 0; i < length; i++)\n    abiParameters.push(\n      parseAbiParameter(params[i]!, {\n        modifiers: eventModifiers,\n        structs,\n        type: 'event',\n      }),\n    )\n  return { name: match.name, type: 'event', inputs: abiParameters }\n}\n\nexport function parseErrorSignature(\n  signature: string,\n  structs: StructLookup = {},\n) {\n  const match = execErrorSignature(signature)\n  if (!match) throw new InvalidSignatureError({ signature, type: 'error' })\n\n  const params = splitParameters(match.parameters)\n  const abiParameters = []\n  const length = params.length\n  for (let i = 0; i < length; i++)\n    abiParameters.push(\n      parseAbiParameter(params[i]!, { structs, type: 'error' }),\n    )\n  return { name: match.name, type: 'error', inputs: abiParameters }\n}\n\nexport function parseConstructorSignature(\n  signature: string,\n  structs: StructLookup = {},\n) {\n  const match = execConstructorSignature(signature)\n  if (!match)\n    throw new InvalidSignatureError({ signature, type: 'constructor' })\n\n  const params = splitParameters(match.parameters)\n  const abiParameters = []\n  const length = params.length\n  for (let i = 0; i < length; i++)\n    abiParameters.push(\n      parseAbiParameter(params[i]!, { structs, type: 'constructor' }),\n    )\n  return {\n    type: 'constructor',\n    stateMutability: match.stateMutability ?? 'nonpayable',\n    inputs: abiParameters,\n  }\n}\n\nexport function parseFallbackSignature(signature: string) {\n  const match = execFallbackSignature(signature)\n  if (!match) throw new InvalidSignatureError({ signature, type: 'fallback' })\n\n  return {\n    type: 'fallback',\n    stateMutability: match.stateMutability ?? 'nonpayable',\n  }\n}\n\nconst abiParameterWithoutTupleRegex =\n  /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*(?:\\spayable)?)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/\nconst abiParameterWithTupleRegex =\n  /^\\((?<type>.+?)\\)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/\nconst dynamicIntegerRegex = /^u?int$/\n\ntype ParseOptions = {\n  modifiers?: Set<Modifier>\n  structs?: StructLookup\n  type?: AbiItemType | 'struct'\n}\n\nexport function parseAbiParameter(param: string, options?: ParseOptions) {\n  // optional namespace cache by `type`\n  const parameterCacheKey = getParameterCacheKey(\n    param,\n    options?.type,\n    options?.structs,\n  )\n  if (parameterCache.has(parameterCacheKey))\n    return parameterCache.get(parameterCacheKey)!\n\n  const isTuple = isTupleRegex.test(param)\n  const match = execTyped<{\n    array?: string\n    modifier?: Modifier\n    name?: string\n    type: string\n  }>(\n    isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex,\n    param,\n  )\n  if (!match) throw new InvalidParameterError({ param })\n\n  if (match.name && isSolidityKeyword(match.name))\n    throw new SolidityProtectedKeywordError({ param, name: match.name })\n\n  const name = match.name ? { name: match.name } : {}\n  const indexed = match.modifier === 'indexed' ? { indexed: true } : {}\n  const structs = options?.structs ?? {}\n  let type: string\n  let components = {}\n  if (isTuple) {\n    type = 'tuple'\n    const params = splitParameters(match.type)\n    const components_ = []\n    const length = params.length\n    for (let i = 0; i < length; i++) {\n      // remove `modifiers` from `options` to prevent from being added to tuple components\n      components_.push(parseAbiParameter(params[i]!, { structs }))\n    }\n    components = { components: components_ }\n  } else if (match.type in structs) {\n    type = 'tuple'\n    components = { components: structs[match.type] }\n  } else if (dynamicIntegerRegex.test(match.type)) {\n    type = `${match.type}256`\n  } else if (match.type === 'address payable') {\n    type = 'address'\n  } else {\n    type = match.type\n    if (!(options?.type === 'struct') && !isSolidityType(type))\n      throw new UnknownSolidityTypeError({ type })\n  }\n\n  if (match.modifier) {\n    // Check if modifier exists, but is not allowed (e.g. `indexed` in `functionModifiers`)\n    if (!options?.modifiers?.has?.(match.modifier))\n      throw new InvalidModifierError({\n        param,\n        type: options?.type,\n        modifier: match.modifier,\n      })\n\n    // Check if resolved `type` is valid if there is a function modifier\n    if (\n      functionModifiers.has(match.modifier as FunctionModifier) &&\n      !isValidDataLocation(type, !!match.array)\n    )\n      throw new InvalidFunctionModifierError({\n        param,\n        type: options?.type,\n        modifier: match.modifier,\n      })\n  }\n\n  const abiParameter = {\n    type: `${type}${match.array ?? ''}`,\n    ...name,\n    ...indexed,\n    ...components,\n  }\n  parameterCache.set(parameterCacheKey, abiParameter)\n  return abiParameter\n}\n\n// s/o latika for this\nexport function splitParameters(\n  params: string,\n  result: string[] = [],\n  current = '',\n  depth = 0,\n): readonly string[] {\n  const length = params.trim().length\n  // biome-ignore lint/correctness/noUnreachable: recursive\n  for (let i = 0; i < length; i++) {\n    const char = params[i]\n    const tail = params.slice(i + 1)\n    switch (char) {\n      case ',':\n        return depth === 0\n          ? splitParameters(tail, [...result, current.trim()])\n          : splitParameters(tail, result, `${current}${char}`, depth)\n      case '(':\n        return splitParameters(tail, result, `${current}${char}`, depth + 1)\n      case ')':\n        return splitParameters(tail, result, `${current}${char}`, depth - 1)\n      default:\n        return splitParameters(tail, result, `${current}${char}`, depth)\n    }\n  }\n\n  if (current === '') return result\n  if (depth !== 0) throw new InvalidParenthesisError({ current, depth })\n\n  result.push(current.trim())\n  return result\n}\n\nexport function isSolidityType(\n  type: string,\n): type is Exclude<AbiType, SolidityTuple | SolidityArray> {\n  return (\n    type === 'address' ||\n    type === 'bool' ||\n    type === 'function' ||\n    type === 'string' ||\n    bytesRegex.test(type) ||\n    integerRegex.test(type)\n  )\n}\n\nconst protectedKeywordsRegex =\n  /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/\n\n/** @internal */\nexport function isSolidityKeyword(name: string) {\n  return (\n    name === 'address' ||\n    name === 'bool' ||\n    name === 'function' ||\n    name === 'string' ||\n    name === 'tuple' ||\n    bytesRegex.test(name) ||\n    integerRegex.test(name) ||\n    protectedKeywordsRegex.test(name)\n  )\n}\n\n/** @internal */\nexport function isValidDataLocation(\n  type: string,\n  isArray: boolean,\n): type is Exclude<\n  AbiType,\n  SolidityString | Extract<SolidityBytes, 'bytes'> | SolidityArray\n> {\n  return isArray || type === 'bytes' || type === 'string' || type === 'tuple'\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}