{"ast":null,"code":"import * as abitype from 'abitype';\nimport * as AbiItem from './AbiItem.js';\nimport * as AbiParameters from './AbiParameters.js';\nimport * as Hex from './Hex.js';\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function decode(...parameters) {\n  const [abiConstructor, options] = (() => {\n    if (Array.isArray(parameters[0])) {\n      const [abi, options] = parameters;\n      return [fromAbi(abi), options];\n    }\n    return parameters;\n  })();\n  const {\n    bytecode\n  } = options;\n  if (abiConstructor.inputs?.length === 0) return undefined;\n  const data = options.data.replace(bytecode, '0x');\n  return AbiParameters.decode(abiConstructor.inputs, data);\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function encode(...parameters) {\n  const [abiConstructor, options] = (() => {\n    if (Array.isArray(parameters[0])) {\n      const [abi, options] = parameters;\n      return [fromAbi(abi), options];\n    }\n    return parameters;\n  })();\n  const {\n    bytecode,\n    args\n  } = options;\n  return Hex.concat(bytecode, abiConstructor.inputs?.length && args?.length ? AbiParameters.encode(abiConstructor.inputs, args) : '0x');\n}\n/** @internal */\nexport function format(abiConstructor) {\n  return abitype.formatAbiItem(abiConstructor);\n}\n/** @internal */\nexport function from(abiConstructor) {\n  return AbiItem.from(abiConstructor);\n}\n/** @internal */\nexport function fromAbi(abi) {\n  const item = abi.find(item => item.type === 'constructor');\n  if (!item) throw new AbiItem.NotFoundError({\n    name: 'constructor'\n  });\n  return item;\n}","map":{"version":3,"names":["abitype","AbiItem","AbiParameters","Hex","decode","parameters","abiConstructor","options","Array","isArray","abi","fromAbi","bytecode","inputs","length","undefined","data","replace","encode","args","concat","format","formatAbiItem","from","item","find","type","NotFoundError","name"],"sources":["/Users/mac/Desktop/topl1/frontend/node_modules/ox/core/AbiConstructor.ts"],"sourcesContent":["import * as abitype from 'abitype'\nimport type * as Abi from './Abi.js'\nimport * as AbiItem from './AbiItem.js'\nimport * as AbiParameters from './AbiParameters.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport type * as internal from './internal/abiConstructor.js'\nimport type { IsNarrowable } from './internal/types.js'\n\n/** Root type for an {@link ox#AbiItem.AbiItem} with a `constructor` type. */\nexport type AbiConstructor = abitype.AbiConstructor\n\n/**\n * ABI-decodes the provided constructor input (`inputs`).\n *\n * @example\n * ```ts twoslash\n * import { AbiConstructor } from 'ox'\n *\n * const constructor = AbiConstructor.from('constructor(address, uint256)')\n *\n * const bytecode = '0x...'\n *\n * const data = AbiConstructor.encode(constructor, {\n *   bytecode,\n *   args: ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 123n],\n * })\n *\n * const decoded = AbiConstructor.decode(constructor, { // [!code focus]\n *   bytecode, // [!code focus]\n *   data, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @example\n * ### ABI-shorthand\n *\n * You can also specify an entire ABI object as a parameter to `AbiConstructor.decode`.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiConstructor } from 'ox'\n *\n * const abi = Abi.from([...])\n *\n * const data = AbiConstructor.encode(abi, {\n *   bytecode: '0x...',\n *   args: ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 123n],\n * })\n *\n * const decoded = AbiConstructor.decode(abi, { // [!code focus]\n *   bytecode: '0x...', // [!code focus]\n *   data, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param abiConstructor - The ABI Constructor to decode.\n * @param options - Decoding options.\n * @returns The decoded constructor inputs.\n */\nexport function decode<\n  const abi extends Abi.Abi | readonly unknown[],\n  abiConstructor extends\n    AbiConstructor = fromAbi.ReturnType<abi> extends AbiConstructor\n    ? fromAbi.ReturnType<abi>\n    : never,\n>(\n  abi: abi | Abi.Abi | readonly unknown[],\n  options: decode.Options,\n): decode.ReturnType<abiConstructor>\nexport function decode<const abiConstructor extends AbiConstructor>(\n  abiConstructor: abiConstructor | AbiConstructor,\n  options: decode.Options,\n): decode.ReturnType<abiConstructor>\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function decode(\n  ...parameters:\n    | [abi: Abi.Abi | readonly unknown[], options: decode.Options]\n    | [abiConstructor: AbiConstructor, options: decode.Options]\n): decode.ReturnType {\n  const [abiConstructor, options] = (() => {\n    if (Array.isArray(parameters[0])) {\n      const [abi, options] = parameters as [\n        Abi.Abi | readonly unknown[],\n        decode.Options,\n      ]\n      return [fromAbi(abi), options] as [AbiConstructor, decode.Options]\n    }\n    return parameters as [AbiConstructor, decode.Options]\n  })()\n\n  const { bytecode } = options\n  if (abiConstructor.inputs?.length === 0) return undefined\n  const data = options.data.replace(bytecode, '0x') as Hex.Hex\n  return AbiParameters.decode(abiConstructor.inputs, data)\n}\n\nexport declare namespace decode {\n  interface Options {\n    /** The bytecode of the contract. */\n    bytecode: Hex.Hex\n    /** The encoded constructor. */\n    data: Hex.Hex\n  }\n\n  type ReturnType<abiConstructor extends AbiConstructor = AbiConstructor> =\n    | (abiConstructor['inputs']['length'] extends 0\n        ? undefined\n        : abitype.AbiParametersToPrimitiveTypes<abiConstructor['inputs']>)\n    | (IsNarrowable<abiConstructor, AbiConstructor> extends true\n        ? never\n        : undefined)\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * ABI-encodes the provided constructor input (`inputs`).\n *\n * @example\n * ```ts twoslash\n * import { AbiConstructor } from 'ox'\n *\n * const constructor = AbiConstructor.from('constructor(address, uint256)')\n *\n * const data = AbiConstructor.encode(constructor, {\n *   bytecode: '0x...',\n *   args: ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 123n],\n * })\n * ```\n *\n * @example\n * ### ABI-shorthand\n *\n * You can also specify an entire ABI object as a parameter to `AbiConstructor.encode`.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiConstructor } from 'ox'\n *\n * const abi = Abi.from([...])\n *\n * const data = AbiConstructor.encode(abi, { // [!code focus]\n *   bytecode: '0x...', // [!code focus]\n *   args: ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 123n], // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @example\n * ### End-to-end\n *\n * Below is an end-to-end example of using `AbiConstructor.encode` to encode the constructor of a contract and deploy it.\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { AbiConstructor, Hex } from 'ox'\n *\n * // 1. Instantiate the ABI Constructor.\n * const constructor = AbiConstructor.from(\n *   'constructor(address owner, uint256 amount)',\n * )\n *\n * // 2. Encode the ABI Constructor.\n * const data = AbiConstructor.encode(constructor, {\n *   bytecode: '0x...',\n *   args: ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 123n],\n * })\n *\n * // 3. Deploy the contract.\n * const hash = await window.ethereum!.request({\n *   method: 'eth_sendTransaction',\n *   params: [{ data }],\n * })\n * ```\n *\n * :::note\n *\n * For simplicity, the above example uses `window.ethereum.request`, but you can use any\n * type of JSON-RPC interface.\n *\n * :::\n *\n * @param abiConstructor - The ABI Constructor to encode.\n * @param options - Encoding options.\n * @returns The encoded constructor.\n */\nexport function encode<\n  const abi extends Abi.Abi | readonly unknown[],\n  abiConstructor extends\n    AbiConstructor = fromAbi.ReturnType<abi> extends AbiConstructor\n    ? fromAbi.ReturnType<abi>\n    : never,\n>(\n  abi: abi | Abi.Abi | readonly unknown[],\n  options: encode.Options<abiConstructor>,\n): encode.ReturnType\nexport function encode<const abiConstructor extends AbiConstructor>(\n  abiConstructor: abiConstructor | AbiConstructor,\n  options: encode.Options<abiConstructor>,\n): encode.ReturnType\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function encode(\n  ...parameters:\n    | [abi: Abi.Abi | readonly unknown[], options: encode.Options]\n    | [abiConstructor: AbiConstructor, options: encode.Options]\n): encode.ReturnType {\n  const [abiConstructor, options] = (() => {\n    if (Array.isArray(parameters[0])) {\n      const [abi, options] = parameters as [\n        Abi.Abi | readonly unknown[],\n        encode.Options,\n      ]\n      return [fromAbi(abi), options] as [AbiConstructor, encode.Options]\n    }\n\n    return parameters as [AbiConstructor, encode.Options]\n  })()\n\n  const { bytecode, args } = options\n  return Hex.concat(\n    bytecode,\n    abiConstructor.inputs?.length && args?.length\n      ? AbiParameters.encode(abiConstructor.inputs, args as readonly unknown[])\n      : '0x',\n  )\n}\n\nexport declare namespace encode {\n  type Options<\n    abiConstructor extends AbiConstructor = AbiConstructor,\n    ///\n    args extends abitype.AbiParametersToPrimitiveTypes<\n      abiConstructor['inputs']\n    > = abitype.AbiParametersToPrimitiveTypes<abiConstructor['inputs']>,\n  > = {\n    /** The bytecode of the contract. */\n    bytecode: Hex.Hex\n    /** The constructor arguments to encode. */\n    args?: args | undefined\n  } & (readonly [] extends args\n    ? {}\n    : {\n        /** The constructor arguments to encode. */\n        args: args\n      })\n\n  type ReturnType = Hex.Hex\n\n  type ErrorType =\n    | Hex.concat.ErrorType\n    | AbiParameters.encode.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function format<const abiConstructor extends AbiConstructor>(\n  abiConstructor: abiConstructor,\n): format.ReturnType<abiConstructor>\n/**\n * Formats an {@link ox#AbiConstructor.AbiConstructor} into a **Human Readable ABI Function**.\n *\n * @example\n * ```ts twoslash\n * import { AbiConstructor } from 'ox'\n *\n * const formatted = AbiConstructor.format({\n *   inputs: [\n *     { name: 'owner', type: 'address' },\n *   ],\n *   payable: false,\n *   stateMutability: 'nonpayable',\n *   type: 'constructor',\n * })\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param abiConstructor - The ABI Constructor to format.\n * @returns The formatted ABI Constructor.\n */\nexport function format(abiConstructor: AbiConstructor): string\n/** @internal */\nexport function format(abiConstructor: AbiConstructor): format.ReturnType {\n  return abitype.formatAbiItem(abiConstructor)\n}\n\nexport declare namespace format {\n  type ReturnType<abiConstructor extends AbiConstructor = AbiConstructor> =\n    abitype.FormatAbiItem<abiConstructor>\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function from<\n  const abiConstructor extends AbiConstructor | string | readonly string[],\n>(\n  abiConstructor: (abiConstructor | string | readonly string[]) &\n    (\n      | (abiConstructor extends string\n          ? internal.Signature<abiConstructor>\n          : never)\n      | (abiConstructor extends readonly string[]\n          ? internal.Signatures<abiConstructor>\n          : never)\n      | AbiConstructor\n    ),\n): from.ReturnType<abiConstructor>\n/**\n * Parses an arbitrary **JSON ABI Constructor** or **Human Readable ABI Constructor** into a typed {@link ox#AbiConstructor.AbiConstructor}.\n *\n * @example\n * ### JSON ABIs\n *\n * ```ts twoslash\n * import { AbiConstructor } from 'ox'\n *\n * const constructor = AbiConstructor.from({\n *   inputs: [\n *     { name: 'owner', type: 'address' },\n *   ],\n *   payable: false,\n *   stateMutability: 'nonpayable',\n *   type: 'constructor',\n * })\n *\n * constructor\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable ABIs\n *\n * A Human Readable ABI can be parsed into a typed ABI object:\n *\n * ```ts twoslash\n * import { AbiConstructor } from 'ox'\n *\n * const constructor = AbiConstructor.from(\n *   'constructor(address owner)' // [!code hl]\n * )\n *\n * constructor\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiConstructor } from 'ox'\n *\n * const constructor = AbiConstructor.from([\n *   'struct Foo { address owner; uint256 amount; }', // [!code hl]\n *   'constructor(Foo foo)',\n * ])\n *\n * constructor\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param abiConstructor - The ABI Constructor to parse.\n * @returns Typed ABI Constructor.\n */\nexport function from(\n  abiConstructor: AbiConstructor | string | readonly string[],\n): AbiConstructor\n/** @internal */\nexport function from(\n  abiConstructor: AbiConstructor | string | readonly string[],\n): from.ReturnType {\n  return AbiItem.from(abiConstructor as AbiConstructor)\n}\n\nexport declare namespace from {\n  type ReturnType<\n    abiConstructor extends\n      | AbiConstructor\n      | string\n      | readonly string[] = AbiConstructor,\n  > = AbiItem.from.ReturnType<abiConstructor>\n\n  type ErrorType = AbiItem.from.ErrorType | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function fromAbi<const abi extends Abi.Abi | readonly unknown[]>(\n  abi: abi | Abi.Abi | readonly unknown[],\n): fromAbi.ReturnType<abi>\n/**\n * Extracts an {@link ox#AbiConstructor.AbiConstructor} from an {@link ox#Abi.Abi} given a name and optional arguments.\n *\n * @example\n * ### Extracting by Name\n *\n * ABI Events can be extracted by their name using the `name` option:\n *\n * ```ts twoslash\n * import { Abi, AbiConstructor } from 'ox'\n *\n * const abi = Abi.from([\n *   'constructor(address owner)',\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiConstructor.fromAbi(abi) // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @returns The ABI constructor.\n */\nexport function fromAbi(abi: Abi.Abi | readonly unknown[]): AbiConstructor\n/** @internal */\nexport function fromAbi(abi: Abi.Abi | readonly unknown[]): fromAbi.ReturnType {\n  const item = (abi as Abi.Abi).find((item) => item.type === 'constructor')\n  if (!item) throw new AbiItem.NotFoundError({ name: 'constructor' })\n  return item\n}\n\nexport declare namespace fromAbi {\n  type ReturnType<abi extends Abi.Abi | readonly unknown[] = Abi.Abi> = Extract<\n    abi[number],\n    { type: 'constructor' }\n  >\n\n  type ErrorType = AbiItem.NotFoundError | Errors.GlobalErrorType\n}\n"],"mappings":"AAAA,OAAO,KAAKA,OAAO,MAAM,SAAS;AAElC,OAAO,KAAKC,OAAO,MAAM,cAAc;AACvC,OAAO,KAAKC,aAAa,MAAM,oBAAoB;AAEnD,OAAO,KAAKC,GAAG,MAAM,UAAU;AAqE/B;AACA,OAAM,SAAUC,MAAMA,CACpB,GAAGC,UAE0D;EAE7D,MAAM,CAACC,cAAc,EAAEC,OAAO,CAAC,GAAG,CAAC,MAAK;IACtC,IAAIC,KAAK,CAACC,OAAO,CAACJ,UAAU,CAAC,CAAC,CAAC,CAAC,EAAE;MAChC,MAAM,CAACK,GAAG,EAAEH,OAAO,CAAC,GAAGF,UAGtB;MACD,OAAO,CAACM,OAAO,CAACD,GAAG,CAAC,EAAEH,OAAO,CAAqC;IACpE;IACA,OAAOF,UAA8C;EACvD,CAAC,EAAC,CAAE;EAEJ,MAAM;IAAEO;EAAQ,CAAE,GAAGL,OAAO;EAC5B,IAAID,cAAc,CAACO,MAAM,EAAEC,MAAM,KAAK,CAAC,EAAE,OAAOC,SAAS;EACzD,MAAMC,IAAI,GAAGT,OAAO,CAACS,IAAI,CAACC,OAAO,CAACL,QAAQ,EAAE,IAAI,CAAY;EAC5D,OAAOV,aAAa,CAACE,MAAM,CAACE,cAAc,CAACO,MAAM,EAAEG,IAAI,CAAC;AAC1D;AAyGA;AACA,OAAM,SAAUE,MAAMA,CACpB,GAAGb,UAE0D;EAE7D,MAAM,CAACC,cAAc,EAAEC,OAAO,CAAC,GAAG,CAAC,MAAK;IACtC,IAAIC,KAAK,CAACC,OAAO,CAACJ,UAAU,CAAC,CAAC,CAAC,CAAC,EAAE;MAChC,MAAM,CAACK,GAAG,EAAEH,OAAO,CAAC,GAAGF,UAGtB;MACD,OAAO,CAACM,OAAO,CAACD,GAAG,CAAC,EAAEH,OAAO,CAAqC;IACpE;IAEA,OAAOF,UAA8C;EACvD,CAAC,EAAC,CAAE;EAEJ,MAAM;IAAEO,QAAQ;IAAEO;EAAI,CAAE,GAAGZ,OAAO;EAClC,OAAOJ,GAAG,CAACiB,MAAM,CACfR,QAAQ,EACRN,cAAc,CAACO,MAAM,EAAEC,MAAM,IAAIK,IAAI,EAAEL,MAAM,GACzCZ,aAAa,CAACgB,MAAM,CAACZ,cAAc,CAACO,MAAM,EAAEM,IAA0B,CAAC,GACvE,IAAI,CACT;AACH;AA2DA;AACA,OAAM,SAAUE,MAAMA,CAACf,cAA8B;EACnD,OAAON,OAAO,CAACsB,aAAa,CAAChB,cAAc,CAAC;AAC9C;AA0HA;AACA,OAAM,SAAUiB,IAAIA,CAClBjB,cAA2D;EAE3D,OAAOL,OAAO,CAACsB,IAAI,CAACjB,cAAgC,CAAC;AACvD;AAgDA;AACA,OAAM,SAAUK,OAAOA,CAACD,GAAiC;EACvD,MAAMc,IAAI,GAAId,GAAe,CAACe,IAAI,CAAED,IAAI,IAAKA,IAAI,CAACE,IAAI,KAAK,aAAa,CAAC;EACzE,IAAI,CAACF,IAAI,EAAE,MAAM,IAAIvB,OAAO,CAAC0B,aAAa,CAAC;IAAEC,IAAI,EAAE;EAAa,CAAE,CAAC;EACnE,OAAOJ,IAAI;AACb","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}