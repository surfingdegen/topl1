{"ast":null,"code":"import * as Bytes from './Bytes.js';\nimport * as Errors from './Errors.js';\nimport * as Hex from './Hex.js';\nimport * as Cursor from './internal/cursor.js';\n/**\n * Decodes a Recursive-Length Prefix (RLP) value into a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Rlp } from 'ox'\n * Rlp.toBytes('0x8b68656c6c6f20776f726c64')\n * // Uint8Array([139, 104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param value - The value to decode.\n * @returns The decoded {@link ox#Bytes.Bytes} value.\n */\nexport function toBytes(value) {\n  return to(value, 'Bytes');\n}\n/**\n * Decodes a Recursive-Length Prefix (RLP) value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Rlp } from 'ox'\n * Rlp.toHex('0x8b68656c6c6f20776f726c64')\n * // 0x68656c6c6f20776f726c64\n * ```\n *\n * @param value - The value to decode.\n * @returns The decoded {@link ox#Hex.Hex} value.\n */\nexport function toHex(value) {\n  return to(value, 'Hex');\n}\n/////////////////////////////////////////////////////////////////////////////////\n// Internal\n/////////////////////////////////////////////////////////////////////////////////\n/** @internal */\nexport function to(value, to) {\n  const to_ = to ?? (typeof value === 'string' ? 'Hex' : 'Bytes');\n  const bytes = (() => {\n    if (typeof value === 'string') {\n      if (value.length > 3 && value.length % 2 !== 0) throw new Hex.InvalidLengthError(value);\n      return Bytes.fromHex(value);\n    }\n    return value;\n  })();\n  const cursor = Cursor.create(bytes, {\n    recursiveReadLimit: Number.POSITIVE_INFINITY\n  });\n  const result = decodeRlpCursor(cursor, to_);\n  return result;\n}\n/** @internal */\n/** @internal */\nexport function decodeRlpCursor(cursor, to = 'Hex') {\n  if (cursor.bytes.length === 0) return to === 'Hex' ? Hex.fromBytes(cursor.bytes) : cursor.bytes;\n  const prefix = cursor.readByte();\n  if (prefix < 0x80) cursor.decrementPosition(1);\n  // bytes\n  if (prefix < 0xc0) {\n    const length = readLength(cursor, prefix, 0x80);\n    const bytes = cursor.readBytes(length);\n    return to === 'Hex' ? Hex.fromBytes(bytes) : bytes;\n  }\n  // list\n  const length = readLength(cursor, prefix, 0xc0);\n  return readList(cursor, length, to);\n}\n/** @internal */\nexport function readLength(cursor, prefix, offset) {\n  if (offset === 0x80 && prefix < 0x80) return 1;\n  if (prefix <= offset + 55) return prefix - offset;\n  if (prefix === offset + 55 + 1) return cursor.readUint8();\n  if (prefix === offset + 55 + 2) return cursor.readUint16();\n  if (prefix === offset + 55 + 3) return cursor.readUint24();\n  if (prefix === offset + 55 + 4) return cursor.readUint32();\n  throw new Errors.BaseError('Invalid RLP prefix');\n}\n/** @internal */\nexport function readList(cursor, length, to) {\n  const position = cursor.position;\n  const value = [];\n  while (cursor.position - position < length) value.push(decodeRlpCursor(cursor, to));\n  return value;\n}\n/**\n * Encodes a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value into a Recursive-Length Prefix (RLP) value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Rlp } from 'ox'\n *\n * Rlp.from('0x68656c6c6f20776f726c64', { as: 'Hex' })\n * // @log: 0x8b68656c6c6f20776f726c64\n *\n * Rlp.from(Bytes.from([139, 104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100]), { as: 'Bytes' })\n * // @log: Uint8Array([104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value to encode.\n * @param options - Options.\n * @returns The RLP value.\n */\nexport function from(value, options) {\n  const {\n    as\n  } = options;\n  const encodable = getEncodable(value);\n  const cursor = Cursor.create(new Uint8Array(encodable.length));\n  encodable.encode(cursor);\n  if (as === 'Hex') return Hex.fromBytes(cursor.bytes);\n  return cursor.bytes;\n}\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a Recursive-Length Prefix (RLP) value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Rlp } from 'ox'\n *\n * Rlp.fromBytes(Bytes.from([139, 104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100]))\n * // @log: Uint8Array([104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} value to encode.\n * @param options - Options.\n * @returns The RLP value.\n */\nexport function fromBytes(bytes, options = {}) {\n  const {\n    as = 'Bytes'\n  } = options;\n  return from(bytes, {\n    as\n  });\n}\n/**\n * Encodes a {@link ox#Hex.Hex} value into a Recursive-Length Prefix (RLP) value.\n *\n * @example\n * ```ts twoslash\n * import { Rlp } from 'ox'\n *\n * Rlp.fromHex('0x68656c6c6f20776f726c64')\n * // @log: 0x8b68656c6c6f20776f726c64\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to encode.\n * @param options - Options.\n * @returns The RLP value.\n */\nexport function fromHex(hex, options = {}) {\n  const {\n    as = 'Hex'\n  } = options;\n  return from(hex, {\n    as\n  });\n}\n/////////////////////////////////////////////////////////////////////////////////\n// Internal\n/////////////////////////////////////////////////////////////////////////////////\nfunction getEncodable(bytes) {\n  if (Array.isArray(bytes)) return getEncodableList(bytes.map(x => getEncodable(x)));\n  return getEncodableBytes(bytes);\n}\nfunction getEncodableList(list) {\n  const bodyLength = list.reduce((acc, x) => acc + x.length, 0);\n  const sizeOfBodyLength = getSizeOfLength(bodyLength);\n  const length = (() => {\n    if (bodyLength <= 55) return 1 + bodyLength;\n    return 1 + sizeOfBodyLength + bodyLength;\n  })();\n  return {\n    length,\n    encode(cursor) {\n      if (bodyLength <= 55) {\n        cursor.pushByte(0xc0 + bodyLength);\n      } else {\n        cursor.pushByte(0xc0 + 55 + sizeOfBodyLength);\n        if (sizeOfBodyLength === 1) cursor.pushUint8(bodyLength);else if (sizeOfBodyLength === 2) cursor.pushUint16(bodyLength);else if (sizeOfBodyLength === 3) cursor.pushUint24(bodyLength);else cursor.pushUint32(bodyLength);\n      }\n      for (const {\n        encode\n      } of list) {\n        encode(cursor);\n      }\n    }\n  };\n}\nfunction getEncodableBytes(bytesOrHex) {\n  const bytes = typeof bytesOrHex === 'string' ? Bytes.fromHex(bytesOrHex) : bytesOrHex;\n  const sizeOfBytesLength = getSizeOfLength(bytes.length);\n  const length = (() => {\n    if (bytes.length === 1 && bytes[0] < 0x80) return 1;\n    if (bytes.length <= 55) return 1 + bytes.length;\n    return 1 + sizeOfBytesLength + bytes.length;\n  })();\n  return {\n    length,\n    encode(cursor) {\n      if (bytes.length === 1 && bytes[0] < 0x80) {\n        cursor.pushBytes(bytes);\n      } else if (bytes.length <= 55) {\n        cursor.pushByte(0x80 + bytes.length);\n        cursor.pushBytes(bytes);\n      } else {\n        cursor.pushByte(0x80 + 55 + sizeOfBytesLength);\n        if (sizeOfBytesLength === 1) cursor.pushUint8(bytes.length);else if (sizeOfBytesLength === 2) cursor.pushUint16(bytes.length);else if (sizeOfBytesLength === 3) cursor.pushUint24(bytes.length);else cursor.pushUint32(bytes.length);\n        cursor.pushBytes(bytes);\n      }\n    }\n  };\n}\nfunction getSizeOfLength(length) {\n  if (length <= 0xff) return 1;\n  if (length <= 0xff_ff) return 2;\n  if (length <= 0xff_ff_ff) return 3;\n  if (length <= 0xff_ff_ff_ff) return 4;\n  throw new Errors.BaseError('Length is too large.');\n}","map":{"version":3,"names":["Bytes","Errors","Hex","Cursor","toBytes","value","to","toHex","to_","bytes","length","InvalidLengthError","fromHex","cursor","create","recursiveReadLimit","Number","POSITIVE_INFINITY","result","decodeRlpCursor","fromBytes","prefix","readByte","decrementPosition","readLength","readBytes","readList","offset","readUint8","readUint16","readUint24","readUint32","BaseError","position","push","from","options","as","encodable","getEncodable","Uint8Array","encode","hex","Array","isArray","getEncodableList","map","x","getEncodableBytes","list","bodyLength","reduce","acc","sizeOfBodyLength","getSizeOfLength","pushByte","pushUint8","pushUint16","pushUint24","pushUint32","bytesOrHex","sizeOfBytesLength","pushBytes"],"sources":["/Users/mac/Desktop/topl1/frontend/node_modules/ox/core/Rlp.ts"],"sourcesContent":["import * as Bytes from './Bytes.js'\nimport * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport * as Cursor from './internal/cursor.js'\nimport type { ExactPartial, RecursiveArray } from './internal/types.js'\n\n/**\n * Decodes a Recursive-Length Prefix (RLP) value into a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Rlp } from 'ox'\n * Rlp.toBytes('0x8b68656c6c6f20776f726c64')\n * // Uint8Array([139, 104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param value - The value to decode.\n * @returns The decoded {@link ox#Bytes.Bytes} value.\n */\nexport function toBytes(\n  value: Bytes.Bytes | Hex.Hex,\n): RecursiveArray<Bytes.Bytes> {\n  return to(value, 'Bytes')\n}\n\nexport declare namespace toBytes {\n  type ErrorType = to.ErrorType\n}\n\n/**\n * Decodes a Recursive-Length Prefix (RLP) value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Rlp } from 'ox'\n * Rlp.toHex('0x8b68656c6c6f20776f726c64')\n * // 0x68656c6c6f20776f726c64\n * ```\n *\n * @param value - The value to decode.\n * @returns The decoded {@link ox#Hex.Hex} value.\n */\nexport function toHex(value: Bytes.Bytes | Hex.Hex): RecursiveArray<Hex.Hex> {\n  return to(value, 'Hex')\n}\n\nexport declare namespace toHex {\n  type ErrorType = to.ErrorType\n}\n\n/////////////////////////////////////////////////////////////////////////////////\n// Internal\n/////////////////////////////////////////////////////////////////////////////////\n\n/** @internal */\nexport function to<\n  value extends Bytes.Bytes | Hex.Hex,\n  to extends 'Hex' | 'Bytes',\n>(value: value, to: to | 'Hex' | 'Bytes'): to.ReturnType<to> {\n  const to_ = to ?? (typeof value === 'string' ? 'Hex' : 'Bytes')\n\n  const bytes = (() => {\n    if (typeof value === 'string') {\n      if (value.length > 3 && value.length % 2 !== 0)\n        throw new Hex.InvalidLengthError(value)\n      return Bytes.fromHex(value)\n    }\n    return value as Bytes.Bytes\n  })()\n\n  const cursor = Cursor.create(bytes, {\n    recursiveReadLimit: Number.POSITIVE_INFINITY,\n  })\n  const result = decodeRlpCursor(cursor, to_)\n\n  return result as to.ReturnType<to>\n}\n\n/** @internal */\nexport declare namespace to {\n  type ReturnType<to extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> =\n    | (to extends 'Bytes' ? RecursiveArray<Bytes.Bytes> : never)\n    | (to extends 'Hex' ? RecursiveArray<Hex.Hex> : never)\n\n  type ErrorType =\n    | Bytes.fromHex.ErrorType\n    | decodeRlpCursor.ErrorType\n    | Cursor.create.ErrorType\n    | Hex.InvalidLengthError\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\n\n/** @internal */\nexport function decodeRlpCursor<to extends 'Hex' | 'Bytes' = 'Hex'>(\n  cursor: Cursor.Cursor,\n  to: to | 'Hex' | 'Bytes' | undefined = 'Hex',\n): decodeRlpCursor.ReturnType<to> {\n  if (cursor.bytes.length === 0)\n    return (\n      to === 'Hex' ? Hex.fromBytes(cursor.bytes) : cursor.bytes\n    ) as decodeRlpCursor.ReturnType<to>\n\n  const prefix = cursor.readByte()\n  if (prefix < 0x80) cursor.decrementPosition(1)\n\n  // bytes\n  if (prefix < 0xc0) {\n    const length = readLength(cursor, prefix, 0x80)\n    const bytes = cursor.readBytes(length)\n    return (\n      to === 'Hex' ? Hex.fromBytes(bytes) : bytes\n    ) as decodeRlpCursor.ReturnType<to>\n  }\n\n  // list\n  const length = readLength(cursor, prefix, 0xc0)\n  return readList(cursor, length, to) as {} as decodeRlpCursor.ReturnType<to>\n}\n\n/** @internal */\nexport declare namespace decodeRlpCursor {\n  type ReturnType<to extends 'Hex' | 'Bytes' = 'Hex'> = to.ReturnType<to>\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | readLength.ErrorType\n    | readList.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function readLength(\n  cursor: Cursor.Cursor,\n  prefix: number,\n  offset: number,\n) {\n  if (offset === 0x80 && prefix < 0x80) return 1\n  if (prefix <= offset + 55) return prefix - offset\n  if (prefix === offset + 55 + 1) return cursor.readUint8()\n  if (prefix === offset + 55 + 2) return cursor.readUint16()\n  if (prefix === offset + 55 + 3) return cursor.readUint24()\n  if (prefix === offset + 55 + 4) return cursor.readUint32()\n  throw new Errors.BaseError('Invalid RLP prefix')\n}\n\n/** @internal */\nexport declare namespace readLength {\n  type ErrorType = Errors.BaseError | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function readList<to extends 'Hex' | 'Bytes'>(\n  cursor: Cursor.Cursor,\n  length: number,\n  to: to | 'Hex' | 'Bytes',\n) {\n  const position = cursor.position\n  const value: decodeRlpCursor.ReturnType<to>[] = []\n  while (cursor.position - position < length)\n    value.push(decodeRlpCursor(cursor, to))\n  return value\n}\n\n/** @internal */\nexport declare namespace readList {\n  type ErrorType = Errors.GlobalErrorType\n}\n\ntype Encodable = {\n  length: number\n  encode(cursor: Cursor.Cursor): void\n}\n\n/**\n * Encodes a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value into a Recursive-Length Prefix (RLP) value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Rlp } from 'ox'\n *\n * Rlp.from('0x68656c6c6f20776f726c64', { as: 'Hex' })\n * // @log: 0x8b68656c6c6f20776f726c64\n *\n * Rlp.from(Bytes.from([139, 104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100]), { as: 'Bytes' })\n * // @log: Uint8Array([104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value to encode.\n * @param options - Options.\n * @returns The RLP value.\n */\nexport function from<as extends 'Hex' | 'Bytes'>(\n  value: RecursiveArray<Bytes.Bytes> | RecursiveArray<Hex.Hex>,\n  options: from.Options<as>,\n): from.ReturnType<as> {\n  const { as } = options\n\n  const encodable = getEncodable(value)\n  const cursor = Cursor.create(new Uint8Array(encodable.length))\n  encodable.encode(cursor)\n\n  if (as === 'Hex') return Hex.fromBytes(cursor.bytes) as from.ReturnType<as>\n  return cursor.bytes as from.ReturnType<as>\n}\n\nexport declare namespace from {\n  type Options<as extends 'Hex' | 'Bytes'> = {\n    /** The type to convert the RLP value to. */\n    as: as | 'Hex' | 'Bytes'\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | Cursor.create.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Bytes.fromHex.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a Recursive-Length Prefix (RLP) value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Rlp } from 'ox'\n *\n * Rlp.fromBytes(Bytes.from([139, 104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100]))\n * // @log: Uint8Array([104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} value to encode.\n * @param options - Options.\n * @returns The RLP value.\n */\nexport function fromBytes<as extends 'Hex' | 'Bytes' = 'Bytes'>(\n  bytes: RecursiveArray<Bytes.Bytes>,\n  options: fromBytes.Options<as> = {},\n): fromBytes.ReturnType<as> {\n  const { as = 'Bytes' } = options\n  return from(bytes, { as }) as never\n}\n\nexport declare namespace fromBytes {\n  type Options<as extends 'Hex' | 'Bytes' = 'Bytes'> = ExactPartial<\n    from.Options<as>\n  >\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Bytes'> = from.ReturnType<as>\n\n  type ErrorType = from.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a {@link ox#Hex.Hex} value into a Recursive-Length Prefix (RLP) value.\n *\n * @example\n * ```ts twoslash\n * import { Rlp } from 'ox'\n *\n * Rlp.fromHex('0x68656c6c6f20776f726c64')\n * // @log: 0x8b68656c6c6f20776f726c64\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to encode.\n * @param options - Options.\n * @returns The RLP value.\n */\nexport function fromHex<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  hex: RecursiveArray<Hex.Hex>,\n  options: fromHex.Options<as> = {},\n): fromHex.ReturnType<as> {\n  const { as = 'Hex' } = options\n  return from(hex, { as }) as never\n}\n\nexport declare namespace fromHex {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = ExactPartial<\n    from.Options<as>\n  >\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex'> = from.ReturnType<as>\n\n  type ErrorType = from.ErrorType | Errors.GlobalErrorType\n}\n\n/////////////////////////////////////////////////////////////////////////////////\n// Internal\n/////////////////////////////////////////////////////////////////////////////////\n\nfunction getEncodable(\n  bytes: RecursiveArray<Bytes.Bytes> | RecursiveArray<Hex.Hex>,\n): Encodable {\n  if (Array.isArray(bytes))\n    return getEncodableList(bytes.map((x) => getEncodable(x)))\n  return getEncodableBytes(bytes as any)\n}\n\nfunction getEncodableList(list: Encodable[]): Encodable {\n  const bodyLength = list.reduce((acc, x) => acc + x.length, 0)\n\n  const sizeOfBodyLength = getSizeOfLength(bodyLength)\n  const length = (() => {\n    if (bodyLength <= 55) return 1 + bodyLength\n    return 1 + sizeOfBodyLength + bodyLength\n  })()\n\n  return {\n    length,\n    encode(cursor: Cursor.Cursor) {\n      if (bodyLength <= 55) {\n        cursor.pushByte(0xc0 + bodyLength)\n      } else {\n        cursor.pushByte(0xc0 + 55 + sizeOfBodyLength)\n        if (sizeOfBodyLength === 1) cursor.pushUint8(bodyLength)\n        else if (sizeOfBodyLength === 2) cursor.pushUint16(bodyLength)\n        else if (sizeOfBodyLength === 3) cursor.pushUint24(bodyLength)\n        else cursor.pushUint32(bodyLength)\n      }\n      for (const { encode } of list) {\n        encode(cursor)\n      }\n    },\n  }\n}\n\nfunction getEncodableBytes(bytesOrHex: Bytes.Bytes | Hex.Hex): Encodable {\n  const bytes =\n    typeof bytesOrHex === 'string' ? Bytes.fromHex(bytesOrHex) : bytesOrHex\n\n  const sizeOfBytesLength = getSizeOfLength(bytes.length)\n  const length = (() => {\n    if (bytes.length === 1 && bytes[0]! < 0x80) return 1\n    if (bytes.length <= 55) return 1 + bytes.length\n    return 1 + sizeOfBytesLength + bytes.length\n  })()\n\n  return {\n    length,\n    encode(cursor: Cursor.Cursor) {\n      if (bytes.length === 1 && bytes[0]! < 0x80) {\n        cursor.pushBytes(bytes)\n      } else if (bytes.length <= 55) {\n        cursor.pushByte(0x80 + bytes.length)\n        cursor.pushBytes(bytes)\n      } else {\n        cursor.pushByte(0x80 + 55 + sizeOfBytesLength)\n        if (sizeOfBytesLength === 1) cursor.pushUint8(bytes.length)\n        else if (sizeOfBytesLength === 2) cursor.pushUint16(bytes.length)\n        else if (sizeOfBytesLength === 3) cursor.pushUint24(bytes.length)\n        else cursor.pushUint32(bytes.length)\n        cursor.pushBytes(bytes)\n      }\n    },\n  }\n}\n\nfunction getSizeOfLength(length: number) {\n  if (length <= 0xff) return 1\n  if (length <= 0xff_ff) return 2\n  if (length <= 0xff_ff_ff) return 3\n  if (length <= 0xff_ff_ff_ff) return 4\n  throw new Errors.BaseError('Length is too large.')\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}