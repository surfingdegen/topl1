{"ast":null,"code":"import _objectWithoutProperties from \"/Users/mac/Desktop/topl1/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _objectSpread from \"/Users/mac/Desktop/topl1/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nconst _excluded = [\"address\", \"factory\", \"factoryData\", \"hash\", \"signature\", \"verifierAddress\"];\nimport { SignatureErc6492 } from 'ox/erc6492';\nimport { SignatureErc8010 } from 'ox/erc8010';\nimport { erc1271Abi, erc6492SignatureValidatorAbi, multicall3Abi } from '../../constants/abis.js';\nimport { erc6492SignatureValidatorByteCode, multicall3Bytecode } from '../../constants/contracts.js';\nimport { CallExecutionError, ContractFunctionExecutionError } from '../../errors/contract.js';\nimport { encodeDeployData } from '../../utils/abi/encodeDeployData.js';\nimport { encodeFunctionData } from '../../utils/abi/encodeFunctionData.js';\nimport { getAddress } from '../../utils/address/getAddress.js';\nimport { isAddressEqual } from '../../utils/address/isAddressEqual.js';\nimport { verifyAuthorization } from '../../utils/authorization/verifyAuthorization.js';\nimport { concatHex } from '../../utils/data/concat.js';\nimport { isHex } from '../../utils/data/isHex.js';\nimport { hexToBool } from '../../utils/encoding/fromHex.js';\nimport { bytesToHex, numberToHex } from '../../utils/encoding/toHex.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { recoverAddress } from '../../utils/signature/recoverAddress.js';\nimport { serializeSignature } from '../../utils/signature/serializeSignature.js';\nimport { call } from './call.js';\nimport { getCode } from './getCode.js';\nimport { readContract } from './readContract.js';\n/**\n * Verifies a message hash onchain using ERC-6492.\n *\n * @param client - Client to use.\n * @param parameters - {@link VerifyHashParameters}\n * @returns Whether or not the signature is valid. {@link VerifyHashReturnType}\n */\nexport async function verifyHash(client, parameters) {\n  var _parameters$universal, _chain$contracts, _parameters$multicall, _chain$contracts2;\n  const {\n    address,\n    chain = client.chain,\n    hash,\n    erc6492VerifierAddress: verifierAddress = (_parameters$universal = parameters.universalSignatureVerifierAddress) !== null && _parameters$universal !== void 0 ? _parameters$universal : chain === null || chain === void 0 || (_chain$contracts = chain.contracts) === null || _chain$contracts === void 0 || (_chain$contracts = _chain$contracts.erc6492Verifier) === null || _chain$contracts === void 0 ? void 0 : _chain$contracts.address,\n    multicallAddress = (_parameters$multicall = parameters.multicallAddress) !== null && _parameters$multicall !== void 0 ? _parameters$multicall : chain === null || chain === void 0 || (_chain$contracts2 = chain.contracts) === null || _chain$contracts2 === void 0 || (_chain$contracts2 = _chain$contracts2.multicall3) === null || _chain$contracts2 === void 0 ? void 0 : _chain$contracts2.address\n  } = parameters;\n  if (chain !== null && chain !== void 0 && chain.verifyHash) return await chain.verifyHash(client, parameters);\n  const signature = (() => {\n    const signature = parameters.signature;\n    if (isHex(signature)) return signature;\n    if (typeof signature === 'object' && 'r' in signature && 's' in signature) return serializeSignature(signature);\n    return bytesToHex(signature);\n  })();\n  try {\n    if (SignatureErc8010.validate(signature)) return await verifyErc8010(client, _objectSpread(_objectSpread({}, parameters), {}, {\n      multicallAddress,\n      signature\n    }));\n    return await verifyErc6492(client, _objectSpread(_objectSpread({}, parameters), {}, {\n      verifierAddress,\n      signature\n    }));\n  } catch (error) {\n    // Fallback attempt to verify the signature via ECDSA recovery.\n    try {\n      const verified = isAddressEqual(getAddress(address), await recoverAddress({\n        hash,\n        signature\n      }));\n      if (verified) return true;\n    } catch (_unused) {}\n    if (error instanceof VerificationError) {\n      // if the execution fails, the signature was not valid and an internal method inside of the validator reverted\n      // this can happen for many reasons, for example if signer can not be recovered from the signature\n      // or if the signature has no valid format\n      return false;\n    }\n    throw error;\n  }\n}\n/** @internal */\nexport async function verifyErc8010(client, parameters) {\n  var _results;\n  const {\n    address,\n    blockNumber,\n    blockTag,\n    hash,\n    multicallAddress\n  } = parameters;\n  const {\n    authorization: authorization_ox,\n    data: initData,\n    signature,\n    to\n  } = SignatureErc8010.unwrap(parameters.signature);\n  // Check if already delegated\n  const code = await getCode(client, {\n    address,\n    blockNumber,\n    blockTag\n  });\n  // If already delegated, perform standard ERC-1271 verification.\n  if (code === concatHex(['0xef0100', authorization_ox.address])) return await verifyErc1271(client, {\n    address,\n    blockNumber,\n    blockTag,\n    hash,\n    signature\n  });\n  const authorization = {\n    address: authorization_ox.address,\n    chainId: Number(authorization_ox.chainId),\n    nonce: Number(authorization_ox.nonce),\n    r: numberToHex(authorization_ox.r, {\n      size: 32\n    }),\n    s: numberToHex(authorization_ox.s, {\n      size: 32\n    }),\n    yParity: authorization_ox.yParity\n  };\n  const valid = await verifyAuthorization({\n    address,\n    authorization\n  });\n  if (!valid) throw new VerificationError();\n  // Deployless verification.\n  const results = await getAction(client, readContract, 'readContract')(_objectSpread(_objectSpread({}, multicallAddress ? {\n    address: multicallAddress\n  } : {\n    code: multicall3Bytecode\n  }), {}, {\n    authorizationList: [authorization],\n    abi: multicall3Abi,\n    blockNumber,\n    blockTag: 'pending',\n    functionName: 'aggregate3',\n    args: [[...(initData ? [{\n      allowFailure: true,\n      target: to !== null && to !== void 0 ? to : address,\n      callData: initData\n    }] : []), {\n      allowFailure: true,\n      target: address,\n      callData: encodeFunctionData({\n        abi: erc1271Abi,\n        functionName: 'isValidSignature',\n        args: [hash, signature]\n      })\n    }]]\n  }));\n  const data = (_results = results[results.length - 1]) === null || _results === void 0 ? void 0 : _results.returnData;\n  if (data !== null && data !== void 0 && data.startsWith('0x1626ba7e')) return true;\n  throw new VerificationError();\n}\n/** @internal */\n// biome-ignore lint/correctness/noUnusedVariables: _\nasync function verifyErc6492(client, parameters) {\n  const {\n      address,\n      factory,\n      factoryData,\n      hash,\n      signature,\n      verifierAddress\n    } = parameters,\n    rest = _objectWithoutProperties(parameters, _excluded);\n  const wrappedSignature = await (async () => {\n    // If no `factory` or `factoryData` is provided, it is assumed that the\n    // address is not a Smart Account, or the Smart Account is already deployed.\n    if (!factory && !factoryData) return signature;\n    // If the signature is already wrapped, return the signature.\n    if (SignatureErc6492.validate(signature)) return signature;\n    // If the Smart Account is not deployed, wrap the signature with a 6492 wrapper\n    // to perform counterfactual validation.\n    return SignatureErc6492.wrap({\n      data: factoryData,\n      signature,\n      to: factory\n    });\n  })();\n  const args = verifierAddress ? _objectSpread({\n    to: verifierAddress,\n    data: encodeFunctionData({\n      abi: erc6492SignatureValidatorAbi,\n      functionName: 'isValidSig',\n      args: [address, hash, wrappedSignature]\n    })\n  }, rest) : _objectSpread({\n    data: encodeDeployData({\n      abi: erc6492SignatureValidatorAbi,\n      args: [address, hash, wrappedSignature],\n      bytecode: erc6492SignatureValidatorByteCode\n    })\n  }, rest);\n  const {\n    data\n  } = await getAction(client, call, 'call')(args).catch(error => {\n    if (error instanceof CallExecutionError) throw new VerificationError();\n    throw error;\n  });\n  if (hexToBool(data !== null && data !== void 0 ? data : '0x0')) return true;\n  throw new VerificationError();\n}\n/** @internal */\nexport async function verifyErc1271(client, parameters) {\n  const {\n    address,\n    blockNumber,\n    blockTag,\n    hash,\n    signature\n  } = parameters;\n  const result = await getAction(client, readContract, 'readContract')({\n    address,\n    abi: erc1271Abi,\n    args: [hash, signature],\n    blockNumber,\n    blockTag,\n    functionName: 'isValidSignature'\n  }).catch(error => {\n    if (error instanceof ContractFunctionExecutionError) throw new VerificationError();\n    throw error;\n  });\n  if (result.startsWith('0x1626ba7e')) return true;\n  throw new VerificationError();\n}\nclass VerificationError extends Error {}","map":{"version":3,"names":["SignatureErc6492","SignatureErc8010","erc1271Abi","erc6492SignatureValidatorAbi","multicall3Abi","erc6492SignatureValidatorByteCode","multicall3Bytecode","CallExecutionError","ContractFunctionExecutionError","encodeDeployData","encodeFunctionData","getAddress","isAddressEqual","verifyAuthorization","concatHex","isHex","hexToBool","bytesToHex","numberToHex","getAction","recoverAddress","serializeSignature","call","getCode","readContract","verifyHash","client","parameters","_parameters$universal","_chain$contracts","_parameters$multicall","_chain$contracts2","address","chain","hash","erc6492VerifierAddress","verifierAddress","universalSignatureVerifierAddress","contracts","erc6492Verifier","multicallAddress","multicall3","signature","validate","verifyErc8010","_objectSpread","verifyErc6492","error","verified","_unused","VerificationError","_results","blockNumber","blockTag","authorization","authorization_ox","data","initData","to","unwrap","code","verifyErc1271","chainId","Number","nonce","r","size","s","yParity","valid","results","authorizationList","abi","functionName","args","allowFailure","target","callData","length","returnData","startsWith","factory","factoryData","rest","_objectWithoutProperties","_excluded","wrappedSignature","wrap","bytecode","catch","result","Error"],"sources":["/Users/mac/Desktop/topl1/frontend/node_modules/viem/actions/public/verifyHash.ts"],"sourcesContent":["import type { Address } from 'abitype'\nimport { SignatureErc6492 } from 'ox/erc6492'\nimport { SignatureErc8010 } from 'ox/erc8010'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  erc1271Abi,\n  erc6492SignatureValidatorAbi,\n  multicall3Abi,\n} from '../../constants/abis.js'\nimport {\n  erc6492SignatureValidatorByteCode,\n  multicall3Bytecode,\n} from '../../constants/contracts.js'\nimport {\n  CallExecutionError,\n  ContractFunctionExecutionError,\n} from '../../errors/contract.js'\nimport type { InvalidHexBooleanError } from '../../errors/encoding.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { ByteArray, Hex, Signature } from '../../types/misc.js'\nimport type { OneOf } from '../../types/utils.js'\nimport {\n  type EncodeDeployDataErrorType,\n  encodeDeployData,\n} from '../../utils/abi/encodeDeployData.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  encodeFunctionData,\n} from '../../utils/abi/encodeFunctionData.js'\nimport {\n  type GetAddressErrorType,\n  getAddress,\n} from '../../utils/address/getAddress.js'\nimport {\n  type IsAddressEqualErrorType,\n  isAddressEqual,\n} from '../../utils/address/isAddressEqual.js'\nimport { verifyAuthorization } from '../../utils/authorization/verifyAuthorization.js'\nimport { type ConcatHexErrorType, concatHex } from '../../utils/data/concat.js'\nimport { type IsHexErrorType, isHex } from '../../utils/data/isHex.js'\nimport { hexToBool } from '../../utils/encoding/fromHex.js'\nimport {\n  type BytesToHexErrorType,\n  bytesToHex,\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\nimport { getAction } from '../../utils/getAction.js'\nimport {\n  type RecoverAddressErrorType,\n  recoverAddress,\n} from '../../utils/signature/recoverAddress.js'\nimport {\n  type SerializeSignatureErrorType,\n  serializeSignature,\n} from '../../utils/signature/serializeSignature.js'\nimport { type CallErrorType, type CallParameters, call } from './call.js'\nimport { type GetCodeErrorType, getCode } from './getCode.js'\nimport { type ReadContractErrorType, readContract } from './readContract.js'\n\nexport type VerifyHashParameters = Pick<\n  CallParameters,\n  'blockNumber' | 'blockTag'\n> & {\n  /** The address that signed the original message. */\n  address: Address\n  /** The chain to use. */\n  chain?: Chain | null | undefined\n  /** The address of the ERC-6492 signature verifier contract. */\n  erc6492VerifierAddress?: Address | undefined\n  /** The hash to be verified. */\n  hash: Hex\n  /** Multicall3 address for ERC-8010 verification. */\n  multicallAddress?: Address | undefined\n  /** The signature that was generated by signing the message with the address's private key. */\n  signature: Hex | ByteArray | Signature\n  /** @deprecated use `erc6492VerifierAddress` instead. */\n  universalSignatureVerifierAddress?: Address | undefined\n} & OneOf<{ factory: Address; factoryData: Hex } | {}>\n\nexport type VerifyHashReturnType = boolean\n\nexport type VerifyHashErrorType =\n  | BytesToHexErrorType\n  | CallErrorType\n  | ConcatHexErrorType\n  | EncodeDeployDataErrorType\n  | EncodeFunctionDataErrorType\n  | ErrorType\n  | GetAddressErrorType\n  | GetCodeErrorType\n  | InvalidHexBooleanError\n  | IsAddressEqualErrorType\n  | IsHexErrorType\n  | NumberToHexErrorType\n  | ReadContractErrorType\n  | RecoverAddressErrorType\n  | SerializeSignatureErrorType\n\n/**\n * Verifies a message hash onchain using ERC-6492.\n *\n * @param client - Client to use.\n * @param parameters - {@link VerifyHashParameters}\n * @returns Whether or not the signature is valid. {@link VerifyHashReturnType}\n */\nexport async function verifyHash<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: VerifyHashParameters,\n): Promise<VerifyHashReturnType> {\n  const {\n    address,\n    chain = client.chain,\n    hash,\n    erc6492VerifierAddress:\n      verifierAddress = parameters.universalSignatureVerifierAddress ??\n      chain?.contracts?.erc6492Verifier?.address,\n    multicallAddress = parameters.multicallAddress ??\n      chain?.contracts?.multicall3?.address,\n  } = parameters\n\n  if (chain?.verifyHash) return await chain.verifyHash(client, parameters)\n\n  const signature = (() => {\n    const signature = parameters.signature\n    if (isHex(signature)) return signature\n    if (typeof signature === 'object' && 'r' in signature && 's' in signature)\n      return serializeSignature(signature)\n    return bytesToHex(signature)\n  })()\n\n  try {\n    if (SignatureErc8010.validate(signature))\n      return await verifyErc8010(client, {\n        ...parameters,\n        multicallAddress,\n        signature,\n      })\n    return await verifyErc6492(client, {\n      ...parameters,\n      verifierAddress,\n      signature,\n    })\n  } catch (error) {\n    // Fallback attempt to verify the signature via ECDSA recovery.\n    try {\n      const verified = isAddressEqual(\n        getAddress(address),\n        await recoverAddress({ hash, signature }),\n      )\n      if (verified) return true\n    } catch {}\n\n    if (error instanceof VerificationError) {\n      // if the execution fails, the signature was not valid and an internal method inside of the validator reverted\n      // this can happen for many reasons, for example if signer can not be recovered from the signature\n      // or if the signature has no valid format\n      return false\n    }\n\n    throw error\n  }\n}\n\n/** @internal */\nexport async function verifyErc8010(\n  client: Client,\n  parameters: verifyErc8010.Parameters,\n) {\n  const { address, blockNumber, blockTag, hash, multicallAddress } = parameters\n\n  const {\n    authorization: authorization_ox,\n    data: initData,\n    signature,\n    to,\n  } = SignatureErc8010.unwrap(parameters.signature)\n\n  // Check if already delegated\n  const code = await getCode(client, {\n    address,\n    blockNumber,\n    blockTag,\n  } as never)\n\n  // If already delegated, perform standard ERC-1271 verification.\n  if (code === concatHex(['0xef0100', authorization_ox.address]))\n    return await verifyErc1271(client, {\n      address,\n      blockNumber,\n      blockTag,\n      hash,\n      signature,\n    })\n\n  const authorization = {\n    address: authorization_ox.address,\n    chainId: Number(authorization_ox.chainId),\n    nonce: Number(authorization_ox.nonce),\n    r: numberToHex(authorization_ox.r, { size: 32 }),\n    s: numberToHex(authorization_ox.s, { size: 32 }),\n    yParity: authorization_ox.yParity,\n  } as const\n\n  const valid = await verifyAuthorization({\n    address,\n    authorization,\n  })\n  if (!valid) throw new VerificationError()\n\n  // Deployless verification.\n  const results = await getAction(\n    client,\n    readContract,\n    'readContract',\n  )({\n    ...(multicallAddress\n      ? { address: multicallAddress }\n      : { code: multicall3Bytecode }),\n    authorizationList: [authorization],\n    abi: multicall3Abi,\n    blockNumber,\n    blockTag: 'pending',\n    functionName: 'aggregate3',\n    args: [\n      [\n        ...(initData\n          ? ([\n              {\n                allowFailure: true,\n                target: to ?? address,\n                callData: initData,\n              },\n            ] as const)\n          : []),\n        {\n          allowFailure: true,\n          target: address,\n          callData: encodeFunctionData({\n            abi: erc1271Abi,\n            functionName: 'isValidSignature',\n            args: [hash, signature],\n          }),\n        },\n      ],\n    ],\n  })\n\n  const data = results[results.length - 1]?.returnData\n\n  if (data?.startsWith('0x1626ba7e')) return true\n  throw new VerificationError()\n}\n\nexport namespace verifyErc8010 {\n  export type Parameters = Pick<CallParameters, 'blockNumber' | 'blockTag'> & {\n    /** The address that signed the original message. */\n    address: Address\n    /** The hash to be verified. */\n    hash: Hex\n    /** Multicall3 address for ERC-8010 verification. */\n    multicallAddress?: Address | undefined\n    /** The signature that was generated by signing the message with the address's private key. */\n    signature: Hex\n  }\n}\n\n/** @internal */\n// biome-ignore lint/correctness/noUnusedVariables: _\nasync function verifyErc6492(\n  client: Client,\n  parameters: verifyErc6492.Parameters,\n) {\n  const {\n    address,\n    factory,\n    factoryData,\n    hash,\n    signature,\n    verifierAddress,\n    ...rest\n  } = parameters\n\n  const wrappedSignature = await (async () => {\n    // If no `factory` or `factoryData` is provided, it is assumed that the\n    // address is not a Smart Account, or the Smart Account is already deployed.\n    if (!factory && !factoryData) return signature\n\n    // If the signature is already wrapped, return the signature.\n    if (SignatureErc6492.validate(signature)) return signature\n\n    // If the Smart Account is not deployed, wrap the signature with a 6492 wrapper\n    // to perform counterfactual validation.\n    return SignatureErc6492.wrap({\n      data: factoryData!,\n      signature,\n      to: factory!,\n    })\n  })()\n\n  const args = verifierAddress\n    ? ({\n        to: verifierAddress,\n        data: encodeFunctionData({\n          abi: erc6492SignatureValidatorAbi,\n          functionName: 'isValidSig',\n          args: [address, hash, wrappedSignature],\n        }),\n        ...rest,\n      } as unknown as CallParameters)\n    : ({\n        data: encodeDeployData({\n          abi: erc6492SignatureValidatorAbi,\n          args: [address, hash, wrappedSignature],\n          bytecode: erc6492SignatureValidatorByteCode,\n        }),\n        ...rest,\n      } as unknown as CallParameters)\n\n  const { data } = await getAction(\n    client,\n    call,\n    'call',\n  )(args).catch((error) => {\n    if (error instanceof CallExecutionError) throw new VerificationError()\n    throw error\n  })\n\n  if (hexToBool(data ?? '0x0')) return true\n  throw new VerificationError()\n}\n\nexport namespace verifyErc6492 {\n  export type Parameters = Pick<CallParameters, 'blockNumber' | 'blockTag'> & {\n    /** The address that signed the original message. */\n    address: Address\n    /** The hash to be verified. */\n    hash: Hex\n    /** The signature that was generated by signing the message with the address's private key. */\n    signature: Hex\n    /** The address of the ERC-6492 signature verifier contract. */\n    verifierAddress?: Address | undefined\n  } & OneOf<{ factory: Address; factoryData: Hex } | {}>\n}\n\n/** @internal */\nexport async function verifyErc1271(\n  client: Client,\n  parameters: verifyErc1271.Parameters,\n) {\n  const { address, blockNumber, blockTag, hash, signature } = parameters\n\n  const result = await getAction(\n    client,\n    readContract,\n    'readContract',\n  )({\n    address,\n    abi: erc1271Abi,\n    args: [hash, signature],\n    blockNumber,\n    blockTag,\n    functionName: 'isValidSignature',\n  }).catch((error) => {\n    if (error instanceof ContractFunctionExecutionError)\n      throw new VerificationError()\n    throw error\n  })\n\n  if (result.startsWith('0x1626ba7e')) return true\n  throw new VerificationError()\n}\n\nexport namespace verifyErc1271 {\n  export type Parameters = Pick<CallParameters, 'blockNumber' | 'blockTag'> & {\n    /** The address that signed the original message. */\n    address: Address\n    /** The hash to be verified. */\n    hash: Hex\n    /** The signature that was generated by signing the message with the address's private key. */\n    signature: Hex\n  }\n}\n\nclass VerificationError extends Error {}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}