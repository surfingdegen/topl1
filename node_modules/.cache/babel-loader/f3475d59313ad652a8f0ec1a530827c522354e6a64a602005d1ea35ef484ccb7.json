{"ast":null,"code":"import { isHex } from '../data/isHex.js';\nimport { size } from '../data/size.js';\nimport { hexToBigInt, hexToNumber } from '../encoding/fromHex.js';\nimport { toHex } from '../encoding/toHex.js';\nexport async function recoverPublicKey(_ref) {\n  let {\n    hash,\n    signature\n  } = _ref;\n  const hashHex = isHex(hash) ? hash : toHex(hash);\n  const {\n    secp256k1\n  } = await import('@noble/curves/secp256k1');\n  const signature_ = (() => {\n    // typeof signature: `Signature`\n    if (typeof signature === 'object' && 'r' in signature && 's' in signature) {\n      const {\n        r,\n        s,\n        v,\n        yParity\n      } = signature;\n      const yParityOrV = Number(yParity !== null && yParity !== void 0 ? yParity : v);\n      const recoveryBit = toRecoveryBit(yParityOrV);\n      return new secp256k1.Signature(hexToBigInt(r), hexToBigInt(s)).addRecoveryBit(recoveryBit);\n    }\n    // typeof signature: `Hex | ByteArray`\n    const signatureHex = isHex(signature) ? signature : toHex(signature);\n    if (size(signatureHex) !== 65) throw new Error('invalid signature length');\n    const yParityOrV = hexToNumber(\"0x\".concat(signatureHex.slice(130)));\n    const recoveryBit = toRecoveryBit(yParityOrV);\n    return secp256k1.Signature.fromCompact(signatureHex.substring(2, 130)).addRecoveryBit(recoveryBit);\n  })();\n  const publicKey = signature_.recoverPublicKey(hashHex.substring(2)).toHex(false);\n  return \"0x\".concat(publicKey);\n}\nfunction toRecoveryBit(yParityOrV) {\n  if (yParityOrV === 0 || yParityOrV === 1) return yParityOrV;\n  if (yParityOrV === 27) return 0;\n  if (yParityOrV === 28) return 1;\n  throw new Error('Invalid yParityOrV value');\n}","map":{"version":3,"names":["isHex","size","hexToBigInt","hexToNumber","toHex","recoverPublicKey","_ref","hash","signature","hashHex","secp256k1","signature_","r","s","v","yParity","yParityOrV","Number","recoveryBit","toRecoveryBit","Signature","addRecoveryBit","signatureHex","Error","concat","slice","fromCompact","substring","publicKey"],"sources":["/Users/mac/Desktop/topl1/frontend/node_modules/viem/utils/signature/recoverPublicKey.ts"],"sourcesContent":["import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex, Signature } from '../../types/misc.js'\nimport { type IsHexErrorType, isHex } from '../data/isHex.js'\nimport { size } from '../data/size.js'\nimport {\n  type HexToNumberErrorType,\n  hexToBigInt,\n  hexToNumber,\n} from '../encoding/fromHex.js'\nimport { toHex } from '../encoding/toHex.js'\n\nexport type RecoverPublicKeyParameters = {\n  hash: Hex | ByteArray\n  signature: Hex | ByteArray | Signature\n}\n\nexport type RecoverPublicKeyReturnType = Hex\n\nexport type RecoverPublicKeyErrorType =\n  | HexToNumberErrorType\n  | IsHexErrorType\n  | ErrorType\n\nexport async function recoverPublicKey({\n  hash,\n  signature,\n}: RecoverPublicKeyParameters): Promise<RecoverPublicKeyReturnType> {\n  const hashHex = isHex(hash) ? hash : toHex(hash)\n\n  const { secp256k1 } = await import('@noble/curves/secp256k1')\n  const signature_ = (() => {\n    // typeof signature: `Signature`\n    if (typeof signature === 'object' && 'r' in signature && 's' in signature) {\n      const { r, s, v, yParity } = signature\n      const yParityOrV = Number(yParity ?? v)!\n      const recoveryBit = toRecoveryBit(yParityOrV)\n      return new secp256k1.Signature(\n        hexToBigInt(r),\n        hexToBigInt(s),\n      ).addRecoveryBit(recoveryBit)\n    }\n\n    // typeof signature: `Hex | ByteArray`\n    const signatureHex = isHex(signature) ? signature : toHex(signature)\n    if (size(signatureHex) !== 65) throw new Error('invalid signature length')\n    const yParityOrV = hexToNumber(`0x${signatureHex.slice(130)}`)\n    const recoveryBit = toRecoveryBit(yParityOrV)\n    return secp256k1.Signature.fromCompact(\n      signatureHex.substring(2, 130),\n    ).addRecoveryBit(recoveryBit)\n  })()\n\n  const publicKey = signature_\n    .recoverPublicKey(hashHex.substring(2))\n    .toHex(false)\n  return `0x${publicKey}`\n}\n\nfunction toRecoveryBit(yParityOrV: number) {\n  if (yParityOrV === 0 || yParityOrV === 1) return yParityOrV\n  if (yParityOrV === 27) return 0\n  if (yParityOrV === 28) return 1\n  throw new Error('Invalid yParityOrV value')\n}\n"],"mappings":"AAEA,SAA8BA,KAAK,QAAQ,kBAAkB;AAC7D,SAASC,IAAI,QAAQ,iBAAiB;AACtC,SAEEC,WAAW,EACXC,WAAW,QACN,wBAAwB;AAC/B,SAASC,KAAK,QAAQ,sBAAsB;AAc5C,OAAO,eAAeC,gBAAgBA,CAAAC,IAAA,EAGT;EAAA,IAHU;IACrCC,IAAI;IACJC;EAAS,CACkB,GAAAF,IAAA;EAC3B,MAAMG,OAAO,GAAGT,KAAK,CAACO,IAAI,CAAC,GAAGA,IAAI,GAAGH,KAAK,CAACG,IAAI,CAAC;EAEhD,MAAM;IAAEG;EAAS,CAAE,GAAG,MAAM,MAAM,CAAC,yBAAyB,CAAC;EAC7D,MAAMC,UAAU,GAAG,CAAC,MAAK;IACvB;IACA,IAAI,OAAOH,SAAS,KAAK,QAAQ,IAAI,GAAG,IAAIA,SAAS,IAAI,GAAG,IAAIA,SAAS,EAAE;MACzE,MAAM;QAAEI,CAAC;QAAEC,CAAC;QAAEC,CAAC;QAAEC;MAAO,CAAE,GAAGP,SAAS;MACtC,MAAMQ,UAAU,GAAGC,MAAM,CAACF,OAAO,aAAPA,OAAO,cAAPA,OAAO,GAAID,CAAC,CAAE;MACxC,MAAMI,WAAW,GAAGC,aAAa,CAACH,UAAU,CAAC;MAC7C,OAAO,IAAIN,SAAS,CAACU,SAAS,CAC5BlB,WAAW,CAACU,CAAC,CAAC,EACdV,WAAW,CAACW,CAAC,CAAC,CACf,CAACQ,cAAc,CAACH,WAAW,CAAC;IAC/B;IAEA;IACA,MAAMI,YAAY,GAAGtB,KAAK,CAACQ,SAAS,CAAC,GAAGA,SAAS,GAAGJ,KAAK,CAACI,SAAS,CAAC;IACpE,IAAIP,IAAI,CAACqB,YAAY,CAAC,KAAK,EAAE,EAAE,MAAM,IAAIC,KAAK,CAAC,0BAA0B,CAAC;IAC1E,MAAMP,UAAU,GAAGb,WAAW,MAAAqB,MAAA,CAAMF,YAAY,CAACG,KAAK,CAAC,GAAG,CAAC,CAAE,CAAC;IAC9D,MAAMP,WAAW,GAAGC,aAAa,CAACH,UAAU,CAAC;IAC7C,OAAON,SAAS,CAACU,SAAS,CAACM,WAAW,CACpCJ,YAAY,CAACK,SAAS,CAAC,CAAC,EAAE,GAAG,CAAC,CAC/B,CAACN,cAAc,CAACH,WAAW,CAAC;EAC/B,CAAC,EAAC,CAAE;EAEJ,MAAMU,SAAS,GAAGjB,UAAU,CACzBN,gBAAgB,CAACI,OAAO,CAACkB,SAAS,CAAC,CAAC,CAAC,CAAC,CACtCvB,KAAK,CAAC,KAAK,CAAC;EACf,YAAAoB,MAAA,CAAYI,SAAS;AACvB;AAEA,SAAST,aAAaA,CAACH,UAAkB;EACvC,IAAIA,UAAU,KAAK,CAAC,IAAIA,UAAU,KAAK,CAAC,EAAE,OAAOA,UAAU;EAC3D,IAAIA,UAAU,KAAK,EAAE,EAAE,OAAO,CAAC;EAC/B,IAAIA,UAAU,KAAK,EAAE,EAAE,OAAO,CAAC;EAC/B,MAAM,IAAIO,KAAK,CAAC,0BAA0B,CAAC;AAC7C","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}