{"ast":null,"code":"import { BlockNotFoundError } from '../../errors/block.js';\nimport { TransactionNotFoundError, TransactionReceiptNotFoundError, WaitForTransactionReceiptTimeoutError } from '../../errors/transaction.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { observe } from '../../utils/observe.js';\nimport { withResolvers } from '../../utils/promise/withResolvers.js';\nimport { withRetry } from '../../utils/promise/withRetry.js';\nimport { stringify } from '../../utils/stringify.js';\nimport { getBlock } from './getBlock.js';\nimport { getTransaction } from './getTransaction.js';\nimport { getTransactionReceipt } from './getTransactionReceipt.js';\nimport { watchBlockNumber } from './watchBlockNumber.js';\n/**\n * Waits for the [Transaction](https://viem.sh/docs/glossary/terms#transaction) to be included on a [Block](https://viem.sh/docs/glossary/terms#block) (one confirmation), and then returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms#transaction-receipt).\n *\n * - Docs: https://viem.sh/docs/actions/public/waitForTransactionReceipt\n * - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_sending-transactions\n * - JSON-RPC Methods:\n *   - Polls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt) on each block until it has been processed.\n *   - If a Transaction has been replaced:\n *     - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) and extracts the transactions\n *     - Checks if one of the Transactions is a replacement\n *     - If so, calls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt).\n *\n * The `waitForTransactionReceipt` action additionally supports Replacement detection (e.g. sped up Transactions).\n *\n * Transactions can be replaced when a user modifies their transaction in their wallet (to speed up or cancel). Transactions are replaced when they are sent from the same nonce.\n *\n * There are 3 types of Transaction Replacement reasons:\n *\n * - `repriced`: The gas price has been modified (e.g. different `maxFeePerGas`)\n * - `cancelled`: The Transaction has been cancelled (e.g. `value === 0n`)\n * - `replaced`: The Transaction has been replaced (e.g. different `value` or `data`)\n *\n * @param client - Client to use\n * @param parameters - {@link WaitForTransactionReceiptParameters}\n * @returns The transaction receipt. {@link WaitForTransactionReceiptReturnType}\n *\n * @example\n * import { createPublicClient, waitForTransactionReceipt, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const transactionReceipt = await waitForTransactionReceipt(client, {\n *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n * })\n */\nexport async function waitForTransactionReceipt(client, parameters) {\n  const {\n    checkReplacement = true,\n    confirmations = 1,\n    hash,\n    onReplaced,\n    retryCount = 6,\n    retryDelay = _ref => {\n      let {\n        count\n      } = _ref;\n      return ~~(1 << count) * 200;\n    },\n    // exponential backoff\n    timeout = 180000\n  } = parameters;\n  const observerId = stringify(['waitForTransactionReceipt', client.uid, hash]);\n  const pollingInterval = (_client$chain => {\n    if (parameters.pollingInterval) return parameters.pollingInterval;\n    if ((_client$chain = client.chain) !== null && _client$chain !== void 0 && _client$chain.experimental_preconfirmationTime) return client.chain.experimental_preconfirmationTime;\n    return client.pollingInterval;\n  })();\n  let transaction;\n  let replacedTransaction;\n  let receipt;\n  let retrying = false;\n  let _unobserve;\n  let _unwatch;\n  const {\n    promise,\n    resolve,\n    reject\n  } = withResolvers();\n  const timer = timeout ? setTimeout(() => {\n    var _unwatch2, _unobserve2;\n    (_unwatch2 = _unwatch) === null || _unwatch2 === void 0 || _unwatch2();\n    (_unobserve2 = _unobserve) === null || _unobserve2 === void 0 || _unobserve2();\n    reject(new WaitForTransactionReceiptTimeoutError({\n      hash\n    }));\n  }, timeout) : undefined;\n  _unobserve = observe(observerId, {\n    onReplaced,\n    resolve,\n    reject\n  }, async emit => {\n    receipt = await getAction(client, getTransactionReceipt, 'getTransactionReceipt')({\n      hash\n    }).catch(() => undefined);\n    if (receipt && confirmations <= 1) {\n      var _unobserve3;\n      clearTimeout(timer);\n      emit.resolve(receipt);\n      (_unobserve3 = _unobserve) === null || _unobserve3 === void 0 || _unobserve3();\n      return;\n    }\n    _unwatch = getAction(client, watchBlockNumber, 'watchBlockNumber')({\n      emitMissed: true,\n      emitOnBegin: true,\n      poll: true,\n      pollingInterval,\n      async onBlockNumber(blockNumber_) {\n        const done = fn => {\n          var _unwatch3, _unobserve4;\n          clearTimeout(timer);\n          (_unwatch3 = _unwatch) === null || _unwatch3 === void 0 || _unwatch3();\n          fn();\n          (_unobserve4 = _unobserve) === null || _unobserve4 === void 0 || _unobserve4();\n        };\n        let blockNumber = blockNumber_;\n        if (retrying) return;\n        try {\n          // If we already have a valid receipt, let's check if we have enough\n          // confirmations. If we do, then we can resolve.\n          if (receipt) {\n            if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations)) return;\n            done(() => emit.resolve(receipt));\n            return;\n          }\n          // Get the transaction to check if it's been replaced.\n          // We need to retry as some RPC Providers may be slow to sync\n          // up mined transactions.\n          if (checkReplacement && !transaction) {\n            retrying = true;\n            await withRetry(async () => {\n              transaction = await getAction(client, getTransaction, 'getTransaction')({\n                hash\n              });\n              if (transaction.blockNumber) blockNumber = transaction.blockNumber;\n            }, {\n              delay: retryDelay,\n              retryCount\n            });\n            retrying = false;\n          }\n          // Get the receipt to check if it's been processed.\n          receipt = await getAction(client, getTransactionReceipt, 'getTransactionReceipt')({\n            hash\n          });\n          // Check if we have enough confirmations. If not, continue polling.\n          if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations)) return;\n          done(() => emit.resolve(receipt));\n        } catch (err) {\n          // If the receipt is not found, the transaction will be pending.\n          // We need to check if it has potentially been replaced.\n          if (err instanceof TransactionNotFoundError || err instanceof TransactionReceiptNotFoundError) {\n            if (!transaction) {\n              retrying = false;\n              return;\n            }\n            try {\n              replacedTransaction = transaction;\n              // Let's retrieve the transactions from the current block.\n              // We need to retry as some RPC Providers may be slow to sync\n              // up mined blocks.\n              retrying = true;\n              const block = await withRetry(() => getAction(client, getBlock, 'getBlock')({\n                blockNumber,\n                includeTransactions: true\n              }), {\n                delay: retryDelay,\n                retryCount,\n                shouldRetry: _ref2 => {\n                  let {\n                    error\n                  } = _ref2;\n                  return error instanceof BlockNotFoundError;\n                }\n              });\n              retrying = false;\n              const replacementTransaction = block.transactions.find(_ref3 => {\n                let {\n                  from,\n                  nonce\n                } = _ref3;\n                return from === replacedTransaction.from && nonce === replacedTransaction.nonce;\n              });\n              // If we couldn't find a replacement transaction, continue polling.\n              if (!replacementTransaction) return;\n              // If we found a replacement transaction, return it's receipt.\n              receipt = await getAction(client, getTransactionReceipt, 'getTransactionReceipt')({\n                hash: replacementTransaction.hash\n              });\n              // Check if we have enough confirmations. If not, continue polling.\n              if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations)) return;\n              let reason = 'replaced';\n              if (replacementTransaction.to === replacedTransaction.to && replacementTransaction.value === replacedTransaction.value && replacementTransaction.input === replacedTransaction.input) {\n                reason = 'repriced';\n              } else if (replacementTransaction.from === replacementTransaction.to && replacementTransaction.value === 0n) {\n                reason = 'cancelled';\n              }\n              done(() => {\n                var _emit$onReplaced;\n                (_emit$onReplaced = emit.onReplaced) === null || _emit$onReplaced === void 0 || _emit$onReplaced.call(emit, {\n                  reason,\n                  replacedTransaction: replacedTransaction,\n                  transaction: replacementTransaction,\n                  transactionReceipt: receipt\n                });\n                emit.resolve(receipt);\n              });\n            } catch (err_) {\n              done(() => emit.reject(err_));\n            }\n          } else {\n            done(() => emit.reject(err));\n          }\n        }\n      }\n    });\n  });\n  return promise;\n}","map":{"version":3,"names":["BlockNotFoundError","TransactionNotFoundError","TransactionReceiptNotFoundError","WaitForTransactionReceiptTimeoutError","getAction","observe","withResolvers","withRetry","stringify","getBlock","getTransaction","getTransactionReceipt","watchBlockNumber","waitForTransactionReceipt","client","parameters","checkReplacement","confirmations","hash","onReplaced","retryCount","retryDelay","_ref","count","timeout","observerId","uid","pollingInterval","_client$chain","chain","experimental_preconfirmationTime","transaction","replacedTransaction","receipt","retrying","_unobserve","_unwatch","promise","resolve","reject","timer","setTimeout","_unwatch2","_unobserve2","undefined","emit","catch","_unobserve3","clearTimeout","emitMissed","emitOnBegin","poll","onBlockNumber","blockNumber_","done","fn","_unwatch3","_unobserve4","blockNumber","delay","err","block","includeTransactions","shouldRetry","_ref2","error","replacementTransaction","transactions","find","_ref3","from","nonce","reason","to","value","input","_emit$onReplaced","call","transactionReceipt","err_"],"sources":["/Users/mac/Desktop/topl1/frontend/node_modules/viem/actions/public/waitForTransactionReceipt.ts"],"sourcesContent":["import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { BlockNotFoundError } from '../../errors/block.js'\nimport {\n  TransactionNotFoundError,\n  TransactionReceiptNotFoundError,\n  WaitForTransactionReceiptTimeoutError,\n  type WaitForTransactionReceiptTimeoutErrorType,\n} from '../../errors/transaction.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hash } from '../../types/misc.js'\nimport type { Transaction } from '../../types/transaction.js'\nimport { getAction } from '../../utils/getAction.js'\nimport { type ObserveErrorType, observe } from '../../utils/observe.js'\nimport { withResolvers } from '../../utils/promise/withResolvers.js'\nimport {\n  type WithRetryParameters,\n  withRetry,\n} from '../../utils/promise/withRetry.js'\nimport { stringify } from '../../utils/stringify.js'\n\nimport { type GetBlockErrorType, getBlock } from './getBlock.js'\nimport {\n  type GetTransactionErrorType,\n  type GetTransactionReturnType,\n  getTransaction,\n} from './getTransaction.js'\nimport {\n  type GetTransactionReceiptErrorType,\n  type GetTransactionReceiptReturnType,\n  getTransactionReceipt,\n} from './getTransactionReceipt.js'\nimport {\n  type WatchBlockNumberErrorType,\n  watchBlockNumber,\n} from './watchBlockNumber.js'\n\nexport type ReplacementReason = 'cancelled' | 'replaced' | 'repriced'\nexport type ReplacementReturnType<\n  chain extends Chain | undefined = Chain | undefined,\n> = {\n  reason: ReplacementReason\n  replacedTransaction: Transaction\n  transaction: Transaction\n  transactionReceipt: GetTransactionReceiptReturnType<chain>\n}\n\nexport type WaitForTransactionReceiptReturnType<\n  chain extends Chain | undefined = Chain | undefined,\n> = GetTransactionReceiptReturnType<chain>\n\nexport type WaitForTransactionReceiptParameters<\n  chain extends Chain | undefined = Chain | undefined,\n> = {\n  /**\n   * Whether to check for transaction replacements.\n   * @default true\n   */\n  checkReplacement?: boolean | undefined\n  /**\n   * The number of confirmations (blocks that have passed) to wait before resolving.\n   * @default 1\n   */\n  confirmations?: number | undefined\n  /** The hash of the transaction. */\n  hash: Hash\n  /** Optional callback to emit if the transaction has been replaced. */\n  onReplaced?: ((response: ReplacementReturnType<chain>) => void) | undefined\n  /**\n   * Polling frequency (in ms). Defaults to the client's pollingInterval config.\n   * @default client.pollingInterval\n   */\n  pollingInterval?: number | undefined\n  /**\n   * Number of times to retry if the transaction or block is not found.\n   * @default 6 (exponential backoff)\n   */\n  retryCount?: WithRetryParameters['retryCount'] | undefined\n  /**\n   * Time to wait (in ms) between retries.\n   * @default `({ count }) => ~~(1 << count) * 200` (exponential backoff)\n   */\n  retryDelay?: WithRetryParameters['delay'] | undefined\n  /**\n   * Optional timeout (in milliseconds) to wait before stopping polling.\n   * @default 180_000\n   */\n  timeout?: number | undefined\n}\n\nexport type WaitForTransactionReceiptErrorType =\n  | ObserveErrorType\n  | GetBlockErrorType\n  | GetTransactionErrorType\n  | GetTransactionReceiptErrorType\n  | WatchBlockNumberErrorType\n  | WaitForTransactionReceiptTimeoutErrorType\n  | ErrorType\n\n/**\n * Waits for the [Transaction](https://viem.sh/docs/glossary/terms#transaction) to be included on a [Block](https://viem.sh/docs/glossary/terms#block) (one confirmation), and then returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms#transaction-receipt).\n *\n * - Docs: https://viem.sh/docs/actions/public/waitForTransactionReceipt\n * - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_sending-transactions\n * - JSON-RPC Methods:\n *   - Polls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt) on each block until it has been processed.\n *   - If a Transaction has been replaced:\n *     - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) and extracts the transactions\n *     - Checks if one of the Transactions is a replacement\n *     - If so, calls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt).\n *\n * The `waitForTransactionReceipt` action additionally supports Replacement detection (e.g. sped up Transactions).\n *\n * Transactions can be replaced when a user modifies their transaction in their wallet (to speed up or cancel). Transactions are replaced when they are sent from the same nonce.\n *\n * There are 3 types of Transaction Replacement reasons:\n *\n * - `repriced`: The gas price has been modified (e.g. different `maxFeePerGas`)\n * - `cancelled`: The Transaction has been cancelled (e.g. `value === 0n`)\n * - `replaced`: The Transaction has been replaced (e.g. different `value` or `data`)\n *\n * @param client - Client to use\n * @param parameters - {@link WaitForTransactionReceiptParameters}\n * @returns The transaction receipt. {@link WaitForTransactionReceiptReturnType}\n *\n * @example\n * import { createPublicClient, waitForTransactionReceipt, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const transactionReceipt = await waitForTransactionReceipt(client, {\n *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n * })\n */\nexport async function waitForTransactionReceipt<\n  chain extends Chain | undefined,\n>(\n  client: Client<Transport, chain>,\n  parameters: WaitForTransactionReceiptParameters<chain>,\n): Promise<WaitForTransactionReceiptReturnType<chain>> {\n  const {\n    checkReplacement = true,\n    confirmations = 1,\n    hash,\n    onReplaced,\n    retryCount = 6,\n    retryDelay = ({ count }) => ~~(1 << count) * 200, // exponential backoff\n    timeout = 180_000,\n  } = parameters\n\n  const observerId = stringify(['waitForTransactionReceipt', client.uid, hash])\n\n  const pollingInterval = (() => {\n    if (parameters.pollingInterval) return parameters.pollingInterval\n    if (client.chain?.experimental_preconfirmationTime)\n      return client.chain.experimental_preconfirmationTime\n    return client.pollingInterval\n  })()\n\n  let transaction: GetTransactionReturnType<chain> | undefined\n  let replacedTransaction: GetTransactionReturnType<chain> | undefined\n  let receipt: GetTransactionReceiptReturnType<chain> | undefined\n  let retrying = false\n\n  let _unobserve: () => void\n  let _unwatch: () => void\n\n  const { promise, resolve, reject } =\n    withResolvers<WaitForTransactionReceiptReturnType<chain>>()\n\n  const timer = timeout\n    ? setTimeout(() => {\n        _unwatch?.()\n        _unobserve?.()\n        reject(new WaitForTransactionReceiptTimeoutError({ hash }))\n      }, timeout)\n    : undefined\n\n  _unobserve = observe(\n    observerId,\n    { onReplaced, resolve, reject },\n    async (emit) => {\n      receipt = await getAction(\n        client,\n        getTransactionReceipt,\n        'getTransactionReceipt',\n      )({ hash }).catch(() => undefined)\n\n      if (receipt && confirmations <= 1) {\n        clearTimeout(timer)\n        emit.resolve(receipt)\n        _unobserve?.()\n        return\n      }\n\n      _unwatch = getAction(\n        client,\n        watchBlockNumber,\n        'watchBlockNumber',\n      )({\n        emitMissed: true,\n        emitOnBegin: true,\n        poll: true,\n        pollingInterval,\n        async onBlockNumber(blockNumber_) {\n          const done = (fn: () => void) => {\n            clearTimeout(timer)\n            _unwatch?.()\n            fn()\n            _unobserve?.()\n          }\n\n          let blockNumber = blockNumber_\n\n          if (retrying) return\n\n          try {\n            // If we already have a valid receipt, let's check if we have enough\n            // confirmations. If we do, then we can resolve.\n            if (receipt) {\n              if (\n                confirmations > 1 &&\n                (!receipt.blockNumber ||\n                  blockNumber - receipt.blockNumber + 1n < confirmations)\n              )\n                return\n\n              done(() => emit.resolve(receipt!))\n              return\n            }\n\n            // Get the transaction to check if it's been replaced.\n            // We need to retry as some RPC Providers may be slow to sync\n            // up mined transactions.\n            if (checkReplacement && !transaction) {\n              retrying = true\n              await withRetry(\n                async () => {\n                  transaction = (await getAction(\n                    client,\n                    getTransaction,\n                    'getTransaction',\n                  )({ hash })) as GetTransactionReturnType<chain>\n                  if (transaction.blockNumber)\n                    blockNumber = transaction.blockNumber\n                },\n                {\n                  delay: retryDelay,\n                  retryCount,\n                },\n              )\n              retrying = false\n            }\n\n            // Get the receipt to check if it's been processed.\n            receipt = await getAction(\n              client,\n              getTransactionReceipt,\n              'getTransactionReceipt',\n            )({ hash })\n\n            // Check if we have enough confirmations. If not, continue polling.\n            if (\n              confirmations > 1 &&\n              (!receipt.blockNumber ||\n                blockNumber - receipt.blockNumber + 1n < confirmations)\n            )\n              return\n\n            done(() => emit.resolve(receipt!))\n          } catch (err) {\n            // If the receipt is not found, the transaction will be pending.\n            // We need to check if it has potentially been replaced.\n            if (\n              err instanceof TransactionNotFoundError ||\n              err instanceof TransactionReceiptNotFoundError\n            ) {\n              if (!transaction) {\n                retrying = false\n                return\n              }\n\n              try {\n                replacedTransaction = transaction\n\n                // Let's retrieve the transactions from the current block.\n                // We need to retry as some RPC Providers may be slow to sync\n                // up mined blocks.\n                retrying = true\n                const block = await withRetry(\n                  () =>\n                    getAction(\n                      client,\n                      getBlock,\n                      'getBlock',\n                    )({\n                      blockNumber,\n                      includeTransactions: true,\n                    }),\n                  {\n                    delay: retryDelay,\n                    retryCount,\n                    shouldRetry: ({ error }) =>\n                      error instanceof BlockNotFoundError,\n                  },\n                )\n                retrying = false\n\n                const replacementTransaction = (\n                  block.transactions as {} as Transaction[]\n                ).find(\n                  ({ from, nonce }) =>\n                    from === replacedTransaction!.from &&\n                    nonce === replacedTransaction!.nonce,\n                )\n\n                // If we couldn't find a replacement transaction, continue polling.\n                if (!replacementTransaction) return\n\n                // If we found a replacement transaction, return it's receipt.\n                receipt = await getAction(\n                  client,\n                  getTransactionReceipt,\n                  'getTransactionReceipt',\n                )({\n                  hash: replacementTransaction.hash,\n                })\n\n                // Check if we have enough confirmations. If not, continue polling.\n                if (\n                  confirmations > 1 &&\n                  (!receipt.blockNumber ||\n                    blockNumber - receipt.blockNumber + 1n < confirmations)\n                )\n                  return\n\n                let reason: ReplacementReason = 'replaced'\n                if (\n                  replacementTransaction.to === replacedTransaction.to &&\n                  replacementTransaction.value === replacedTransaction.value &&\n                  replacementTransaction.input === replacedTransaction.input\n                ) {\n                  reason = 'repriced'\n                } else if (\n                  replacementTransaction.from === replacementTransaction.to &&\n                  replacementTransaction.value === 0n\n                ) {\n                  reason = 'cancelled'\n                }\n\n                done(() => {\n                  emit.onReplaced?.({\n                    reason,\n                    replacedTransaction: replacedTransaction! as any,\n                    transaction: replacementTransaction,\n                    transactionReceipt: receipt!,\n                  })\n                  emit.resolve(receipt!)\n                })\n              } catch (err_) {\n                done(() => emit.reject(err_))\n              }\n            } else {\n              done(() => emit.reject(err))\n            }\n          }\n        },\n      })\n    },\n  )\n\n  return promise\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}