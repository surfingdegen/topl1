{"ast":null,"code":"import { hexToBigInt } from '../../utils/encoding/fromHex.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { observe } from '../../utils/observe.js';\nimport { poll } from '../../utils/poll.js';\nimport { stringify } from '../../utils/stringify.js';\nimport { getBlockNumber } from './getBlockNumber.js';\n/**\n * Watches and returns incoming block numbers.\n *\n * - Docs: https://viem.sh/docs/actions/public/watchBlockNumber\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks_watching-blocks\n * - JSON-RPC Methods:\n *   - When `poll: true`, calls [`eth_blockNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blocknumber) on a polling interval.\n *   - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `\"newHeads\"` event.\n *\n * @param client - Client to use\n * @param parameters - {@link WatchBlockNumberParameters}\n * @returns A function that can be invoked to stop watching for new block numbers. {@link WatchBlockNumberReturnType}\n *\n * @example\n * import { createPublicClient, watchBlockNumber, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const unwatch = watchBlockNumber(client, {\n *   onBlockNumber: (blockNumber) => console.log(blockNumber),\n * })\n */\nexport function watchBlockNumber(client, {\n  emitOnBegin = false,\n  emitMissed = false,\n  onBlockNumber,\n  onError,\n  poll: poll_,\n  pollingInterval = client.pollingInterval\n}) {\n  const enablePolling = (() => {\n    if (typeof poll_ !== 'undefined') return poll_;\n    if (client.transport.type === 'webSocket' || client.transport.type === 'ipc') return false;\n    if (client.transport.type === 'fallback' && (client.transport.transports[0].config.type === 'webSocket' || client.transport.transports[0].config.type === 'ipc')) return false;\n    return true;\n  })();\n  let prevBlockNumber;\n  const pollBlockNumber = () => {\n    const observerId = stringify(['watchBlockNumber', client.uid, emitOnBegin, emitMissed, pollingInterval]);\n    return observe(observerId, {\n      onBlockNumber,\n      onError\n    }, emit => poll(async () => {\n      try {\n        const blockNumber = await getAction(client, getBlockNumber, 'getBlockNumber')({\n          cacheTime: 0\n        });\n        if (prevBlockNumber !== undefined) {\n          // If the current block number is the same as the previous,\n          // we can skip.\n          if (blockNumber === prevBlockNumber) return;\n          // If we have missed out on some previous blocks, and the\n          // `emitMissed` flag is truthy, let's emit those blocks.\n          if (blockNumber - prevBlockNumber > 1 && emitMissed) {\n            for (let i = prevBlockNumber + 1n; i < blockNumber; i++) {\n              emit.onBlockNumber(i, prevBlockNumber);\n              prevBlockNumber = i;\n            }\n          }\n        }\n        // If the next block number is greater than the previous,\n        // it is not in the past, and we can emit the new block number.\n        if (prevBlockNumber === undefined || blockNumber > prevBlockNumber) {\n          emit.onBlockNumber(blockNumber, prevBlockNumber);\n          prevBlockNumber = blockNumber;\n        }\n      } catch (err) {\n        emit.onError?.(err);\n      }\n    }, {\n      emitOnBegin,\n      interval: pollingInterval\n    }));\n  };\n  const subscribeBlockNumber = () => {\n    const observerId = stringify(['watchBlockNumber', client.uid, emitOnBegin, emitMissed]);\n    return observe(observerId, {\n      onBlockNumber,\n      onError\n    }, emit => {\n      let active = true;\n      let unsubscribe = () => active = false;\n      (async () => {\n        try {\n          const transport = (() => {\n            if (client.transport.type === 'fallback') {\n              const transport = client.transport.transports.find(transport => transport.config.type === 'webSocket' || transport.config.type === 'ipc');\n              if (!transport) return client.transport;\n              return transport.value;\n            }\n            return client.transport;\n          })();\n          const {\n            unsubscribe: unsubscribe_\n          } = await transport.subscribe({\n            params: ['newHeads'],\n            onData(data) {\n              if (!active) return;\n              const blockNumber = hexToBigInt(data.result?.number);\n              emit.onBlockNumber(blockNumber, prevBlockNumber);\n              prevBlockNumber = blockNumber;\n            },\n            onError(error) {\n              emit.onError?.(error);\n            }\n          });\n          unsubscribe = unsubscribe_;\n          if (!active) unsubscribe();\n        } catch (err) {\n          onError?.(err);\n        }\n      })();\n      return () => unsubscribe();\n    });\n  };\n  return enablePolling ? pollBlockNumber() : subscribeBlockNumber();\n}","map":{"version":3,"names":["hexToBigInt","getAction","observe","poll","stringify","getBlockNumber","watchBlockNumber","client","emitOnBegin","emitMissed","onBlockNumber","onError","poll_","pollingInterval","enablePolling","transport","type","transports","config","prevBlockNumber","pollBlockNumber","observerId","uid","emit","blockNumber","cacheTime","undefined","i","err","interval","subscribeBlockNumber","active","unsubscribe","find","value","unsubscribe_","subscribe","params","onData","data","result","number","error"],"sources":["/Users/mac/Desktop/topl1/frontend/node_modules/viem/actions/public/watchBlockNumber.ts"],"sourcesContent":["import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { HasTransportType } from '../../types/transport.js'\nimport { hexToBigInt } from '../../utils/encoding/fromHex.js'\nimport { getAction } from '../../utils/getAction.js'\nimport { observe } from '../../utils/observe.js'\nimport { type PollErrorType, poll } from '../../utils/poll.js'\nimport { stringify } from '../../utils/stringify.js'\n\nimport {\n  type GetBlockNumberReturnType,\n  getBlockNumber,\n} from './getBlockNumber.js'\n\nexport type OnBlockNumberParameter = GetBlockNumberReturnType\nexport type OnBlockNumberFn = (\n  blockNumber: OnBlockNumberParameter,\n  prevBlockNumber: OnBlockNumberParameter | undefined,\n) => void\n\nexport type WatchBlockNumberParameters<\n  transport extends Transport = Transport,\n> = {\n  /** The callback to call when a new block number is received. */\n  onBlockNumber: OnBlockNumberFn\n  /** The callback to call when an error occurred when trying to get for a new block. */\n  onError?: ((error: Error) => void) | undefined\n} & (\n  | (HasTransportType<transport, 'webSocket' | 'ipc'> extends true\n      ? {\n          emitMissed?: undefined\n          emitOnBegin?: undefined\n          /** Whether or not the WebSocket Transport should poll the JSON-RPC, rather than using `eth_subscribe`. */\n          poll?: false | undefined\n          pollingInterval?: undefined\n        }\n      : never)\n  | {\n      /** Whether or not to emit the missed block numbers to the callback. */\n      emitMissed?: boolean | undefined\n      /** Whether or not to emit the latest block number to the callback when the subscription opens. */\n      emitOnBegin?: boolean | undefined\n      poll?: true | undefined\n      /** Polling frequency (in ms). Defaults to Client's pollingInterval config. */\n      pollingInterval?: number | undefined\n    }\n)\n\nexport type WatchBlockNumberReturnType = () => void\n\nexport type WatchBlockNumberErrorType = PollErrorType | ErrorType\n\n/**\n * Watches and returns incoming block numbers.\n *\n * - Docs: https://viem.sh/docs/actions/public/watchBlockNumber\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks_watching-blocks\n * - JSON-RPC Methods:\n *   - When `poll: true`, calls [`eth_blockNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blocknumber) on a polling interval.\n *   - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `\"newHeads\"` event.\n *\n * @param client - Client to use\n * @param parameters - {@link WatchBlockNumberParameters}\n * @returns A function that can be invoked to stop watching for new block numbers. {@link WatchBlockNumberReturnType}\n *\n * @example\n * import { createPublicClient, watchBlockNumber, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const unwatch = watchBlockNumber(client, {\n *   onBlockNumber: (blockNumber) => console.log(blockNumber),\n * })\n */\nexport function watchBlockNumber<\n  chain extends Chain | undefined,\n  transport extends Transport,\n>(\n  client: Client<transport, chain>,\n  {\n    emitOnBegin = false,\n    emitMissed = false,\n    onBlockNumber,\n    onError,\n    poll: poll_,\n    pollingInterval = client.pollingInterval,\n  }: WatchBlockNumberParameters<transport>,\n): WatchBlockNumberReturnType {\n  const enablePolling = (() => {\n    if (typeof poll_ !== 'undefined') return poll_\n    if (\n      client.transport.type === 'webSocket' ||\n      client.transport.type === 'ipc'\n    )\n      return false\n    if (\n      client.transport.type === 'fallback' &&\n      (client.transport.transports[0].config.type === 'webSocket' ||\n        client.transport.transports[0].config.type === 'ipc')\n    )\n      return false\n    return true\n  })()\n\n  let prevBlockNumber: GetBlockNumberReturnType | undefined\n\n  const pollBlockNumber = () => {\n    const observerId = stringify([\n      'watchBlockNumber',\n      client.uid,\n      emitOnBegin,\n      emitMissed,\n      pollingInterval,\n    ])\n\n    return observe(observerId, { onBlockNumber, onError }, (emit) =>\n      poll(\n        async () => {\n          try {\n            const blockNumber = await getAction(\n              client,\n              getBlockNumber,\n              'getBlockNumber',\n            )({ cacheTime: 0 })\n\n            if (prevBlockNumber !== undefined) {\n              // If the current block number is the same as the previous,\n              // we can skip.\n              if (blockNumber === prevBlockNumber) return\n\n              // If we have missed out on some previous blocks, and the\n              // `emitMissed` flag is truthy, let's emit those blocks.\n              if (blockNumber - prevBlockNumber > 1 && emitMissed) {\n                for (let i = prevBlockNumber + 1n; i < blockNumber; i++) {\n                  emit.onBlockNumber(i, prevBlockNumber)\n                  prevBlockNumber = i\n                }\n              }\n            }\n\n            // If the next block number is greater than the previous,\n            // it is not in the past, and we can emit the new block number.\n            if (\n              prevBlockNumber === undefined ||\n              blockNumber > prevBlockNumber\n            ) {\n              emit.onBlockNumber(blockNumber, prevBlockNumber)\n              prevBlockNumber = blockNumber\n            }\n          } catch (err) {\n            emit.onError?.(err as Error)\n          }\n        },\n        {\n          emitOnBegin,\n          interval: pollingInterval,\n        },\n      ),\n    )\n  }\n\n  const subscribeBlockNumber = () => {\n    const observerId = stringify([\n      'watchBlockNumber',\n      client.uid,\n      emitOnBegin,\n      emitMissed,\n    ])\n\n    return observe(observerId, { onBlockNumber, onError }, (emit) => {\n      let active = true\n      let unsubscribe = () => (active = false)\n      ;(async () => {\n        try {\n          const transport = (() => {\n            if (client.transport.type === 'fallback') {\n              const transport = client.transport.transports.find(\n                (transport: ReturnType<Transport>) =>\n                  transport.config.type === 'webSocket' ||\n                  transport.config.type === 'ipc',\n              )\n              if (!transport) return client.transport\n              return transport.value\n            }\n            return client.transport\n          })()\n\n          const { unsubscribe: unsubscribe_ } = await transport.subscribe({\n            params: ['newHeads'],\n            onData(data: any) {\n              if (!active) return\n              const blockNumber = hexToBigInt(data.result?.number)\n              emit.onBlockNumber(blockNumber, prevBlockNumber)\n              prevBlockNumber = blockNumber\n            },\n            onError(error: Error) {\n              emit.onError?.(error)\n            },\n          })\n          unsubscribe = unsubscribe_\n          if (!active) unsubscribe()\n        } catch (err) {\n          onError?.(err as Error)\n        }\n      })()\n      return () => unsubscribe()\n    })\n  }\n\n  return enablePolling ? pollBlockNumber() : subscribeBlockNumber()\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}