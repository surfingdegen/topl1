{"ast":null,"code":"import * as abitype from 'abitype';\nimport * as AbiItem from './AbiItem.js';\nimport * as AbiParameters from './AbiParameters.js';\nimport * as Hex from './Hex.js';\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function decode() {\n  var _abiConstructor$input;\n  for (var _len = arguments.length, parameters = new Array(_len), _key = 0; _key < _len; _key++) {\n    parameters[_key] = arguments[_key];\n  }\n  const [abiConstructor, options] = (() => {\n    if (Array.isArray(parameters[0])) {\n      const [abi, options] = parameters;\n      return [fromAbi(abi), options];\n    }\n    return parameters;\n  })();\n  const {\n    bytecode\n  } = options;\n  if (((_abiConstructor$input = abiConstructor.inputs) === null || _abiConstructor$input === void 0 ? void 0 : _abiConstructor$input.length) === 0) return undefined;\n  const data = options.data.replace(bytecode, '0x');\n  return AbiParameters.decode(abiConstructor.inputs, data);\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function encode() {\n  var _abiConstructor$input2;\n  for (var _len2 = arguments.length, parameters = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    parameters[_key2] = arguments[_key2];\n  }\n  const [abiConstructor, options] = (() => {\n    if (Array.isArray(parameters[0])) {\n      const [abi, options] = parameters;\n      return [fromAbi(abi), options];\n    }\n    return parameters;\n  })();\n  const {\n    bytecode,\n    args\n  } = options;\n  return Hex.concat(bytecode, (_abiConstructor$input2 = abiConstructor.inputs) !== null && _abiConstructor$input2 !== void 0 && _abiConstructor$input2.length && args !== null && args !== void 0 && args.length ? AbiParameters.encode(abiConstructor.inputs, args) : '0x');\n}\n/** @internal */\nexport function format(abiConstructor) {\n  return abitype.formatAbiItem(abiConstructor);\n}\n/** @internal */\nexport function from(abiConstructor) {\n  return AbiItem.from(abiConstructor);\n}\n/** @internal */\nexport function fromAbi(abi) {\n  const item = abi.find(item => item.type === 'constructor');\n  if (!item) throw new AbiItem.NotFoundError({\n    name: 'constructor'\n  });\n  return item;\n}","map":{"version":3,"names":["abitype","AbiItem","AbiParameters","Hex","decode","_abiConstructor$input","_len","arguments","length","parameters","Array","_key","abiConstructor","options","isArray","abi","fromAbi","bytecode","inputs","undefined","data","replace","encode","_abiConstructor$input2","_len2","_key2","args","concat","format","formatAbiItem","from","item","find","type","NotFoundError","name"],"sources":["/Users/mac/Desktop/topl1/frontend/node_modules/ox/core/AbiConstructor.ts"],"sourcesContent":["import * as abitype from 'abitype'\nimport type * as Abi from './Abi.js'\nimport * as AbiItem from './AbiItem.js'\nimport * as AbiParameters from './AbiParameters.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport type * as internal from './internal/abiConstructor.js'\nimport type { IsNarrowable } from './internal/types.js'\n\n/** Root type for an {@link ox#AbiItem.AbiItem} with a `constructor` type. */\nexport type AbiConstructor = abitype.AbiConstructor\n\n/**\n * ABI-decodes the provided constructor input (`inputs`).\n *\n * @example\n * ```ts twoslash\n * import { AbiConstructor } from 'ox'\n *\n * const constructor = AbiConstructor.from('constructor(address, uint256)')\n *\n * const bytecode = '0x...'\n *\n * const data = AbiConstructor.encode(constructor, {\n *   bytecode,\n *   args: ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 123n],\n * })\n *\n * const decoded = AbiConstructor.decode(constructor, { // [!code focus]\n *   bytecode, // [!code focus]\n *   data, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @example\n * ### ABI-shorthand\n *\n * You can also specify an entire ABI object as a parameter to `AbiConstructor.decode`.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiConstructor } from 'ox'\n *\n * const abi = Abi.from([...])\n *\n * const data = AbiConstructor.encode(abi, {\n *   bytecode: '0x...',\n *   args: ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 123n],\n * })\n *\n * const decoded = AbiConstructor.decode(abi, { // [!code focus]\n *   bytecode: '0x...', // [!code focus]\n *   data, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param abiConstructor - The ABI Constructor to decode.\n * @param options - Decoding options.\n * @returns The decoded constructor inputs.\n */\nexport function decode<\n  const abi extends Abi.Abi | readonly unknown[],\n  abiConstructor extends\n    AbiConstructor = fromAbi.ReturnType<abi> extends AbiConstructor\n    ? fromAbi.ReturnType<abi>\n    : never,\n>(\n  abi: abi | Abi.Abi | readonly unknown[],\n  options: decode.Options,\n): decode.ReturnType<abiConstructor>\nexport function decode<const abiConstructor extends AbiConstructor>(\n  abiConstructor: abiConstructor | AbiConstructor,\n  options: decode.Options,\n): decode.ReturnType<abiConstructor>\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function decode(\n  ...parameters:\n    | [abi: Abi.Abi | readonly unknown[], options: decode.Options]\n    | [abiConstructor: AbiConstructor, options: decode.Options]\n): decode.ReturnType {\n  const [abiConstructor, options] = (() => {\n    if (Array.isArray(parameters[0])) {\n      const [abi, options] = parameters as [\n        Abi.Abi | readonly unknown[],\n        decode.Options,\n      ]\n      return [fromAbi(abi), options] as [AbiConstructor, decode.Options]\n    }\n    return parameters as [AbiConstructor, decode.Options]\n  })()\n\n  const { bytecode } = options\n  if (abiConstructor.inputs?.length === 0) return undefined\n  const data = options.data.replace(bytecode, '0x') as Hex.Hex\n  return AbiParameters.decode(abiConstructor.inputs, data)\n}\n\nexport declare namespace decode {\n  interface Options {\n    /** The bytecode of the contract. */\n    bytecode: Hex.Hex\n    /** The encoded constructor. */\n    data: Hex.Hex\n  }\n\n  type ReturnType<abiConstructor extends AbiConstructor = AbiConstructor> =\n    | (abiConstructor['inputs']['length'] extends 0\n        ? undefined\n        : abitype.AbiParametersToPrimitiveTypes<abiConstructor['inputs']>)\n    | (IsNarrowable<abiConstructor, AbiConstructor> extends true\n        ? never\n        : undefined)\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * ABI-encodes the provided constructor input (`inputs`).\n *\n * @example\n * ```ts twoslash\n * import { AbiConstructor } from 'ox'\n *\n * const constructor = AbiConstructor.from('constructor(address, uint256)')\n *\n * const data = AbiConstructor.encode(constructor, {\n *   bytecode: '0x...',\n *   args: ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 123n],\n * })\n * ```\n *\n * @example\n * ### ABI-shorthand\n *\n * You can also specify an entire ABI object as a parameter to `AbiConstructor.encode`.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiConstructor } from 'ox'\n *\n * const abi = Abi.from([...])\n *\n * const data = AbiConstructor.encode(abi, { // [!code focus]\n *   bytecode: '0x...', // [!code focus]\n *   args: ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 123n], // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @example\n * ### End-to-end\n *\n * Below is an end-to-end example of using `AbiConstructor.encode` to encode the constructor of a contract and deploy it.\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { AbiConstructor, Hex } from 'ox'\n *\n * // 1. Instantiate the ABI Constructor.\n * const constructor = AbiConstructor.from(\n *   'constructor(address owner, uint256 amount)',\n * )\n *\n * // 2. Encode the ABI Constructor.\n * const data = AbiConstructor.encode(constructor, {\n *   bytecode: '0x...',\n *   args: ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 123n],\n * })\n *\n * // 3. Deploy the contract.\n * const hash = await window.ethereum!.request({\n *   method: 'eth_sendTransaction',\n *   params: [{ data }],\n * })\n * ```\n *\n * :::note\n *\n * For simplicity, the above example uses `window.ethereum.request`, but you can use any\n * type of JSON-RPC interface.\n *\n * :::\n *\n * @param abiConstructor - The ABI Constructor to encode.\n * @param options - Encoding options.\n * @returns The encoded constructor.\n */\nexport function encode<\n  const abi extends Abi.Abi | readonly unknown[],\n  abiConstructor extends\n    AbiConstructor = fromAbi.ReturnType<abi> extends AbiConstructor\n    ? fromAbi.ReturnType<abi>\n    : never,\n>(\n  abi: abi | Abi.Abi | readonly unknown[],\n  options: encode.Options<abiConstructor>,\n): encode.ReturnType\nexport function encode<const abiConstructor extends AbiConstructor>(\n  abiConstructor: abiConstructor | AbiConstructor,\n  options: encode.Options<abiConstructor>,\n): encode.ReturnType\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function encode(\n  ...parameters:\n    | [abi: Abi.Abi | readonly unknown[], options: encode.Options]\n    | [abiConstructor: AbiConstructor, options: encode.Options]\n): encode.ReturnType {\n  const [abiConstructor, options] = (() => {\n    if (Array.isArray(parameters[0])) {\n      const [abi, options] = parameters as [\n        Abi.Abi | readonly unknown[],\n        encode.Options,\n      ]\n      return [fromAbi(abi), options] as [AbiConstructor, encode.Options]\n    }\n\n    return parameters as [AbiConstructor, encode.Options]\n  })()\n\n  const { bytecode, args } = options\n  return Hex.concat(\n    bytecode,\n    abiConstructor.inputs?.length && args?.length\n      ? AbiParameters.encode(abiConstructor.inputs, args as readonly unknown[])\n      : '0x',\n  )\n}\n\nexport declare namespace encode {\n  type Options<\n    abiConstructor extends AbiConstructor = AbiConstructor,\n    ///\n    args extends abitype.AbiParametersToPrimitiveTypes<\n      abiConstructor['inputs']\n    > = abitype.AbiParametersToPrimitiveTypes<abiConstructor['inputs']>,\n  > = {\n    /** The bytecode of the contract. */\n    bytecode: Hex.Hex\n    /** The constructor arguments to encode. */\n    args?: args | undefined\n  } & (readonly [] extends args\n    ? {}\n    : {\n        /** The constructor arguments to encode. */\n        args: args\n      })\n\n  type ReturnType = Hex.Hex\n\n  type ErrorType =\n    | Hex.concat.ErrorType\n    | AbiParameters.encode.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function format<const abiConstructor extends AbiConstructor>(\n  abiConstructor: abiConstructor,\n): format.ReturnType<abiConstructor>\n/**\n * Formats an {@link ox#AbiConstructor.AbiConstructor} into a **Human Readable ABI Function**.\n *\n * @example\n * ```ts twoslash\n * import { AbiConstructor } from 'ox'\n *\n * const formatted = AbiConstructor.format({\n *   inputs: [\n *     { name: 'owner', type: 'address' },\n *   ],\n *   payable: false,\n *   stateMutability: 'nonpayable',\n *   type: 'constructor',\n * })\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param abiConstructor - The ABI Constructor to format.\n * @returns The formatted ABI Constructor.\n */\nexport function format(abiConstructor: AbiConstructor): string\n/** @internal */\nexport function format(abiConstructor: AbiConstructor): format.ReturnType {\n  return abitype.formatAbiItem(abiConstructor)\n}\n\nexport declare namespace format {\n  type ReturnType<abiConstructor extends AbiConstructor = AbiConstructor> =\n    abitype.FormatAbiItem<abiConstructor>\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function from<\n  const abiConstructor extends AbiConstructor | string | readonly string[],\n>(\n  abiConstructor: (abiConstructor | string | readonly string[]) &\n    (\n      | (abiConstructor extends string\n          ? internal.Signature<abiConstructor>\n          : never)\n      | (abiConstructor extends readonly string[]\n          ? internal.Signatures<abiConstructor>\n          : never)\n      | AbiConstructor\n    ),\n): from.ReturnType<abiConstructor>\n/**\n * Parses an arbitrary **JSON ABI Constructor** or **Human Readable ABI Constructor** into a typed {@link ox#AbiConstructor.AbiConstructor}.\n *\n * @example\n * ### JSON ABIs\n *\n * ```ts twoslash\n * import { AbiConstructor } from 'ox'\n *\n * const constructor = AbiConstructor.from({\n *   inputs: [\n *     { name: 'owner', type: 'address' },\n *   ],\n *   payable: false,\n *   stateMutability: 'nonpayable',\n *   type: 'constructor',\n * })\n *\n * constructor\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable ABIs\n *\n * A Human Readable ABI can be parsed into a typed ABI object:\n *\n * ```ts twoslash\n * import { AbiConstructor } from 'ox'\n *\n * const constructor = AbiConstructor.from(\n *   'constructor(address owner)' // [!code hl]\n * )\n *\n * constructor\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiConstructor } from 'ox'\n *\n * const constructor = AbiConstructor.from([\n *   'struct Foo { address owner; uint256 amount; }', // [!code hl]\n *   'constructor(Foo foo)',\n * ])\n *\n * constructor\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param abiConstructor - The ABI Constructor to parse.\n * @returns Typed ABI Constructor.\n */\nexport function from(\n  abiConstructor: AbiConstructor | string | readonly string[],\n): AbiConstructor\n/** @internal */\nexport function from(\n  abiConstructor: AbiConstructor | string | readonly string[],\n): from.ReturnType {\n  return AbiItem.from(abiConstructor as AbiConstructor)\n}\n\nexport declare namespace from {\n  type ReturnType<\n    abiConstructor extends\n      | AbiConstructor\n      | string\n      | readonly string[] = AbiConstructor,\n  > = AbiItem.from.ReturnType<abiConstructor>\n\n  type ErrorType = AbiItem.from.ErrorType | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function fromAbi<const abi extends Abi.Abi | readonly unknown[]>(\n  abi: abi | Abi.Abi | readonly unknown[],\n): fromAbi.ReturnType<abi>\n/**\n * Extracts an {@link ox#AbiConstructor.AbiConstructor} from an {@link ox#Abi.Abi} given a name and optional arguments.\n *\n * @example\n * ### Extracting by Name\n *\n * ABI Events can be extracted by their name using the `name` option:\n *\n * ```ts twoslash\n * import { Abi, AbiConstructor } from 'ox'\n *\n * const abi = Abi.from([\n *   'constructor(address owner)',\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiConstructor.fromAbi(abi) // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @returns The ABI constructor.\n */\nexport function fromAbi(abi: Abi.Abi | readonly unknown[]): AbiConstructor\n/** @internal */\nexport function fromAbi(abi: Abi.Abi | readonly unknown[]): fromAbi.ReturnType {\n  const item = (abi as Abi.Abi).find((item) => item.type === 'constructor')\n  if (!item) throw new AbiItem.NotFoundError({ name: 'constructor' })\n  return item\n}\n\nexport declare namespace fromAbi {\n  type ReturnType<abi extends Abi.Abi | readonly unknown[] = Abi.Abi> = Extract<\n    abi[number],\n    { type: 'constructor' }\n  >\n\n  type ErrorType = AbiItem.NotFoundError | Errors.GlobalErrorType\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}