{"ast":null,"code":"import _wrapRegExp from \"/Users/mac/Desktop/topl1/frontend/node_modules/@babel/runtime/helpers/esm/wrapRegExp.js\";\nimport { readContract } from '../../../actions/public/readContract.js';\nimport { EnsAvatarInvalidMetadataError, EnsAvatarInvalidNftUriError, EnsAvatarUnsupportedNamespaceError, EnsAvatarUriResolutionError } from '../../../errors/ens.js';\nconst networkRegex = /*#__PURE__*/_wrapRegExp(/(https?:\\/\\/[^/]*|ipfs:\\/|ipns:\\/|ar:\\/)?(\\/)?(ipfs\\/|ipns\\/)?([\\w\\-.]+)(\\/.*)?/, {\n  protocol: 1,\n  root: 2,\n  subpath: 3,\n  target: 4,\n  subtarget: 5\n});\nconst ipfsHashRegex = /*#__PURE__*/_wrapRegExp(/^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\\/([\\w\\-.]+))?(\\/.*)?$/, {\n  target: 3,\n  subtarget: 4\n});\nconst base64Regex = /^data:([a-zA-Z\\-/+]*);base64,([^\"].*)/;\nconst dataURIRegex = /^data:([a-zA-Z\\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;\n/** @internal */\nexport async function isImageUri(uri) {\n  try {\n    const res = await fetch(uri, {\n      method: 'HEAD'\n    });\n    // retrieve content type header to check if content is image\n    if (res.status === 200) {\n      const contentType = res.headers.get('content-type');\n      return contentType === null || contentType === void 0 ? void 0 : contentType.startsWith('image/');\n    }\n    return false;\n  } catch (error) {\n    // if error is not cors related then fail\n    if (typeof error === 'object' && typeof error.response !== 'undefined') {\n      return false;\n    }\n    // fail in NodeJS, since the error is not cors but any other network issue\n    if (!Object.hasOwn(globalThis, 'Image')) return false;\n    // in case of cors, use image api to validate if given url is an actual image\n    return new Promise(resolve => {\n      const img = new Image();\n      img.onload = () => {\n        resolve(true);\n      };\n      img.onerror = () => {\n        resolve(false);\n      };\n      img.src = uri;\n    });\n  }\n}\n/** @internal */\nexport function getGateway(custom, defaultGateway) {\n  if (!custom) return defaultGateway;\n  if (custom.endsWith('/')) return custom.slice(0, -1);\n  return custom;\n}\nexport function resolveAvatarUri(_ref) {\n  let {\n    uri,\n    gatewayUrls\n  } = _ref;\n  const isEncoded = base64Regex.test(uri);\n  if (isEncoded) return {\n    uri,\n    isOnChain: true,\n    isEncoded\n  };\n  const ipfsGateway = getGateway(gatewayUrls === null || gatewayUrls === void 0 ? void 0 : gatewayUrls.ipfs, 'https://ipfs.io');\n  const arweaveGateway = getGateway(gatewayUrls === null || gatewayUrls === void 0 ? void 0 : gatewayUrls.arweave, 'https://arweave.net');\n  const networkRegexMatch = uri.match(networkRegex);\n  const {\n    protocol,\n    subpath,\n    target,\n    subtarget = ''\n  } = (networkRegexMatch === null || networkRegexMatch === void 0 ? void 0 : networkRegexMatch.groups) || {};\n  const isIPNS = protocol === 'ipns:/' || subpath === 'ipns/';\n  const isIPFS = protocol === 'ipfs:/' || subpath === 'ipfs/' || ipfsHashRegex.test(uri);\n  if (uri.startsWith('http') && !isIPNS && !isIPFS) {\n    let replacedUri = uri;\n    if (gatewayUrls !== null && gatewayUrls !== void 0 && gatewayUrls.arweave) replacedUri = uri.replace(/https:\\/\\/arweave.net/g, gatewayUrls === null || gatewayUrls === void 0 ? void 0 : gatewayUrls.arweave);\n    return {\n      uri: replacedUri,\n      isOnChain: false,\n      isEncoded: false\n    };\n  }\n  if ((isIPNS || isIPFS) && target) {\n    return {\n      uri: \"\".concat(ipfsGateway, \"/\").concat(isIPNS ? 'ipns' : 'ipfs', \"/\").concat(target).concat(subtarget),\n      isOnChain: false,\n      isEncoded: false\n    };\n  }\n  if (protocol === 'ar:/' && target) {\n    return {\n      uri: \"\".concat(arweaveGateway, \"/\").concat(target).concat(subtarget || ''),\n      isOnChain: false,\n      isEncoded: false\n    };\n  }\n  let parsedUri = uri.replace(dataURIRegex, '');\n  if (parsedUri.startsWith('<svg')) {\n    // if svg, base64 encode\n    parsedUri = \"data:image/svg+xml;base64,\".concat(btoa(parsedUri));\n  }\n  if (parsedUri.startsWith('data:') || parsedUri.startsWith('{')) {\n    return {\n      uri: parsedUri,\n      isOnChain: true,\n      isEncoded: false\n    };\n  }\n  throw new EnsAvatarUriResolutionError({\n    uri\n  });\n}\nexport function getJsonImage(data) {\n  // validation check for json data, must include one of theses properties\n  if (typeof data !== 'object' || !('image' in data) && !('image_url' in data) && !('image_data' in data)) {\n    throw new EnsAvatarInvalidMetadataError({\n      data\n    });\n  }\n  return data.image || data.image_url || data.image_data;\n}\nexport async function getMetadataAvatarUri(_ref2) {\n  let {\n    gatewayUrls,\n    uri\n  } = _ref2;\n  try {\n    const res = await fetch(uri).then(res => res.json());\n    const image = await parseAvatarUri({\n      gatewayUrls,\n      uri: getJsonImage(res)\n    });\n    return image;\n  } catch (_unused) {\n    throw new EnsAvatarUriResolutionError({\n      uri\n    });\n  }\n}\nexport async function parseAvatarUri(_ref3) {\n  let {\n    gatewayUrls,\n    uri\n  } = _ref3;\n  const {\n    uri: resolvedURI,\n    isOnChain\n  } = resolveAvatarUri({\n    uri,\n    gatewayUrls\n  });\n  if (isOnChain) return resolvedURI;\n  // check if resolvedURI is an image, if it is return the url\n  const isImage = await isImageUri(resolvedURI);\n  if (isImage) return resolvedURI;\n  throw new EnsAvatarUriResolutionError({\n    uri\n  });\n}\nexport function parseNftUri(uri_) {\n  let uri = uri_;\n  // parse valid nft spec (CAIP-22/CAIP-29)\n  // @see: https://github.com/ChainAgnostic/CAIPs/tree/master/CAIPs\n  if (uri.startsWith('did:nft:')) {\n    // convert DID to CAIP\n    uri = uri.replace('did:nft:', '').replace(/_/g, '/');\n  }\n  const [reference, asset_namespace, tokenID] = uri.split('/');\n  const [eip_namespace, chainID] = reference.split(':');\n  const [erc_namespace, contractAddress] = asset_namespace.split(':');\n  if (!eip_namespace || eip_namespace.toLowerCase() !== 'eip155') throw new EnsAvatarInvalidNftUriError({\n    reason: 'Only EIP-155 supported'\n  });\n  if (!chainID) throw new EnsAvatarInvalidNftUriError({\n    reason: 'Chain ID not found'\n  });\n  if (!contractAddress) throw new EnsAvatarInvalidNftUriError({\n    reason: 'Contract address not found'\n  });\n  if (!tokenID) throw new EnsAvatarInvalidNftUriError({\n    reason: 'Token ID not found'\n  });\n  if (!erc_namespace) throw new EnsAvatarInvalidNftUriError({\n    reason: 'ERC namespace not found'\n  });\n  return {\n    chainID: Number.parseInt(chainID, 10),\n    namespace: erc_namespace.toLowerCase(),\n    contractAddress: contractAddress,\n    tokenID\n  };\n}\nexport async function getNftTokenUri(client, _ref4) {\n  let {\n    nft\n  } = _ref4;\n  if (nft.namespace === 'erc721') {\n    return readContract(client, {\n      address: nft.contractAddress,\n      abi: [{\n        name: 'tokenURI',\n        type: 'function',\n        stateMutability: 'view',\n        inputs: [{\n          name: 'tokenId',\n          type: 'uint256'\n        }],\n        outputs: [{\n          name: '',\n          type: 'string'\n        }]\n      }],\n      functionName: 'tokenURI',\n      args: [BigInt(nft.tokenID)]\n    });\n  }\n  if (nft.namespace === 'erc1155') {\n    return readContract(client, {\n      address: nft.contractAddress,\n      abi: [{\n        name: 'uri',\n        type: 'function',\n        stateMutability: 'view',\n        inputs: [{\n          name: '_id',\n          type: 'uint256'\n        }],\n        outputs: [{\n          name: '',\n          type: 'string'\n        }]\n      }],\n      functionName: 'uri',\n      args: [BigInt(nft.tokenID)]\n    });\n  }\n  throw new EnsAvatarUnsupportedNamespaceError({\n    namespace: nft.namespace\n  });\n}","map":{"version":3,"names":["readContract","EnsAvatarInvalidMetadataError","EnsAvatarInvalidNftUriError","EnsAvatarUnsupportedNamespaceError","EnsAvatarUriResolutionError","networkRegex","_wrapRegExp","protocol","root","subpath","target","subtarget","ipfsHashRegex","base64Regex","dataURIRegex","isImageUri","uri","res","fetch","method","status","contentType","headers","get","startsWith","error","response","Object","hasOwn","globalThis","Promise","resolve","img","Image","onload","onerror","src","getGateway","custom","defaultGateway","endsWith","slice","resolveAvatarUri","_ref","gatewayUrls","isEncoded","test","isOnChain","ipfsGateway","ipfs","arweaveGateway","arweave","networkRegexMatch","match","groups","isIPNS","isIPFS","replacedUri","replace","concat","parsedUri","btoa","getJsonImage","data","image","image_url","image_data","getMetadataAvatarUri","_ref2","then","json","parseAvatarUri","_unused","_ref3","resolvedURI","isImage","parseNftUri","uri_","reference","asset_namespace","tokenID","split","eip_namespace","chainID","erc_namespace","contractAddress","toLowerCase","reason","Number","parseInt","namespace","getNftTokenUri","client","_ref4","nft","address","abi","name","type","stateMutability","inputs","outputs","functionName","args","BigInt"],"sources":["/Users/mac/Desktop/topl1/frontend/node_modules/viem/utils/ens/avatar/utils.ts"],"sourcesContent":["import type { Address } from 'abitype'\n\nimport {\n  type ReadContractErrorType,\n  readContract,\n} from '../../../actions/public/readContract.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport {\n  EnsAvatarInvalidMetadataError,\n  type EnsAvatarInvalidMetadataErrorType,\n  EnsAvatarInvalidNftUriError,\n  type EnsAvatarInvalidNftUriErrorType,\n  EnsAvatarUnsupportedNamespaceError,\n  type EnsAvatarUnsupportedNamespaceErrorType,\n  EnsAvatarUriResolutionError,\n  type EnsAvatarUriResolutionErrorType,\n} from '../../../errors/ens.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Chain } from '../../../types/chain.js'\nimport type { AssetGatewayUrls } from '../../../types/ens.js'\n\ntype UriItem = {\n  uri: string\n  isOnChain: boolean\n  isEncoded: boolean\n}\n\nconst networkRegex =\n  /(?<protocol>https?:\\/\\/[^/]*|ipfs:\\/|ipns:\\/|ar:\\/)?(?<root>\\/)?(?<subpath>ipfs\\/|ipns\\/)?(?<target>[\\w\\-.]+)(?<subtarget>\\/.*)?/\nconst ipfsHashRegex =\n  /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\\/(?<target>[\\w\\-.]+))?(?<subtarget>\\/.*)?$/\nconst base64Regex = /^data:([a-zA-Z\\-/+]*);base64,([^\"].*)/\nconst dataURIRegex = /^data:([a-zA-Z\\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/\n\ntype IsImageUriErrorType = ErrorType\n\n/** @internal */\nexport async function isImageUri(uri: string) {\n  try {\n    const res = await fetch(uri, { method: 'HEAD' })\n    // retrieve content type header to check if content is image\n    if (res.status === 200) {\n      const contentType = res.headers.get('content-type')\n      return contentType?.startsWith('image/')\n    }\n    return false\n  } catch (error: any) {\n    // if error is not cors related then fail\n    if (typeof error === 'object' && typeof error.response !== 'undefined') {\n      return false\n    }\n    // fail in NodeJS, since the error is not cors but any other network issue\n    if (!Object.hasOwn(globalThis, 'Image')) return false\n    // in case of cors, use image api to validate if given url is an actual image\n    return new Promise((resolve) => {\n      const img = new Image()\n      img.onload = () => {\n        resolve(true)\n      }\n      img.onerror = () => {\n        resolve(false)\n      }\n      img.src = uri\n    })\n  }\n}\n\ntype GetGatewayErrorType = ErrorType\n\n/** @internal */\nexport function getGateway(custom: string | undefined, defaultGateway: string) {\n  if (!custom) return defaultGateway\n  if (custom.endsWith('/')) return custom.slice(0, -1)\n  return custom\n}\n\nexport type ResolveAvatarUriErrorType =\n  | GetGatewayErrorType\n  | EnsAvatarUriResolutionErrorType\n  | ErrorType\n\nexport function resolveAvatarUri({\n  uri,\n  gatewayUrls,\n}: {\n  uri: string\n  gatewayUrls?: AssetGatewayUrls | undefined\n}): UriItem {\n  const isEncoded = base64Regex.test(uri)\n  if (isEncoded) return { uri, isOnChain: true, isEncoded }\n\n  const ipfsGateway = getGateway(gatewayUrls?.ipfs, 'https://ipfs.io')\n  const arweaveGateway = getGateway(gatewayUrls?.arweave, 'https://arweave.net')\n\n  const networkRegexMatch = uri.match(networkRegex)\n  const {\n    protocol,\n    subpath,\n    target,\n    subtarget = '',\n  } = networkRegexMatch?.groups || {}\n\n  const isIPNS = protocol === 'ipns:/' || subpath === 'ipns/'\n  const isIPFS =\n    protocol === 'ipfs:/' || subpath === 'ipfs/' || ipfsHashRegex.test(uri)\n\n  if (uri.startsWith('http') && !isIPNS && !isIPFS) {\n    let replacedUri = uri\n    if (gatewayUrls?.arweave)\n      replacedUri = uri.replace(/https:\\/\\/arweave.net/g, gatewayUrls?.arweave)\n    return { uri: replacedUri, isOnChain: false, isEncoded: false }\n  }\n\n  if ((isIPNS || isIPFS) && target) {\n    return {\n      uri: `${ipfsGateway}/${isIPNS ? 'ipns' : 'ipfs'}/${target}${subtarget}`,\n      isOnChain: false,\n      isEncoded: false,\n    }\n  }\n\n  if (protocol === 'ar:/' && target) {\n    return {\n      uri: `${arweaveGateway}/${target}${subtarget || ''}`,\n      isOnChain: false,\n      isEncoded: false,\n    }\n  }\n\n  let parsedUri = uri.replace(dataURIRegex, '')\n  if (parsedUri.startsWith('<svg')) {\n    // if svg, base64 encode\n    parsedUri = `data:image/svg+xml;base64,${btoa(parsedUri)}`\n  }\n\n  if (parsedUri.startsWith('data:') || parsedUri.startsWith('{')) {\n    return {\n      uri: parsedUri,\n      isOnChain: true,\n      isEncoded: false,\n    }\n  }\n\n  throw new EnsAvatarUriResolutionError({ uri })\n}\n\nexport type GetJsonImageErrorType =\n  | EnsAvatarInvalidMetadataErrorType\n  | ErrorType\n\nexport function getJsonImage(data: any) {\n  // validation check for json data, must include one of theses properties\n  if (\n    typeof data !== 'object' ||\n    (!('image' in data) && !('image_url' in data) && !('image_data' in data))\n  ) {\n    throw new EnsAvatarInvalidMetadataError({ data })\n  }\n\n  return data.image || data.image_url || data.image_data\n}\n\nexport type GetMetadataAvatarUriErrorType =\n  | EnsAvatarUriResolutionErrorType\n  | ParseAvatarUriErrorType\n  | GetJsonImageErrorType\n  | ErrorType\n\nexport async function getMetadataAvatarUri({\n  gatewayUrls,\n  uri,\n}: {\n  gatewayUrls?: AssetGatewayUrls | undefined\n  uri: string\n}): Promise<string> {\n  try {\n    const res = await fetch(uri).then((res) => res.json())\n    const image = await parseAvatarUri({\n      gatewayUrls,\n      uri: getJsonImage(res),\n    })\n    return image\n  } catch {\n    throw new EnsAvatarUriResolutionError({ uri })\n  }\n}\n\nexport type ParseAvatarUriErrorType =\n  | ResolveAvatarUriErrorType\n  | IsImageUriErrorType\n  | EnsAvatarUriResolutionErrorType\n  | ErrorType\n\nexport async function parseAvatarUri({\n  gatewayUrls,\n  uri,\n}: {\n  gatewayUrls?: AssetGatewayUrls | undefined\n  uri: string\n}): Promise<string> {\n  const { uri: resolvedURI, isOnChain } = resolveAvatarUri({ uri, gatewayUrls })\n  if (isOnChain) return resolvedURI\n\n  // check if resolvedURI is an image, if it is return the url\n  const isImage = await isImageUri(resolvedURI)\n  if (isImage) return resolvedURI\n\n  throw new EnsAvatarUriResolutionError({ uri })\n}\n\ntype ParsedNft = {\n  chainID: number\n  namespace: string\n  contractAddress: Address\n  tokenID: string\n}\n\nexport type ParseNftUriErrorType = EnsAvatarInvalidNftUriErrorType | ErrorType\n\nexport function parseNftUri(uri_: string): ParsedNft {\n  let uri = uri_\n  // parse valid nft spec (CAIP-22/CAIP-29)\n  // @see: https://github.com/ChainAgnostic/CAIPs/tree/master/CAIPs\n  if (uri.startsWith('did:nft:')) {\n    // convert DID to CAIP\n    uri = uri.replace('did:nft:', '').replace(/_/g, '/')\n  }\n\n  const [reference, asset_namespace, tokenID] = uri.split('/')\n  const [eip_namespace, chainID] = reference.split(':')\n  const [erc_namespace, contractAddress] = asset_namespace.split(':')\n\n  if (!eip_namespace || eip_namespace.toLowerCase() !== 'eip155')\n    throw new EnsAvatarInvalidNftUriError({ reason: 'Only EIP-155 supported' })\n  if (!chainID)\n    throw new EnsAvatarInvalidNftUriError({ reason: 'Chain ID not found' })\n  if (!contractAddress)\n    throw new EnsAvatarInvalidNftUriError({\n      reason: 'Contract address not found',\n    })\n  if (!tokenID)\n    throw new EnsAvatarInvalidNftUriError({ reason: 'Token ID not found' })\n  if (!erc_namespace)\n    throw new EnsAvatarInvalidNftUriError({ reason: 'ERC namespace not found' })\n\n  return {\n    chainID: Number.parseInt(chainID, 10),\n    namespace: erc_namespace.toLowerCase(),\n    contractAddress: contractAddress as Address,\n    tokenID,\n  }\n}\n\nexport type GetNftTokenUriErrorType =\n  | ReadContractErrorType\n  | EnsAvatarUnsupportedNamespaceErrorType\n  | ErrorType\n\nexport async function getNftTokenUri<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  { nft }: { nft: ParsedNft },\n) {\n  if (nft.namespace === 'erc721') {\n    return readContract(client, {\n      address: nft.contractAddress,\n      abi: [\n        {\n          name: 'tokenURI',\n          type: 'function',\n          stateMutability: 'view',\n          inputs: [{ name: 'tokenId', type: 'uint256' }],\n          outputs: [{ name: '', type: 'string' }],\n        },\n      ],\n      functionName: 'tokenURI',\n      args: [BigInt(nft.tokenID)],\n    })\n  }\n  if (nft.namespace === 'erc1155') {\n    return readContract(client, {\n      address: nft.contractAddress,\n      abi: [\n        {\n          name: 'uri',\n          type: 'function',\n          stateMutability: 'view',\n          inputs: [{ name: '_id', type: 'uint256' }],\n          outputs: [{ name: '', type: 'string' }],\n        },\n      ],\n      functionName: 'uri',\n      args: [BigInt(nft.tokenID)],\n    })\n  }\n  throw new EnsAvatarUnsupportedNamespaceError({ namespace: nft.namespace })\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}