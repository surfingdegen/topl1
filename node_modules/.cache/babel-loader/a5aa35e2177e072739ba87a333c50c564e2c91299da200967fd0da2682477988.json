{"ast":null,"code":"import { secp256k1 } from '@noble/curves/secp256k1';\nimport * as Address from './Address.js';\nimport * as Bytes from './Bytes.js';\nimport * as Hex from './Hex.js';\nimport * as Entropy from './internal/entropy.js';\nimport * as PublicKey from './PublicKey.js';\n/** Re-export of noble/curves secp256k1 utilities. */\nexport const noble = secp256k1;\n/**\n * Creates a new secp256k1 ECDSA key pair consisting of a private key and its corresponding public key.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const { privateKey, publicKey } = Secp256k1.createKeyPair()\n * ```\n *\n * @param options - The options to generate the key pair.\n * @returns The generated key pair containing both private and public keys.\n */\nexport function createKeyPair(options = {}) {\n  const {\n    as = 'Hex'\n  } = options;\n  const privateKey = randomPrivateKey({\n    as\n  });\n  const publicKey = getPublicKey({\n    privateKey\n  });\n  return {\n    privateKey: privateKey,\n    publicKey\n  };\n}\n/**\n * Computes the secp256k1 ECDSA public key from a provided private key.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const publicKey = Secp256k1.getPublicKey({ privateKey: '0x...' })\n * ```\n *\n * @param options - The options to compute the public key.\n * @returns The computed public key.\n */\nexport function getPublicKey(options) {\n  const {\n    privateKey\n  } = options;\n  const point = secp256k1.ProjectivePoint.fromPrivateKey(Hex.from(privateKey).slice(2));\n  return PublicKey.from(point);\n}\n/**\n * Computes a shared secret using ECDH (Elliptic Curve Diffie-Hellman) between a private key and a public key.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const { privateKey: privateKeyA } = Secp256k1.createKeyPair()\n * const { publicKey: publicKeyB } = Secp256k1.createKeyPair()\n *\n * const sharedSecret = Secp256k1.getSharedSecret({\n *   privateKey: privateKeyA,\n *   publicKey: publicKeyB\n * })\n * ```\n *\n * @param options - The options to compute the shared secret.\n * @returns The computed shared secret.\n */\nexport function getSharedSecret(options) {\n  const {\n    as = 'Hex',\n    privateKey,\n    publicKey\n  } = options;\n  const point = secp256k1.ProjectivePoint.fromHex(PublicKey.toHex(publicKey).slice(2));\n  const sharedPoint = point.multiply(secp256k1.utils.normPrivateKeyToScalar(Hex.from(privateKey).slice(2)));\n  const sharedSecret = sharedPoint.toRawBytes(true); // compressed format\n  if (as === 'Hex') return Hex.fromBytes(sharedSecret);\n  return sharedSecret;\n}\n/**\n * Generates a random ECDSA private key on the secp256k1 curve.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n * ```\n *\n * @param options - The options to generate the private key.\n * @returns The generated private key.\n */\nexport function randomPrivateKey(options = {}) {\n  const {\n    as = 'Hex'\n  } = options;\n  const bytes = secp256k1.utils.randomPrivateKey();\n  if (as === 'Hex') return Hex.fromBytes(bytes);\n  return bytes;\n}\n/**\n * Recovers the signing address from the signed payload and signature.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n *\n * const address = Secp256k1.recoverAddress({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The recovery options.\n * @returns The recovered address.\n */\nexport function recoverAddress(options) {\n  return Address.fromPublicKey(recoverPublicKey(options));\n}\n/**\n * Recovers the signing public key from the signed payload and signature.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n *\n * const publicKey = Secp256k1.recoverPublicKey({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The recovery options.\n * @returns The recovered public key.\n */\nexport function recoverPublicKey(options) {\n  const {\n    payload,\n    signature\n  } = options;\n  const {\n    r,\n    s,\n    yParity\n  } = signature;\n  const signature_ = new secp256k1.Signature(BigInt(r), BigInt(s)).addRecoveryBit(yParity);\n  const point = signature_.recoverPublicKey(Hex.from(payload).substring(2));\n  return PublicKey.from(point);\n}\n/**\n * Signs the payload with the provided private key.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   privateKey: '0x...' // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The signing options.\n * @returns The ECDSA {@link ox#Signature.Signature}.\n */\nexport function sign(options) {\n  const {\n    extraEntropy = Entropy.extraEntropy,\n    hash,\n    payload,\n    privateKey\n  } = options;\n  const {\n    r,\n    s,\n    recovery\n  } = secp256k1.sign(Bytes.from(payload), Bytes.from(privateKey), {\n    extraEntropy: typeof extraEntropy === 'boolean' ? extraEntropy : Hex.from(extraEntropy).slice(2),\n    lowS: true,\n    ...(hash ? {\n      prehash: true\n    } : {})\n  });\n  return {\n    r,\n    s,\n    yParity: recovery\n  };\n}\n/**\n * Verifies a payload was signed by the provided address.\n *\n * @example\n * ### Verify with Ethereum Address\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n *\n * const verified = Secp256k1.verify({ // [!code focus]\n *   address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @example\n * ### Verify with Public Key\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const privateKey = '0x...'\n * const publicKey = Secp256k1.getPublicKey({ privateKey })\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const verified = Secp256k1.verify({ // [!code focus]\n *   publicKey, // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The verification options.\n * @returns Whether the payload was signed by the provided address.\n */\nexport function verify(options) {\n  const {\n    address,\n    hash,\n    payload,\n    publicKey,\n    signature\n  } = options;\n  if (address) return Address.isEqual(address, recoverAddress({\n    payload,\n    signature\n  }));\n  return secp256k1.verify(signature, Bytes.from(payload), PublicKey.toBytes(publicKey), ...(hash ? [{\n    prehash: true,\n    lowS: true\n  }] : []));\n}","map":{"version":3,"names":["secp256k1","Address","Bytes","Hex","Entropy","PublicKey","noble","createKeyPair","options","as","privateKey","randomPrivateKey","publicKey","getPublicKey","point","ProjectivePoint","fromPrivateKey","from","slice","getSharedSecret","fromHex","toHex","sharedPoint","multiply","utils","normPrivateKeyToScalar","sharedSecret","toRawBytes","fromBytes","bytes","recoverAddress","fromPublicKey","recoverPublicKey","payload","signature","r","s","yParity","signature_","Signature","BigInt","addRecoveryBit","substring","sign","extraEntropy","hash","recovery","lowS","prehash","verify","address","isEqual","toBytes"],"sources":["/Users/mac/Desktop/topl1/frontend/node_modules/ox/core/Secp256k1.ts"],"sourcesContent":["import { secp256k1 } from '@noble/curves/secp256k1'\nimport * as Address from './Address.js'\nimport * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport * as Entropy from './internal/entropy.js'\nimport type { OneOf } from './internal/types.js'\nimport * as PublicKey from './PublicKey.js'\nimport type * as Signature from './Signature.js'\n\n/** Re-export of noble/curves secp256k1 utilities. */\nexport const noble = secp256k1\n\n/**\n * Creates a new secp256k1 ECDSA key pair consisting of a private key and its corresponding public key.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const { privateKey, publicKey } = Secp256k1.createKeyPair()\n * ```\n *\n * @param options - The options to generate the key pair.\n * @returns The generated key pair containing both private and public keys.\n */\nexport function createKeyPair<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  options: createKeyPair.Options<as> = {},\n): createKeyPair.ReturnType<as> {\n  const { as = 'Hex' } = options\n  const privateKey = randomPrivateKey({ as })\n  const publicKey = getPublicKey({ privateKey })\n\n  return {\n    privateKey: privateKey as never,\n    publicKey,\n  }\n}\n\nexport declare namespace createKeyPair {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /**\n     * Format of the returned private key.\n     * @default 'Hex'\n     */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> = {\n    privateKey:\n      | (as extends 'Bytes' ? Bytes.Bytes : never)\n      | (as extends 'Hex' ? Hex.Hex : never)\n    publicKey: PublicKey.PublicKey\n  }\n\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | PublicKey.from.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Computes the secp256k1 ECDSA public key from a provided private key.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const publicKey = Secp256k1.getPublicKey({ privateKey: '0x...' })\n * ```\n *\n * @param options - The options to compute the public key.\n * @returns The computed public key.\n */\nexport function getPublicKey(\n  options: getPublicKey.Options,\n): PublicKey.PublicKey {\n  const { privateKey } = options\n  const point = secp256k1.ProjectivePoint.fromPrivateKey(\n    Hex.from(privateKey).slice(2),\n  )\n  return PublicKey.from(point)\n}\n\nexport declare namespace getPublicKey {\n  type Options = {\n    /**\n     * Private key to compute the public key from.\n     */\n    privateKey: Hex.Hex | Bytes.Bytes\n  }\n\n  type ErrorType =\n    | Hex.from.ErrorType\n    | PublicKey.from.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Computes a shared secret using ECDH (Elliptic Curve Diffie-Hellman) between a private key and a public key.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const { privateKey: privateKeyA } = Secp256k1.createKeyPair()\n * const { publicKey: publicKeyB } = Secp256k1.createKeyPair()\n *\n * const sharedSecret = Secp256k1.getSharedSecret({\n *   privateKey: privateKeyA,\n *   publicKey: publicKeyB\n * })\n * ```\n *\n * @param options - The options to compute the shared secret.\n * @returns The computed shared secret.\n */\nexport function getSharedSecret<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  options: getSharedSecret.Options<as>,\n): getSharedSecret.ReturnType<as> {\n  const { as = 'Hex', privateKey, publicKey } = options\n  const point = secp256k1.ProjectivePoint.fromHex(\n    PublicKey.toHex(publicKey).slice(2),\n  )\n  const sharedPoint = point.multiply(\n    secp256k1.utils.normPrivateKeyToScalar(Hex.from(privateKey).slice(2)),\n  )\n  const sharedSecret = sharedPoint.toRawBytes(true) // compressed format\n  if (as === 'Hex') return Hex.fromBytes(sharedSecret) as never\n  return sharedSecret as never\n}\n\nexport declare namespace getSharedSecret {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /**\n     * Format of the returned shared secret.\n     * @default 'Hex'\n     */\n    as?: as | 'Hex' | 'Bytes' | undefined\n    /**\n     * Private key to use for the shared secret computation.\n     */\n    privateKey: Hex.Hex | Bytes.Bytes\n    /**\n     * Public key to use for the shared secret computation.\n     */\n    publicKey: PublicKey.PublicKey<boolean>\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | Hex.from.ErrorType\n    | PublicKey.toHex.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Generates a random ECDSA private key on the secp256k1 curve.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n * ```\n *\n * @param options - The options to generate the private key.\n * @returns The generated private key.\n */\nexport function randomPrivateKey<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  options: randomPrivateKey.Options<as> = {},\n): randomPrivateKey.ReturnType<as> {\n  const { as = 'Hex' } = options\n  const bytes = secp256k1.utils.randomPrivateKey()\n  if (as === 'Hex') return Hex.fromBytes(bytes) as never\n  return bytes as never\n}\n\nexport declare namespace randomPrivateKey {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /**\n     * Format of the returned private key.\n     * @default 'Hex'\n     */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType = Hex.fromBytes.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Recovers the signing address from the signed payload and signature.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n *\n * const address = Secp256k1.recoverAddress({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The recovery options.\n * @returns The recovered address.\n */\nexport function recoverAddress(\n  options: recoverAddress.Options,\n): recoverAddress.ReturnType {\n  return Address.fromPublicKey(recoverPublicKey(options))\n}\n\nexport declare namespace recoverAddress {\n  type Options = {\n    /** Payload that was signed. */\n    payload: Hex.Hex | Bytes.Bytes\n    /** Signature of the payload. */\n    signature: Signature.Signature\n  }\n\n  type ReturnType = Address.Address\n\n  type ErrorType =\n    | Address.fromPublicKey.ErrorType\n    | recoverPublicKey.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Recovers the signing public key from the signed payload and signature.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n *\n * const publicKey = Secp256k1.recoverPublicKey({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The recovery options.\n * @returns The recovered public key.\n */\nexport function recoverPublicKey(\n  options: recoverPublicKey.Options,\n): PublicKey.PublicKey {\n  const { payload, signature } = options\n  const { r, s, yParity } = signature\n  const signature_ = new secp256k1.Signature(\n    BigInt(r),\n    BigInt(s),\n  ).addRecoveryBit(yParity)\n  const point = signature_.recoverPublicKey(Hex.from(payload).substring(2))\n  return PublicKey.from(point)\n}\n\nexport declare namespace recoverPublicKey {\n  type Options = {\n    /** Payload that was signed. */\n    payload: Hex.Hex | Bytes.Bytes\n    /** Signature of the payload. */\n    signature: Signature.Signature\n  }\n\n  type ErrorType =\n    | PublicKey.from.ErrorType\n    | Hex.from.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Signs the payload with the provided private key.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   privateKey: '0x...' // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The signing options.\n * @returns The ECDSA {@link ox#Signature.Signature}.\n */\nexport function sign(options: sign.Options): Signature.Signature {\n  const {\n    extraEntropy = Entropy.extraEntropy,\n    hash,\n    payload,\n    privateKey,\n  } = options\n  const { r, s, recovery } = secp256k1.sign(\n    Bytes.from(payload),\n    Bytes.from(privateKey),\n    {\n      extraEntropy:\n        typeof extraEntropy === 'boolean'\n          ? extraEntropy\n          : Hex.from(extraEntropy).slice(2),\n      lowS: true,\n      ...(hash ? { prehash: true } : {}),\n    },\n  )\n  return {\n    r,\n    s,\n    yParity: recovery,\n  }\n}\n\nexport declare namespace sign {\n  type Options = {\n    /**\n     * Extra entropy to add to the signing process. Setting to `false` will disable it.\n     * @default true\n     */\n    extraEntropy?: boolean | Hex.Hex | Bytes.Bytes | undefined\n    /**\n     *  If set to `true`, the payload will be hashed (sha256) before being signed.\n     */\n    hash?: boolean | undefined\n    /**\n     * Payload to sign.\n     */\n    payload: Hex.Hex | Bytes.Bytes\n    /**\n     * ECDSA private key.\n     */\n    privateKey: Hex.Hex | Bytes.Bytes\n  }\n\n  type ErrorType = Bytes.from.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Verifies a payload was signed by the provided address.\n *\n * @example\n * ### Verify with Ethereum Address\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n *\n * const verified = Secp256k1.verify({ // [!code focus]\n *   address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @example\n * ### Verify with Public Key\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const privateKey = '0x...'\n * const publicKey = Secp256k1.getPublicKey({ privateKey })\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const verified = Secp256k1.verify({ // [!code focus]\n *   publicKey, // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The verification options.\n * @returns Whether the payload was signed by the provided address.\n */\nexport function verify(options: verify.Options): boolean {\n  const { address, hash, payload, publicKey, signature } = options\n  if (address)\n    return Address.isEqual(address, recoverAddress({ payload, signature }))\n  return secp256k1.verify(\n    signature,\n    Bytes.from(payload),\n    PublicKey.toBytes(publicKey),\n    ...(hash ? [{ prehash: true, lowS: true }] : []),\n  )\n}\n\nexport declare namespace verify {\n  type Options = {\n    /** If set to `true`, the payload will be hashed (sha256) before being verified. */\n    hash?: boolean | undefined\n    /** Payload that was signed. */\n    payload: Hex.Hex | Bytes.Bytes\n  } & OneOf<\n    | {\n        /** Address that signed the payload. */\n        address: Address.Address\n        /** Signature of the payload. */\n        signature: Signature.Signature\n      }\n    | {\n        /** Public key that signed the payload. */\n        publicKey: PublicKey.PublicKey<boolean>\n        /** Signature of the payload. */\n        signature: Signature.Signature<false>\n      }\n  >\n\n  type ErrorType = Errors.GlobalErrorType\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}