{"ast":null,"code":"// Copyright (c) 2018-2023 Coinbase, Inc. <https://www.coinbase.com/>\nimport { APP_VERSION_KEY, WALLET_USER_NAME_KEY } from '../constants.js';\nimport { WalletLinkCipher } from './WalletLinkCipher.js';\nimport { WalletLinkHTTP } from './WalletLinkHTTP.js';\nimport { ConnectionState, WalletLinkWebSocket } from './WalletLinkWebSocket.js';\nimport { IntNumber } from '../../../../core/type/index.js';\nconst HEARTBEAT_INTERVAL = 10000;\nconst REQUEST_TIMEOUT = 60000;\n/**\n * Coinbase Wallet Connection\n */\nexport class WalletLinkConnection {\n  /**\n   * Constructor\n   * @param session Session\n   * @param linkAPIUrl Coinbase Wallet link server URL\n   * @param listener WalletLinkConnectionUpdateListener\n   * @param [WebSocketClass] Custom WebSocket implementation\n   */\n  constructor(_ref) {\n    let {\n      session,\n      linkAPIUrl,\n      listener\n    } = _ref;\n    this.destroyed = false;\n    this.lastHeartbeatResponse = 0;\n    this.nextReqId = IntNumber(1);\n    this.reconnectAttempts = 0;\n    this.isReconnecting = false;\n    /**\n     * true if connected and authenticated, else false\n     * runs listener when connected status changes\n     */\n    this._connected = false;\n    /**\n     * true if linked (a guest has joined before)\n     * runs listener when linked status changes\n     */\n    this._linked = false;\n    this.requestResolutions = new Map();\n    this.handleSessionMetadataUpdated = metadata => {\n      if (!metadata) return;\n      // Map of metadata key to handler function\n      const handlers = new Map([['__destroyed', this.handleDestroyed], ['EthereumAddress', this.handleAccountUpdated], ['WalletUsername', this.handleWalletUsernameUpdated], ['AppVersion', this.handleAppVersionUpdated], ['ChainId',\n      // ChainId and JsonRpcUrl are always updated together\n      v => metadata.JsonRpcUrl && this.handleChainUpdated(v, metadata.JsonRpcUrl)]]);\n      // call handler for each metadata key if value is defined\n      handlers.forEach((handler, key) => {\n        const value = metadata[key];\n        if (value === undefined) return;\n        handler(value);\n      });\n    };\n    this.handleDestroyed = __destroyed => {\n      var _a;\n      if (__destroyed !== '1') return;\n      (_a = this.listener) === null || _a === void 0 ? void 0 : _a.resetAndReload();\n    };\n    this.handleAccountUpdated = async encryptedEthereumAddress => {\n      var _a;\n      try {\n        const address = await this.cipher.decrypt(encryptedEthereumAddress);\n        (_a = this.listener) === null || _a === void 0 ? void 0 : _a.accountUpdated(address);\n      } catch (_b) {\n        // Had error decrypting\n      }\n    };\n    this.handleMetadataUpdated = async (key, encryptedMetadataValue) => {\n      var _a;\n      try {\n        const decryptedValue = await this.cipher.decrypt(encryptedMetadataValue);\n        (_a = this.listener) === null || _a === void 0 ? void 0 : _a.metadataUpdated(key, decryptedValue);\n      } catch (_b) {\n        // Had error decrypting\n      }\n    };\n    this.handleWalletUsernameUpdated = async walletUsername => {\n      this.handleMetadataUpdated(WALLET_USER_NAME_KEY, walletUsername);\n    };\n    this.handleAppVersionUpdated = async appVersion => {\n      this.handleMetadataUpdated(APP_VERSION_KEY, appVersion);\n    };\n    this.handleChainUpdated = async (encryptedChainId, encryptedJsonRpcUrl) => {\n      var _a;\n      try {\n        const chainId = await this.cipher.decrypt(encryptedChainId);\n        const jsonRpcUrl = await this.cipher.decrypt(encryptedJsonRpcUrl);\n        (_a = this.listener) === null || _a === void 0 ? void 0 : _a.chainUpdated(chainId, jsonRpcUrl);\n      } catch (_b) {\n        // Had error decrypting\n      }\n    };\n    this.session = session;\n    this.cipher = new WalletLinkCipher(session.secret);\n    this.listener = listener;\n    this.linkAPIUrl = linkAPIUrl;\n    this.WebSocketClass = WebSocket;\n    const ws = this.createWebSocket();\n    this.ws = ws;\n    this.http = new WalletLinkHTTP(linkAPIUrl, session.id, session.key);\n    this.setupVisibilityChangeHandler();\n  }\n  createWebSocket() {\n    const ws = new WalletLinkWebSocket(\"\".concat(this.linkAPIUrl, \"/rpc\"), this.WebSocketClass);\n    // Track this as the active WebSocket instance\n    this.activeWsInstance = ws;\n    ws.setConnectionStateListener(async state => {\n      // Ignore events from non-active WebSocket instances\n      if (ws !== this.activeWsInstance) {\n        return;\n      }\n      // attempt to reconnect every 5 seconds when disconnected\n      let connected = false;\n      switch (state) {\n        case ConnectionState.DISCONNECTED:\n          // Clear heartbeat timer when disconnected\n          if (this.heartbeatIntervalId) {\n            clearInterval(this.heartbeatIntervalId);\n            this.heartbeatIntervalId = undefined;\n          }\n          // Reset lastHeartbeatResponse to prevent false timeout on reconnection\n          this.lastHeartbeatResponse = 0;\n          // Reset connected state to false on disconnect\n          connected = false;\n          // if DISCONNECTED and not destroyed, create a fresh WebSocket connection\n          if (!this.destroyed) {\n            const reconnect = async () => {\n              // Prevent multiple concurrent reconnection attempts\n              if (this.isReconnecting) {\n                return;\n              }\n              this.isReconnecting = true;\n              // 0 second delay on first attempt, then 3 seconds\n              const delay = this.reconnectAttempts === 0 ? 0 : 3000;\n              // wait before reconnecting\n              await new Promise(resolve => setTimeout(resolve, delay));\n              // check whether it's destroyed again and ensure this is still the active instance\n              if (!this.destroyed && ws === this.activeWsInstance) {\n                this.reconnectAttempts++;\n                // Clean up the old WebSocket instance\n                if ('cleanup' in this.ws && typeof this.ws.cleanup === 'function') {\n                  this.ws.cleanup();\n                }\n                // Create a fresh WebSocket instance\n                this.ws = this.createWebSocket();\n                this.ws.connect().catch(() => {\n                  // Reconnection failed, will retry\n                }).finally(() => {\n                  this.isReconnecting = false;\n                });\n              } else {\n                this.isReconnecting = false;\n              }\n            };\n            reconnect();\n          }\n          break;\n        case ConnectionState.CONNECTED:\n          // Reset reconnect attempts on successful connection\n          this.reconnectAttempts = 0;\n          // perform authentication upon connection\n          try {\n            // if CONNECTED, authenticate, and then check link status\n            connected = await this.handleConnected();\n            // Always fetch unseen events when WebSocket state changes to CONNECTED\n            this.fetchUnseenEventsAPI().catch(() => {\n              // Failed to fetch unseen events after connection\n            });\n          } catch (_error) {\n            // Don't set connected to true if authentication fails\n            break;\n          }\n          // Update connected state immediately after successful authentication\n          // This ensures heartbeats won't be skipped\n          this.connected = connected;\n          // send heartbeat every n seconds while connected\n          // if CONNECTED, start the heartbeat timer\n          // first timer event updates lastHeartbeat timestamp\n          // subsequent calls send heartbeat message\n          this.updateLastHeartbeat();\n          // Clear existing heartbeat timer\n          if (this.heartbeatIntervalId) {\n            clearInterval(this.heartbeatIntervalId);\n          }\n          this.heartbeatIntervalId = window.setInterval(() => {\n            this.heartbeat();\n          }, HEARTBEAT_INTERVAL);\n          // Send an immediate heartbeat\n          setTimeout(() => {\n            this.heartbeat();\n          }, 100);\n          break;\n        case ConnectionState.CONNECTING:\n          break;\n      }\n      // Update connected state for DISCONNECTED and CONNECTING cases\n      // For CONNECTED case, it's already set above\n      if (state !== ConnectionState.CONNECTED) {\n        this.connected = connected;\n      }\n    });\n    ws.setIncomingDataListener(m => {\n      var _a;\n      switch (m.type) {\n        // handle server's heartbeat responses\n        case 'Heartbeat':\n          this.updateLastHeartbeat();\n          return;\n        // handle link status updates\n        case 'IsLinkedOK':\n        case 'Linked':\n          {\n            const linked = m.type === 'IsLinkedOK' ? m.linked : undefined;\n            this.linked = linked || m.onlineGuests > 0;\n            break;\n          }\n        // handle session config updates\n        case 'GetSessionConfigOK':\n        case 'SessionConfigUpdated':\n          {\n            this.handleSessionMetadataUpdated(m.metadata);\n            break;\n          }\n        case 'Event':\n          {\n            this.handleIncomingEvent(m);\n            break;\n          }\n      }\n      // resolve request promises\n      if (m.id !== undefined) {\n        (_a = this.requestResolutions.get(m.id)) === null || _a === void 0 ? void 0 : _a(m);\n      }\n    });\n    return ws;\n  }\n  setupVisibilityChangeHandler() {\n    this.visibilityChangeHandler = () => {\n      if (!document.hidden && !this.destroyed) {\n        if (!this.connected) {\n          // Force a fresh connection if we're disconnected\n          this.reconnectWithFreshWebSocket();\n        } else {\n          // Otherwise send a heartbeat to check if connection is still alive\n          this.heartbeat();\n        }\n      }\n    };\n    // Handle focus events (when user switches back to the tab/app)\n    this.focusHandler = () => {\n      if (!this.destroyed && !this.connected) {\n        this.reconnectWithFreshWebSocket();\n      }\n    };\n    // Add event listeners\n    document.addEventListener('visibilitychange', this.visibilityChangeHandler);\n    window.addEventListener('focus', this.focusHandler);\n    window.addEventListener('pageshow', event => {\n      if (event.persisted) {\n        if (this.focusHandler) {\n          this.focusHandler();\n        }\n      }\n    });\n  }\n  reconnectWithFreshWebSocket() {\n    if (this.destroyed) return;\n    // Clear the active instance reference before disconnecting\n    const oldWs = this.ws;\n    this.activeWsInstance = undefined;\n    // Disconnect current WebSocket\n    oldWs.disconnect();\n    // Clean up the old instance\n    if ('cleanup' in oldWs && typeof oldWs.cleanup === 'function') {\n      oldWs.cleanup();\n    }\n    // Create and connect fresh WebSocket\n    this.ws = this.createWebSocket();\n    this.ws.connect().catch(() => {\n      // Fresh reconnection failed\n    });\n  }\n  /**\n   * Make a connection to the server\n   */\n  connect() {\n    if (this.destroyed) {\n      throw new Error('instance is destroyed');\n    }\n    this.ws.connect();\n  }\n  /**\n   * Terminate connection, and mark as destroyed. To reconnect, create a new\n   * instance of WalletSDKConnection\n   */\n  async destroy() {\n    if (this.destroyed) return;\n    await this.makeRequest({\n      type: 'SetSessionConfig',\n      id: IntNumber(this.nextReqId++),\n      sessionId: this.session.id,\n      metadata: {\n        __destroyed: '1'\n      }\n    }, {\n      timeout: 1000\n    });\n    this.destroyed = true;\n    // Clear the active instance reference\n    this.activeWsInstance = undefined;\n    // Clear heartbeat timer\n    if (this.heartbeatIntervalId) {\n      clearInterval(this.heartbeatIntervalId);\n      this.heartbeatIntervalId = undefined;\n    }\n    // Remove event listeners\n    if (this.visibilityChangeHandler) {\n      document.removeEventListener('visibilitychange', this.visibilityChangeHandler);\n    }\n    if (this.focusHandler) {\n      window.removeEventListener('focus', this.focusHandler);\n    }\n    this.ws.disconnect();\n    // Call cleanup on the WebSocket instance if it has the method\n    if ('cleanup' in this.ws && typeof this.ws.cleanup === 'function') {\n      this.ws.cleanup();\n    }\n    this.listener = undefined;\n  }\n  get connected() {\n    return this._connected;\n  }\n  set connected(connected) {\n    this._connected = connected;\n  }\n  get linked() {\n    return this._linked;\n  }\n  set linked(linked) {\n    var _a, _b;\n    this._linked = linked;\n    if (linked) (_a = this.onceLinked) === null || _a === void 0 ? void 0 : _a.call(this);\n    (_b = this.listener) === null || _b === void 0 ? void 0 : _b.linkedUpdated(linked);\n  }\n  setOnceLinked(callback) {\n    return new Promise(resolve => {\n      if (this.linked) {\n        callback().then(resolve);\n      } else {\n        this.onceLinked = () => {\n          callback().then(resolve);\n          this.onceLinked = undefined;\n        };\n      }\n    });\n  }\n  async handleIncomingEvent(m) {\n    var _a;\n    if (m.type !== 'Event' || m.event !== 'Web3Response') {\n      return;\n    }\n    try {\n      const decryptedData = await this.cipher.decrypt(m.data);\n      const message = JSON.parse(decryptedData);\n      if (message.type !== 'WEB3_RESPONSE') return;\n      (_a = this.listener) === null || _a === void 0 ? void 0 : _a.handleWeb3ResponseMessage(message.id, message.response);\n    } catch (_error) {\n      // Had error decrypting\n    }\n  }\n  async checkUnseenEvents() {\n    // Add a small delay to ensure any pending operations complete\n    await new Promise(resolve => setTimeout(resolve, 250));\n    try {\n      await this.fetchUnseenEventsAPI();\n    } catch (e) {\n      console.error('Unable to check for unseen events', e);\n    }\n  }\n  async fetchUnseenEventsAPI() {\n    try {\n      const responseEvents = await this.http.fetchUnseenEvents();\n      responseEvents.forEach(e => {\n        this.handleIncomingEvent(e);\n      });\n    } catch (_error) {\n      // Failed to fetch unseen events\n    }\n  }\n  /**\n   * Publish an event and emit event ID when successful\n   * @param event event name\n   * @param unencryptedData unencrypted event data\n   * @param callWebhook whether the webhook should be invoked\n   * @returns a Promise that emits event ID when successful\n   */\n  async publishEvent(event, unencryptedData) {\n    let callWebhook = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const data = await this.cipher.encrypt(JSON.stringify(Object.assign(Object.assign({}, unencryptedData), {\n      origin: location.origin,\n      location: location.href,\n      relaySource: 'coinbaseWalletExtension' in window && window.coinbaseWalletExtension ? 'injected_sdk' : 'sdk'\n    })));\n    const message = {\n      type: 'PublishEvent',\n      id: IntNumber(this.nextReqId++),\n      sessionId: this.session.id,\n      event,\n      data,\n      callWebhook\n    };\n    return this.setOnceLinked(async () => {\n      const res = await this.makeRequest(message);\n      if (res.type === 'Fail') {\n        throw new Error(res.error || 'failed to publish event');\n      }\n      return res.eventId;\n    });\n  }\n  sendData(message) {\n    this.ws.sendData(JSON.stringify(message));\n  }\n  updateLastHeartbeat() {\n    this.lastHeartbeatResponse = Date.now();\n  }\n  heartbeat() {\n    if (Date.now() - this.lastHeartbeatResponse > HEARTBEAT_INTERVAL * 2) {\n      this.ws.disconnect();\n      return;\n    }\n    // Only send heartbeat if we're connected\n    if (!this.connected) {\n      return;\n    }\n    try {\n      this.ws.sendData('h');\n    } catch (_error) {\n      // Error sending heartbeat\n    }\n  }\n  async makeRequest(message) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      timeout: REQUEST_TIMEOUT\n    };\n    const reqId = message.id;\n    this.sendData(message);\n    // await server message with corresponding id\n    let timeoutId;\n    return Promise.race([new Promise((_, reject) => {\n      timeoutId = window.setTimeout(() => {\n        reject(new Error(\"request \".concat(reqId, \" timed out\")));\n      }, options.timeout);\n    }), new Promise(resolve => {\n      this.requestResolutions.set(reqId, m => {\n        clearTimeout(timeoutId); // clear the timeout\n        resolve(m);\n        this.requestResolutions.delete(reqId);\n      });\n    })]);\n  }\n  async handleConnected() {\n    const res = await this.makeRequest({\n      type: 'HostSession',\n      id: IntNumber(this.nextReqId++),\n      sessionId: this.session.id,\n      sessionKey: this.session.key\n    });\n    if (res.type === 'Fail') {\n      return false;\n    }\n    this.sendData({\n      type: 'IsLinked',\n      id: IntNumber(this.nextReqId++),\n      sessionId: this.session.id\n    });\n    this.sendData({\n      type: 'GetSessionConfig',\n      id: IntNumber(this.nextReqId++),\n      sessionId: this.session.id\n    });\n    return true;\n  }\n}","map":{"version":3,"names":["APP_VERSION_KEY","WALLET_USER_NAME_KEY","WalletLinkCipher","WalletLinkHTTP","ConnectionState","WalletLinkWebSocket","IntNumber","HEARTBEAT_INTERVAL","REQUEST_TIMEOUT","WalletLinkConnection","constructor","_ref","session","linkAPIUrl","listener","destroyed","lastHeartbeatResponse","nextReqId","reconnectAttempts","isReconnecting","_connected","_linked","requestResolutions","Map","handleSessionMetadataUpdated","metadata","handlers","handleDestroyed","handleAccountUpdated","handleWalletUsernameUpdated","handleAppVersionUpdated","v","JsonRpcUrl","handleChainUpdated","forEach","handler","key","value","undefined","__destroyed","_a","resetAndReload","encryptedEthereumAddress","address","cipher","decrypt","accountUpdated","_b","handleMetadataUpdated","encryptedMetadataValue","decryptedValue","metadataUpdated","walletUsername","appVersion","encryptedChainId","encryptedJsonRpcUrl","chainId","jsonRpcUrl","chainUpdated","secret","WebSocketClass","WebSocket","ws","createWebSocket","http","id","setupVisibilityChangeHandler","concat","activeWsInstance","setConnectionStateListener","state","connected","DISCONNECTED","heartbeatIntervalId","clearInterval","reconnect","delay","Promise","resolve","setTimeout","cleanup","connect","catch","finally","CONNECTED","handleConnected","fetchUnseenEventsAPI","_error","updateLastHeartbeat","window","setInterval","heartbeat","CONNECTING","setIncomingDataListener","m","type","linked","onlineGuests","handleIncomingEvent","get","visibilityChangeHandler","document","hidden","reconnectWithFreshWebSocket","focusHandler","addEventListener","event","persisted","oldWs","disconnect","Error","destroy","makeRequest","sessionId","timeout","removeEventListener","onceLinked","call","linkedUpdated","setOnceLinked","callback","then","decryptedData","data","message","JSON","parse","handleWeb3ResponseMessage","response","checkUnseenEvents","e","console","error","responseEvents","fetchUnseenEvents","publishEvent","unencryptedData","callWebhook","arguments","length","encrypt","stringify","Object","assign","origin","location","href","relaySource","coinbaseWalletExtension","res","eventId","sendData","Date","now","options","reqId","timeoutId","race","_","reject","set","clearTimeout","delete","sessionKey"],"sources":["../../../../../src/sign/walletlink/relay/connection/WalletLinkConnection.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}