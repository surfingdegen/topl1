{"ast":null,"code":"import { IntegerOutOfRangeError } from '../../errors/encoding.js';\nimport { pad } from '../data/pad.js';\nimport { assertSize } from './fromHex.js';\nconst hexes = /*#__PURE__*/Array.from({\n  length: 256\n}, (_v, i) => i.toString(16).padStart(2, '0'));\n/**\n * Encodes a string, number, bigint, or ByteArray into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex\n * - Example: https://viem.sh/docs/utilities/toHex#usage\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex('Hello world')\n * // '0x48656c6c6f20776f726c6421'\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex(420)\n * // '0x1a4'\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex('Hello world', { size: 32 })\n * // '0x48656c6c6f20776f726c64210000000000000000000000000000000000000000'\n */\nexport function toHex(value) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (typeof value === 'number' || typeof value === 'bigint') return numberToHex(value, opts);\n  if (typeof value === 'string') {\n    return stringToHex(value, opts);\n  }\n  if (typeof value === 'boolean') return boolToHex(value, opts);\n  return bytesToHex(value, opts);\n}\n/**\n * Encodes a boolean into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#booltohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(true)\n * // '0x1'\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(false)\n * // '0x0'\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(true, { size: 32 })\n * // '0x0000000000000000000000000000000000000000000000000000000000000001'\n */\nexport function boolToHex(value) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const hex = \"0x\".concat(Number(value));\n  if (typeof opts.size === 'number') {\n    assertSize(hex, {\n      size: opts.size\n    });\n    return pad(hex, {\n      size: opts.size\n    });\n  }\n  return hex;\n}\n/**\n * Encodes a bytes array into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#bytestohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { bytesToHex } from 'viem'\n * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * // '0x48656c6c6f20576f726c6421'\n *\n * @example\n * import { bytesToHex } from 'viem'\n * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]), { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n */\nexport function bytesToHex(value) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let string = '';\n  for (let i = 0; i < value.length; i++) {\n    string += hexes[value[i]];\n  }\n  const hex = \"0x\".concat(string);\n  if (typeof opts.size === 'number') {\n    assertSize(hex, {\n      size: opts.size\n    });\n    return pad(hex, {\n      dir: 'right',\n      size: opts.size\n    });\n  }\n  return hex;\n}\n/**\n * Encodes a number or bigint into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#numbertohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { numberToHex } from 'viem'\n * const data = numberToHex(420)\n * // '0x1a4'\n *\n * @example\n * import { numberToHex } from 'viem'\n * const data = numberToHex(420, { size: 32 })\n * // '0x00000000000000000000000000000000000000000000000000000000000001a4'\n */\nexport function numberToHex(value_) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    signed,\n    size\n  } = opts;\n  const value = BigInt(value_);\n  let maxValue;\n  if (size) {\n    if (signed) maxValue = (1n << BigInt(size) * 8n - 1n) - 1n;else maxValue = 2n ** (BigInt(size) * 8n) - 1n;\n  } else if (typeof value_ === 'number') {\n    maxValue = BigInt(Number.MAX_SAFE_INTEGER);\n  }\n  const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0;\n  if (maxValue && value > maxValue || value < minValue) {\n    const suffix = typeof value_ === 'bigint' ? 'n' : '';\n    throw new IntegerOutOfRangeError({\n      max: maxValue ? \"\".concat(maxValue).concat(suffix) : undefined,\n      min: \"\".concat(minValue).concat(suffix),\n      signed,\n      size,\n      value: \"\".concat(value_).concat(suffix)\n    });\n  }\n  const hex = \"0x\".concat((signed && value < 0 ? (1n << BigInt(size * 8)) + BigInt(value) : value).toString(16));\n  if (size) return pad(hex, {\n    size\n  });\n  return hex;\n}\nconst encoder = /*#__PURE__*/new TextEncoder();\n/**\n * Encodes a UTF-8 string into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#stringtohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { stringToHex } from 'viem'\n * const data = stringToHex('Hello World!')\n * // '0x48656c6c6f20576f726c6421'\n *\n * @example\n * import { stringToHex } from 'viem'\n * const data = stringToHex('Hello World!', { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n */\nexport function stringToHex(value_) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const value = encoder.encode(value_);\n  return bytesToHex(value, opts);\n}","map":{"version":3,"names":["IntegerOutOfRangeError","pad","assertSize","hexes","Array","from","length","_v","i","toString","padStart","toHex","value","opts","arguments","undefined","numberToHex","stringToHex","boolToHex","bytesToHex","hex","concat","Number","size","string","dir","value_","signed","BigInt","maxValue","MAX_SAFE_INTEGER","minValue","suffix","max","min","encoder","TextEncoder","encode"],"sources":["/Users/mac/Desktop/topl1/frontend/node_modules/viem/utils/encoding/toHex.ts"],"sourcesContent":["import {\n  IntegerOutOfRangeError,\n  type IntegerOutOfRangeErrorType,\n} from '../../errors/encoding.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type PadErrorType, pad } from '../data/pad.js'\n\nimport { type AssertSizeErrorType, assertSize } from './fromHex.js'\n\nconst hexes = /*#__PURE__*/ Array.from({ length: 256 }, (_v, i) =>\n  i.toString(16).padStart(2, '0'),\n)\n\nexport type ToHexParameters = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number | undefined\n}\n\nexport type ToHexErrorType =\n  | BoolToHexErrorType\n  | BytesToHexErrorType\n  | NumberToHexErrorType\n  | StringToHexErrorType\n  | ErrorType\n\n/**\n * Encodes a string, number, bigint, or ByteArray into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex\n * - Example: https://viem.sh/docs/utilities/toHex#usage\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex('Hello world')\n * // '0x48656c6c6f20776f726c6421'\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex(420)\n * // '0x1a4'\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex('Hello world', { size: 32 })\n * // '0x48656c6c6f20776f726c64210000000000000000000000000000000000000000'\n */\nexport function toHex(\n  value: string | number | bigint | boolean | ByteArray,\n  opts: ToHexParameters = {},\n): Hex {\n  if (typeof value === 'number' || typeof value === 'bigint')\n    return numberToHex(value, opts)\n  if (typeof value === 'string') {\n    return stringToHex(value, opts)\n  }\n  if (typeof value === 'boolean') return boolToHex(value, opts)\n  return bytesToHex(value, opts)\n}\n\nexport type BoolToHexOpts = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number | undefined\n}\n\nexport type BoolToHexErrorType = AssertSizeErrorType | PadErrorType | ErrorType\n\n/**\n * Encodes a boolean into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#booltohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(true)\n * // '0x1'\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(false)\n * // '0x0'\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(true, { size: 32 })\n * // '0x0000000000000000000000000000000000000000000000000000000000000001'\n */\nexport function boolToHex(value: boolean, opts: BoolToHexOpts = {}): Hex {\n  const hex: Hex = `0x${Number(value)}`\n  if (typeof opts.size === 'number') {\n    assertSize(hex, { size: opts.size })\n    return pad(hex, { size: opts.size })\n  }\n  return hex\n}\n\nexport type BytesToHexOpts = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number | undefined\n}\n\nexport type BytesToHexErrorType = AssertSizeErrorType | PadErrorType | ErrorType\n\n/**\n * Encodes a bytes array into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#bytestohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { bytesToHex } from 'viem'\n * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * // '0x48656c6c6f20576f726c6421'\n *\n * @example\n * import { bytesToHex } from 'viem'\n * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]), { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n */\nexport function bytesToHex(value: ByteArray, opts: BytesToHexOpts = {}): Hex {\n  let string = ''\n  for (let i = 0; i < value.length; i++) {\n    string += hexes[value[i]]\n  }\n  const hex = `0x${string}` as const\n\n  if (typeof opts.size === 'number') {\n    assertSize(hex, { size: opts.size })\n    return pad(hex, { dir: 'right', size: opts.size })\n  }\n  return hex\n}\n\nexport type NumberToHexOpts =\n  | {\n      /** Whether or not the number of a signed representation. */\n      signed?: boolean | undefined\n      /** The size (in bytes) of the output hex value. */\n      size: number\n    }\n  | {\n      signed?: undefined\n      /** The size (in bytes) of the output hex value. */\n      size?: number | undefined\n    }\n\nexport type NumberToHexErrorType =\n  | IntegerOutOfRangeErrorType\n  | PadErrorType\n  | ErrorType\n\n/**\n * Encodes a number or bigint into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#numbertohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { numberToHex } from 'viem'\n * const data = numberToHex(420)\n * // '0x1a4'\n *\n * @example\n * import { numberToHex } from 'viem'\n * const data = numberToHex(420, { size: 32 })\n * // '0x00000000000000000000000000000000000000000000000000000000000001a4'\n */\nexport function numberToHex(\n  value_: number | bigint,\n  opts: NumberToHexOpts = {},\n): Hex {\n  const { signed, size } = opts\n\n  const value = BigInt(value_)\n\n  let maxValue: bigint | number | undefined\n  if (size) {\n    if (signed) maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n\n    else maxValue = 2n ** (BigInt(size) * 8n) - 1n\n  } else if (typeof value_ === 'number') {\n    maxValue = BigInt(Number.MAX_SAFE_INTEGER)\n  }\n\n  const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0\n\n  if ((maxValue && value > maxValue) || value < minValue) {\n    const suffix = typeof value_ === 'bigint' ? 'n' : ''\n    throw new IntegerOutOfRangeError({\n      max: maxValue ? `${maxValue}${suffix}` : undefined,\n      min: `${minValue}${suffix}`,\n      signed,\n      size,\n      value: `${value_}${suffix}`,\n    })\n  }\n\n  const hex = `0x${(\n    signed && value < 0 ? (1n << BigInt(size * 8)) + BigInt(value) : value\n  ).toString(16)}` as Hex\n  if (size) return pad(hex, { size }) as Hex\n  return hex\n}\n\nexport type StringToHexOpts = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number | undefined\n}\n\nexport type StringToHexErrorType = BytesToHexErrorType | ErrorType\n\nconst encoder = /*#__PURE__*/ new TextEncoder()\n\n/**\n * Encodes a UTF-8 string into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#stringtohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { stringToHex } from 'viem'\n * const data = stringToHex('Hello World!')\n * // '0x48656c6c6f20576f726c6421'\n *\n * @example\n * import { stringToHex } from 'viem'\n * const data = stringToHex('Hello World!', { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n */\nexport function stringToHex(value_: string, opts: StringToHexOpts = {}): Hex {\n  const value = encoder.encode(value_)\n  return bytesToHex(value, opts)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}